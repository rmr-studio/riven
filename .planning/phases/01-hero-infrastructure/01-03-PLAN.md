---
phase: 01-hero-infrastructure
plan: 03
type: execute
wave: 3
depends_on: ["01-02"]
files_modified:
  - landing/lib/validations.ts
  - landing/app/api/waitlist/route.ts
  - landing/hooks/use-waitlist-mutation.ts
  - landing/components/waitlist-form.tsx
autonomous: true

must_haves:
  truths:
    - "Email validation rejects invalid formats before submission"
    - "Form shows loading state during API call"
    - "Form shows success message after successful submission"
    - "Form shows error toast when submission fails"
    - "API endpoint returns appropriate status codes"
  artifacts:
    - path: "landing/lib/validations.ts"
      provides: "Zod schema for email validation"
      exports: ["waitlistSchema", "WaitlistFormData"]
    - path: "landing/app/api/waitlist/route.ts"
      provides: "POST endpoint for waitlist signup"
      exports: ["POST"]
    - path: "landing/hooks/use-waitlist-mutation.ts"
      provides: "TanStack mutation with toast lifecycle"
      exports: ["useWaitlistMutation"]
    - path: "landing/components/waitlist-form.tsx"
      provides: "Email form with validation and states"
      exports: ["WaitlistForm"]
  key_links:
    - from: "landing/components/waitlist-form.tsx"
      to: "landing/hooks/use-waitlist-mutation.ts"
      via: "hook import and usage"
      pattern: "useWaitlistMutation"
    - from: "landing/hooks/use-waitlist-mutation.ts"
      to: "/api/waitlist"
      via: "fetch call"
      pattern: "fetch.*api/waitlist"
    - from: "landing/components/waitlist-form.tsx"
      to: "landing/lib/validations.ts"
      via: "zodResolver"
      pattern: "zodResolver.*waitlistSchema"
---

<objective>
Build the complete form infrastructure: validation schema, API endpoint, mutation hook, and WaitlistForm component.

Purpose: This is the core conversion mechanism - the form that captures waitlist signups. It must validate emails, show clear feedback during submission, and handle success/error states gracefully.

Output: Working WaitlistForm component that validates email, calls API, shows loading/success/error states with toast notifications.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-hero-infrastructure/01-RESEARCH.md

@landing/components/ui/button.tsx
@landing/components/ui/input.tsx
@landing/providers/query-provider.tsx
@landing/lib/utils.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create validation schema and API route</name>
  <files>landing/lib/validations.ts, landing/app/api/waitlist/route.ts</files>
  <action>
**Create lib/validations.ts:**

Create `/home/jared/dev/riven-landing-worktree/landing/lib/validations.ts`:

```typescript
import { z } from "zod";

export const waitlistSchema = z.object({
  email: z
    .string()
    .min(1, "Email is required")
    .email("Please enter a valid email address"),
});

export type WaitlistFormData = z.infer<typeof waitlistSchema>;
```

**Create API route:**

Create `/home/jared/dev/riven-landing-worktree/landing/app/api/waitlist/route.ts`:

```typescript
import { NextResponse } from "next/server";

export async function POST(request: Request) {
  try {
    const body = await request.json();
    const { email } = body;

    if (!email || typeof email !== "string") {
      return NextResponse.json(
        { success: false, message: "Email is required" },
        { status: 400 }
      );
    }

    // Basic email format check (backup validation)
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(email)) {
      return NextResponse.json(
        { success: false, message: "Invalid email format" },
        { status: 400 }
      );
    }

    // TODO: User will wire this to actual backend
    // For now, log and return success
    console.log("[Waitlist] New signup:", email);

    return NextResponse.json({
      success: true,
      message: "Successfully joined the waitlist",
    });
  } catch (error) {
    console.error("[Waitlist] Error:", error);
    return NextResponse.json(
      { success: false, message: "Something went wrong. Please try again." },
      { status: 500 }
    );
  }
}
```

Note: The API route is a stub per PROJECT.md scope - user wires backend separately.
  </action>
  <verify>
1. `ls landing/lib/validations.ts` - File exists
2. `ls landing/app/api/waitlist/route.ts` - File exists
3. `grep "waitlistSchema" landing/lib/validations.ts` - Schema exported
4. `npm run build` - Build succeeds
  </verify>
  <done>Zod schema validates email format, API route returns 200/400/500 appropriately</done>
</task>

<task type="auto">
  <name>Task 2: Create waitlist mutation hook</name>
  <files>landing/hooks/use-waitlist-mutation.ts</files>
  <action>
Create `/home/jared/dev/riven-landing-worktree/landing/hooks/use-waitlist-mutation.ts`:

```typescript
"use client";

import { useMutation } from "@tanstack/react-query";
import { toast } from "sonner";
import { useRef } from "react";

interface WaitlistSubmission {
  email: string;
}

interface WaitlistResponse {
  success: boolean;
  message?: string;
}

export function useWaitlistMutation() {
  const toastRef = useRef<string | number | undefined>(undefined);

  return useMutation({
    mutationFn: async (data: WaitlistSubmission): Promise<WaitlistResponse> => {
      const response = await fetch("/api/waitlist", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(data),
      });

      const result = await response.json();

      if (!response.ok) {
        throw new Error(result.message || "Failed to join waitlist");
      }

      return result;
    },
    onMutate: () => {
      toastRef.current = toast.loading("Joining waitlist...");
    },
    onSuccess: () => {
      toast.success("You're on the list! We'll be in touch.", {
        id: toastRef.current,
      });
    },
    onError: (error: Error) => {
      toast.error(error.message, { id: toastRef.current });
    },
  });
}
```

Key patterns from RESEARCH.md:
- useRef for toast ID to enable loading -> success/error transition
- Object syntax for useMutation (v5 pattern)
- Error extraction from response body
  </action>
  <verify>
1. `ls landing/hooks/use-waitlist-mutation.ts` - File exists
2. `grep "toastRef" landing/hooks/use-waitlist-mutation.ts` - Uses toast ID pattern
3. `grep "onMutate" landing/hooks/use-waitlist-mutation.ts` - Has loading state
4. `npm run build` - Build succeeds
  </verify>
  <done>Mutation hook shows loading toast, transitions to success/error, uses correct v5 syntax</done>
</task>

<task type="auto">
  <name>Task 3: Create WaitlistForm component</name>
  <files>landing/components/waitlist-form.tsx</files>
  <action>
Create `/home/jared/dev/riven-landing-worktree/landing/components/waitlist-form.tsx`:

```typescript
"use client";

import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { CheckCircle2, Loader2 } from "lucide-react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { useWaitlistMutation } from "@/hooks/use-waitlist-mutation";
import { waitlistSchema, type WaitlistFormData } from "@/lib/validations";
import { cn } from "@/lib/utils";

export function WaitlistForm({ className }: { className?: string }) {
  const { mutate, isPending, isSuccess } = useWaitlistMutation();

  const form = useForm<WaitlistFormData>({
    resolver: zodResolver(waitlistSchema),
    defaultValues: { email: "" },
    mode: "onBlur",
  });

  const onSubmit = (data: WaitlistFormData) => {
    mutate(data);
  };

  // Success state - form is replaced with confirmation
  if (isSuccess) {
    return (
      <div
        className={cn(
          "flex items-center gap-2 text-primary font-medium",
          className
        )}
      >
        <CheckCircle2 className="h-5 w-5" />
        <span>You're on the list! We'll be in touch.</span>
      </div>
    );
  }

  return (
    <form
      onSubmit={form.handleSubmit(onSubmit)}
      className={cn("flex flex-col gap-3 sm:flex-row sm:gap-2", className)}
    >
      <div className="flex-1">
        <Input
          {...form.register("email")}
          type="email"
          placeholder="Enter your email"
          disabled={isPending}
          className={cn(
            "h-12",
            form.formState.errors.email && "border-destructive"
          )}
          aria-invalid={!!form.formState.errors.email}
          aria-describedby={
            form.formState.errors.email ? "email-error" : undefined
          }
        />
        {form.formState.errors.email && (
          <p id="email-error" className="mt-1 text-sm text-destructive">
            {form.formState.errors.email.message}
          </p>
        )}
      </div>
      <Button type="submit" size="lg" disabled={isPending} className="h-12">
        {isPending ? (
          <>
            <Loader2 className="h-4 w-4 animate-spin" />
            Joining...
          </>
        ) : (
          "Join Waitlist"
        )}
      </Button>
    </form>
  );
}
```

Requirements addressed:
- HERO-03: Single email field + submit button
- HERO-04: Zod validation before submission
- HERO-05: Loader2 spinner during isPending
- HERO-06: Success state with checkmark after isSuccess
- HERO-07: Error via toast (handled in mutation hook)
- TECH-03: React Hook Form + Zod

Accessibility: aria-invalid, aria-describedby for error messages.
  </action>
  <verify>
1. `ls landing/components/waitlist-form.tsx` - File exists
2. `grep "isPending" landing/components/waitlist-form.tsx` - Has loading state
3. `grep "isSuccess" landing/components/waitlist-form.tsx` - Has success state
4. `grep "Loader2" landing/components/waitlist-form.tsx` - Uses loading spinner
5. `npm run build` - Build succeeds
  </verify>
  <done>WaitlistForm validates email, shows loading spinner during submission, displays success state after, uses accessible error messaging</done>
</task>

</tasks>

<verification>
1. `npm run build` in landing directory - Should complete without errors
2. `npm run dev` and POST to /api/waitlist with valid email - Returns 200
3. `npm run dev` and POST to /api/waitlist with invalid email - Returns 400
4. All files in correct locations with proper exports
</verification>

<success_criteria>
- Zod schema rejects invalid emails with clear message (HERO-04)
- API route returns 200 for valid email, 400 for invalid, 500 for errors
- Mutation hook shows loading toast, transitions to success/error
- WaitlistForm shows loading spinner during submission (HERO-05)
- WaitlistForm shows success confirmation after submission (HERO-06)
- Error toast appears on failure (HERO-07)
- Form is disabled during submission to prevent double-submit
</success_criteria>

<output>
After completion, create `.planning/phases/01-hero-infrastructure/01-03-SUMMARY.md`
</output>
