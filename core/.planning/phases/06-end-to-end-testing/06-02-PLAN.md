---
phase: 06-end-to-end-testing
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - src/test/kotlin/riven/core/service/entity/query/EntityQueryIntegrationTestBase.kt
  - src/test/kotlin/riven/core/service/entity/query/EntityQueryRelationshipIntegrationTest.kt
  - src/test/kotlin/riven/core/service/entity/query/EntityQueryPaginationIntegrationTest.kt
  - src/test/kotlin/riven/core/service/entity/query/EntityQueryErrorPathIntegrationTest.kt
autonomous: true

must_haves:
  truths:
    - "EXISTS condition returns companies that have at least one employee relationship"
    - "NOT_EXISTS condition returns companies that have no employee relationships"
    - "TargetEquals condition returns companies related to specific employee IDs"
    - "TargetMatches condition returns companies whose employees match nested attribute filter"
    - "TargetTypeMatches condition returns companies using OR semantics across Employee/Project type branches"
    - "1-deep, 2-deep, and 3-deep nested relationship queries return correct results"
    - "Depth > maxDepth (3) is rejected with QueryValidationException"
    - "Invalid attribute reference throws QueryValidationException with InvalidAttributeReferenceException"
    - "Invalid relationship reference throws QueryValidationException with InvalidRelationshipReferenceException"
    - "Pagination limit/offset returns correct page slices with accurate totalCount and hasNextPage"
    - "Workspace isolation prevents cross-tenant data leakage"
  artifacts:
    - path: "src/test/kotlin/riven/core/service/entity/query/EntityQueryRelationshipIntegrationTest.kt"
      provides: "Integration tests for all 5 relationship conditions plus depth nesting"
      min_lines: 150
    - path: "src/test/kotlin/riven/core/service/entity/query/EntityQueryPaginationIntegrationTest.kt"
      provides: "Integration tests for pagination, ordering, and workspace isolation"
      min_lines: 80
    - path: "src/test/kotlin/riven/core/service/entity/query/EntityQueryErrorPathIntegrationTest.kt"
      provides: "Integration tests for error paths (invalid refs, depth exceeded, bad pagination)"
      min_lines: 60
  key_links:
    - from: "EntityQueryRelationshipIntegrationTest.kt"
      to: "EntityQueryService.execute"
      via: "Direct service call via runBlocking with relationship filters"
      pattern: "QueryFilter.Relationship"
    - from: "EntityQueryPaginationIntegrationTest.kt"
      to: "EntityQueryService.execute"
      via: "Direct service call with QueryPagination"
      pattern: "QueryPagination"
    - from: "EntityQueryErrorPathIntegrationTest.kt"
      to: "QueryValidationException"
      via: "assertThrows on invalid references"
      pattern: "assertThrows.*QueryValidationException"
---

<objective>
Validate relationship filtering (all 5 conditions + depth nesting), pagination/ordering, workspace isolation, and error paths against real PostgreSQL.

Purpose: Complete the end-to-end validation of the entity query pipeline by testing the relationship subsystem, pagination mechanics, security isolation, and error handling -- the areas that depend on the test infrastructure and seed data from Plan 01.

Output: Three test classes covering relationship conditions, pagination/workspace, and error paths -- all passing against Testcontainers PostgreSQL.
</objective>

<execution_context>
@/home/jared/.claude/get-shit-done/workflows/execute-plan.md
@/home/jared/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-end-to-end-testing/06-CONTEXT.md
@.planning/phases/06-end-to-end-testing/06-RESEARCH.md
@.planning/phases/06-end-to-end-testing/06-01-SUMMARY.md
@src/main/kotlin/riven/core/service/entity/query/EntityQueryService.kt
@src/main/kotlin/riven/core/service/entity/query/RelationshipSqlGenerator.kt
@src/main/kotlin/riven/core/service/entity/query/AttributeFilterVisitor.kt
@src/main/kotlin/riven/core/service/entity/query/QueryFilterValidator.kt
@src/main/kotlin/riven/core/service/entity/query/EntityQueryAssembler.kt
@src/main/kotlin/riven/core/models/entity/query/EntityQuery.kt
@src/main/kotlin/riven/core/models/entity/query/QueryFilter.kt
@src/main/kotlin/riven/core/models/entity/query/RelationshipCondition.kt
@src/main/kotlin/riven/core/models/entity/query/QueryPagination.kt
@src/main/kotlin/riven/core/models/entity/query/EntityQueryResult.kt
@src/main/kotlin/riven/core/entity/entity/EntityRelationshipEntity.kt
@src/main/kotlin/riven/core/exceptions/query/QueryFilterException.kt
@src/test/kotlin/riven/core/service/entity/query/EntityQueryIntegrationTestBase.kt
@src/test/kotlin/riven/core/service/entity/query/EntityQueryAttributeFilterIntegrationTest.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create relationship filter integration tests</name>
  <files>src/test/kotlin/riven/core/service/entity/query/EntityQueryRelationshipIntegrationTest.kt</files>
  <action>
Create `EntityQueryRelationshipIntegrationTest` extending `EntityQueryIntegrationTestBase`.

This test class validates all 5 relationship conditions and depth nesting against real PostgreSQL. All tests query Company entities using the relationship IDs defined in the base class.

**Relationship Condition Tests:**

1. `test EXISTS returns companies with employees` -- Filter companies where `companyEmployeesRelId` EXISTS. Expect: all companies that have at least one employee relationship row. Assert result entities are the correct subset. The exact count depends on the seed data from Plan 01 -- verify against the known relationship data.

2. `test NOT_EXISTS returns companies without employees` -- Filter companies where `companyEmployeesRelId` NOT_EXISTS. Expect: companies with no employee relationships. If all 10 companies have employees, seed at least 1-2 companies without employees in the base class (or adjust base class if needed -- note this in the code).

3. `test TargetEquals returns companies related to specific employees` -- Filter companies where `companyEmployeesRelId` TargetEquals with a list of 2 specific employee entity IDs (use known IDs from seed data). Expect: only the companies that have relationships to those specific employees.

4. `test TargetMatches returns companies with high-salary employees` -- Filter companies where `companyEmployeesRelId` TargetMatches with nested filter: employee `salary` GREATER_THAN 100000. This exercises the EXISTS subquery with JOIN to entities table and nested attribute filter. Expect: companies that have at least one employee with salary > 100000.

5. `test TargetTypeMatches with OR semantics across type branches` -- Filter companies where `companyOwnerRelId` (polymorphic) TargetTypeMatches with two branches:
   - Branch 1: entityTypeId = employeeTypeId, filter = department EQUALS "Engineering"
   - Branch 2: entityTypeId = projectTypeId, filter = status EQUALS "Active"
   This exercises the polymorphic OR branching. Expect: companies that have an owner that is either an Engineering employee OR an Active project.

6. `test TargetTypeMatches with no filter on a branch` -- Filter companies where `companyOwnerRelId` TargetTypeMatches with:
   - Branch 1: entityTypeId = employeeTypeId, filter = null (any employee)
   Expect: companies that have any employee as owner.

**Depth Nesting Tests:**

7. `test 1-deep relationship nesting succeeds` -- Simple single-level relationship filter (same as EXISTS test above, just explicit about depth).

8. `test 2-deep relationship nesting succeeds` -- This requires a relationship chain. Since we have Company -> Employee, we'd need Employee -> something. Add an Employee -> Project relationship definition on the Employee entity type in the base class setup (e.g., `employeeProjectsRelId`). Then filter: Company where employees exist that have related projects with TargetMatches on project status. This creates Company -> Employee -> Project (2 relationship levels). The base class MUST be modified to include this relationship definition and seed relationship data for Employee -> Project links.

9. `test 3-deep relationship nesting succeeds` -- This requires a 3-level chain. Add a Project -> Company relationship definition on the Project entity type in the base class (e.g., `projectClientRelId`). Then filter: Company where employees exist that have projects that have a client company matching a name filter. This creates Company -> Employee -> Project -> Company (3 relationship levels). Use `maxDepth=3` (the default). Verify the query executes and returns correct results. The base class MUST be modified to include this relationship and seed data.

10. `test depth exceeding maxDepth is rejected` -- Create a query with maxDepth=1 but 2-deep relationship nesting. Use `assertThrows<QueryValidationException>`. The exception should contain a `RelationshipDepthExceededException` in its `validationErrors`.

**Combined Attribute + Relationship Test:**

11. `test AND of attribute filter and relationship filter` -- Filter companies where industry EQUALS "Technology" AND has employees (EXISTS). Verifies mixed filter types compose correctly.

**NOTE on test data for relationship tests:**
- Ensure the base class seeds relationships with known, deterministic assignments so you can predict exact result counts.
- For NOT_EXISTS, ensure at least 1-2 companies have NO employees.
- For TargetMatches, ensure at least some employees have salary > 100000 and some don't.
- For TargetTypeMatches, ensure the polymorphic `companyOwnerRelId` has relationships to both Employee and Project entity types.
- For 2-deep nesting, add an Employee -> Project relationship definition on the Employee entity type in the base class setup.
- For 3-deep nesting, add a Project -> Company relationship definition on the Project entity type in the base class setup.
- The base class from Plan 01 WILL need modifications to support 2-deep and 3-deep nesting tests. Modify EntityQueryIntegrationTestBase.kt to add these relationship definitions and seed corresponding relationship data.
  </action>
  <verify>
Run: `./gradlew test --tests "riven.core.service.entity.query.EntityQueryRelationshipIntegrationTest"`. All tests pass.
  </verify>
  <done>All 5 relationship conditions tested and passing. 2-deep and 3-deep nesting works. Depth exceeded rejection verified. Mixed attribute+relationship filter composes correctly.</done>
</task>

<task type="auto">
  <name>Task 2: Create pagination, ordering, workspace isolation, and error path integration tests</name>
  <files>src/test/kotlin/riven/core/service/entity/query/EntityQueryPaginationIntegrationTest.kt, src/test/kotlin/riven/core/service/entity/query/EntityQueryErrorPathIntegrationTest.kt</files>
  <action>
**A) EntityQueryPaginationIntegrationTest** extending `EntityQueryIntegrationTestBase`:

1. `test default pagination returns first page` -- Query companies with no filter, default pagination (limit=100, offset=0). Expect: all 10 companies, totalCount=10, hasNextPage=false.

2. `test limit caps result count` -- Query companies with limit=3, offset=0. Expect: result.entities.size == 3, totalCount == 10, hasNextPage == true.

3. `test offset skips results` -- Query companies with limit=3, offset=3. Expect: 3 different companies than the first page, totalCount == 10.

4. `test offset beyond total returns empty` -- Query companies with limit=10, offset=20. Expect: empty entities, totalCount == 10, hasNextPage == false.

5. `test hasNextPage is true when more results exist` -- Query companies with limit=5, offset=0. Expect: hasNextPage == true (10 total > 5 offset+limit... wait, offset(0)+limit(5) = 5 < 10, so hasNextPage=true). Assert hasNextPage == true.

6. `test hasNextPage is false on last page` -- Query companies with limit=5, offset=5. Expect: hasNextPage == false (5+5 = 10, not < 10).

7. `test pagination with filter reduces total count` -- Query companies where industry = "Technology" with limit=2, offset=0. Expect: entities.size == 2, totalCount == 3 (3 tech companies), hasNextPage == true.

8. `test default ordering is created_at DESC, id ASC` -- Query companies with no filter and verify the returned order is newest-first (by created_at). Since seed data is inserted in order, the last inserted entity should appear first. Verify ordering is stable across multiple calls.

**B) Workspace Isolation Test** (in same or separate test class):

9. `test workspace isolation prevents cross-tenant access` -- In `@BeforeAll` of this class (or a dedicated method), create a few entities in `otherWorkspaceId`:
   - Create an entity type in `otherWorkspaceId` with same key but different ID
   - Create 3 entities in `otherWorkspaceId`

   Then query companies in `workspaceId`. Expect: only the 10 companies from the primary workspace, totalCount == 10. None of the other workspace entities appear.

   Then query in `otherWorkspaceId`. Expect: only the 3 entities from that workspace.

**C) EntityQueryErrorPathIntegrationTest** extending `EntityQueryIntegrationTestBase`:

1. `test invalid attribute reference throws QueryValidationException` -- Create a filter with a random UUID as attributeId that doesn't exist in the Company schema. Call execute(). Assert `assertThrows<QueryValidationException>`. Verify the exception's `validationErrors` contains an `InvalidAttributeReferenceException` with the bad UUID.

2. `test invalid relationship reference throws QueryValidationException` -- Create a Relationship filter with a random UUID as relationshipId. Call execute(). Assert throws `QueryValidationException` with `InvalidRelationshipReferenceException`.

3. `test depth exceeded throws QueryValidationException` -- Create a query with maxDepth=1 and a 2-deep nested relationship filter. Assert throws `QueryValidationException` with `RelationshipDepthExceededException`.

4. `test entity type not found throws NotFoundException` -- Create an EntityQuery with a random UUID as entityTypeId. Call execute(). Assert throws `NotFoundException`.

5. `test bad pagination limit throws SchemaValidationException` -- Create pagination with limit=0. Call execute(). Assert throws `SchemaValidationException`.

6. `test bad pagination offset throws SchemaValidationException` -- Create pagination with offset=-1. Call execute(). Assert throws `SchemaValidationException`.

**NOTE:** For workspace isolation, you'll need to create a separate entity type in the other workspace because entity types are workspace-scoped. The entity type can have a minimal schema (just a name attribute). Create entities via repository.save() just like the base class does.

**NOTE:** Since execute() is a suspend function, wrap all calls in `runBlocking { ... }`. For assertThrows with suspend functions, use:
```kotlin
val exception = assertThrows<QueryValidationException> {
    runBlocking {
        entityQueryService.execute(...)
    }
}
```
  </action>
  <verify>
Run all integration tests:
```
./gradlew test --tests "riven.core.service.entity.query.EntityQueryPaginationIntegrationTest"
./gradlew test --tests "riven.core.service.entity.query.EntityQueryErrorPathIntegrationTest"
```
All tests pass. Then run the full suite to verify no regressions:
```
./gradlew test --tests "riven.core.service.entity.query.*IntegrationTest"
```
  </verify>
  <done>Pagination tests verify limit, offset, totalCount, hasNextPage, and default ordering. Workspace isolation test proves no cross-tenant leakage. Error path tests verify all 6 error scenarios throw correct exception types. All integration tests pass against Testcontainers PostgreSQL.</done>
</task>

</tasks>

<verification>
1. `./gradlew test --tests "riven.core.service.entity.query.*IntegrationTest"` -- all tests pass
2. Relationship tests cover: EXISTS, NOT_EXISTS, TargetEquals, TargetMatches, TargetTypeMatches
3. Depth nesting tested at 1-deep, 2-deep, 3-deep, and depth-exceeded rejection
4. Pagination tests verify limit, offset, totalCount, hasNextPage
5. Workspace isolation test creates cross-workspace data and verifies isolation
6. Error path tests verify 6 error scenarios with correct exception types
7. All tests use real PostgreSQL via Testcontainers (verify in test output logs)
</verification>

<success_criteria>
- All 5 relationship conditions produce correct results against real PostgreSQL
- TargetTypeMatches correctly applies OR semantics across polymorphic type branches
- 2-deep and 3-deep relationship nesting produces correct results
- Depth > maxDepth rejection works as expected
- Pagination returns correct page slices with accurate totalCount and hasNextPage
- Workspace isolation prevents cross-tenant data leakage (zero entities from other workspace)
- Invalid attribute/relationship references throw descriptive QueryValidationException
- Bad pagination parameters throw SchemaValidationException
- Missing entity type throws NotFoundException
</success_criteria>

<output>
After completion, create `.planning/phases/06-end-to-end-testing/06-02-SUMMARY.md`
</output>
