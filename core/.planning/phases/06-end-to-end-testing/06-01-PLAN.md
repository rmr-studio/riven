---
phase: 06-end-to-end-testing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - build.gradle.kts
  - src/test/resources/application-integration.yml
  - src/test/kotlin/riven/core/service/entity/query/EntityQueryIntegrationTestBase.kt
  - src/test/kotlin/riven/core/service/entity/query/EntityQueryAttributeFilterIntegrationTest.kt
autonomous: true

must_haves:
  truths:
    - "All 14 FilterOperators produce correct results against real PostgreSQL JSONB"
    - "AND/OR logical composition correctly combines filter conditions"
    - "Nested AND(OR(a,b),c) produces correct parenthesized SQL that returns expected entities"
    - "IS_NULL/IS_NOT_NULL correctly handles missing JSONB keys"
    - "EQUALS uses GIN-optimized containment and returns exact matches"
    - "Numeric comparisons (GT, GTE, LT, LTE) silently fail on non-numeric values"
  artifacts:
    - path: "build.gradle.kts"
      provides: "Testcontainers dependencies"
      contains: "org.testcontainers"
    - path: "src/test/resources/application-integration.yml"
      provides: "Integration test Spring Boot config"
      contains: "riven.query.timeout-seconds"
    - path: "src/test/kotlin/riven/core/service/entity/query/EntityQueryIntegrationTestBase.kt"
      provides: "Shared Testcontainers base class with singleton PostgreSQL, test domain, seed data"
      min_lines: 100
    - path: "src/test/kotlin/riven/core/service/entity/query/EntityQueryAttributeFilterIntegrationTest.kt"
      provides: "Integration tests for all 14 FilterOperators and AND/OR composition"
      min_lines: 200
  key_links:
    - from: "EntityQueryIntegrationTestBase.kt"
      to: "EntityQueryService"
      via: "Spring @Autowired injection"
      pattern: "EntityQueryService"
    - from: "EntityQueryIntegrationTestBase.kt"
      to: "PostgreSQLContainer"
      via: "Testcontainers singleton"
      pattern: "PostgreSQLContainer"
    - from: "EntityQueryAttributeFilterIntegrationTest.kt"
      to: "EntityQueryService.execute"
      via: "Direct service call with runBlocking"
      pattern: "runBlocking.*execute"
---

<objective>
Set up Testcontainers PostgreSQL integration test infrastructure and validate all 14 attribute FilterOperators plus AND/OR logical composition against real PostgreSQL.

Purpose: Establish the shared test foundation (Testcontainers, Spring context, test domain, seed data) and prove that attribute filtering -- the most numerous test surface -- works end-to-end against real JSONB operators.

Output: Testcontainers base class, integration test profile, and passing attribute filter + logical composition tests.
</objective>

<execution_context>
@/home/jared/.claude/get-shit-done/workflows/execute-plan.md
@/home/jared/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-end-to-end-testing/06-CONTEXT.md
@.planning/phases/06-end-to-end-testing/06-RESEARCH.md
@src/main/kotlin/riven/core/service/entity/query/EntityQueryService.kt
@src/main/kotlin/riven/core/service/entity/query/EntityQueryAssembler.kt
@src/main/kotlin/riven/core/service/entity/query/AttributeSqlGenerator.kt
@src/main/kotlin/riven/core/service/entity/query/AttributeFilterVisitor.kt
@src/main/kotlin/riven/core/service/entity/query/RelationshipSqlGenerator.kt
@src/main/kotlin/riven/core/service/entity/query/ParameterNameGenerator.kt
@src/main/kotlin/riven/core/service/entity/query/QueryFilterValidator.kt
@src/main/kotlin/riven/core/service/entity/query/SqlFragment.kt
@src/main/kotlin/riven/core/service/entity/query/AssembledQuery.kt
@src/main/kotlin/riven/core/models/entity/query/EntityQuery.kt
@src/main/kotlin/riven/core/models/entity/query/QueryFilter.kt
@src/main/kotlin/riven/core/models/entity/query/RelationshipCondition.kt
@src/main/kotlin/riven/core/models/entity/query/QueryPagination.kt
@src/main/kotlin/riven/core/models/entity/query/EntityQueryResult.kt
@src/main/kotlin/riven/core/entity/entity/EntityEntity.kt
@src/main/kotlin/riven/core/entity/entity/EntityTypeEntity.kt
@src/main/kotlin/riven/core/entity/entity/EntityRelationshipEntity.kt
@src/main/kotlin/riven/core/repository/entity/EntityRepository.kt
@src/main/kotlin/riven/core/repository/entity/EntityTypeRepository.kt
@src/main/kotlin/riven/core/exceptions/query/QueryFilterException.kt
@src/main/kotlin/riven/core/entity/util/AuditableEntity.kt
@src/test/kotlin/riven/core/service/util/factory/entity/EntityFactory.kt
@src/test/resources/application-test.yml
@src/main/resources/application.yml
@build.gradle.kts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Testcontainers dependencies and integration test profile</name>
  <files>build.gradle.kts, src/test/resources/application-integration.yml</files>
  <action>
1. Add Testcontainers dependencies to build.gradle.kts under the existing test dependencies section:
   ```kotlin
   testImplementation("org.testcontainers:testcontainers:1.19.3")
   testImplementation("org.testcontainers:postgresql:1.19.3")
   testImplementation("org.testcontainers:junit-jupiter:1.19.3")
   testImplementation("org.jetbrains.kotlinx:kotlinx-coroutines-test")
   ```
   Add the PostgreSQL driver as a testRuntimeOnly dependency as well (it's currently only runtimeOnly):
   ```kotlin
   testRuntimeOnly("org.postgresql:postgresql")
   ```

2. Create `src/test/resources/application-integration.yml` for the integration test Spring profile. This profile will be activated by tests using `@ActiveProfiles("integration")` and will use the Testcontainers-provided JDBC URL dynamically. Key config:
   ```yaml
   spring:
     datasource:
       # Overridden dynamically by @DynamicPropertySource in base class
       driver-class-name: org.postgresql.Driver
     jpa:
       hibernate:
         ddl-auto: create-drop
       properties:
         hibernate:
           dialect: org.hibernate.dialect.PostgreSQLDialect
           format_sql: true
       show-sql: false
     security:
       oauth2:
         resourceserver:
           jwt:
             issuer-uri: http://localhost:9999
   riven:
     query:
       timeout-seconds: 10
     workflow:
       engine:
         target: localhost:7233
         namespace: default
         enabled: false
   logging:
     level:
       riven.core: INFO
       org.springframework: WARN
       org.hibernate: WARN
       org.testcontainers: INFO
   ```
   Note: `ddl-auto: create-drop` lets Hibernate auto-create the schema from JPA entities. The datasource URL/username/password are injected dynamically by `@DynamicPropertySource` in the base class. Temporal workflow engine is disabled (`enabled: false`) to avoid Temporal connection attempts during integration tests.
  </action>
  <verify>
Run `./gradlew dependencies --configuration testRuntimeClasspath | grep testcontainers` to verify Testcontainers dependencies resolve. Verify `application-integration.yml` exists and has correct structure.
  </verify>
  <done>Testcontainers dependencies in build.gradle.kts, integration test profile in application-integration.yml with PostgreSQL dialect, JPA auto-DDL, query timeout, and disabled Temporal.</done>
</task>

<task type="auto">
  <name>Task 2: Create integration test base class with Testcontainers, test domain, and seed data</name>
  <files>src/test/kotlin/riven/core/service/entity/query/EntityQueryIntegrationTestBase.kt</files>
  <action>
Create an abstract base class `EntityQueryIntegrationTestBase` in `src/test/kotlin/riven/core/service/entity/query/` that all entity query integration test classes will extend. This class sets up:

**A) Testcontainers Singleton PostgreSQL Container**

Use Kotlin companion object with `@JvmStatic` for shared singleton pattern:
```kotlin
companion object {
    @JvmStatic
    val postgres = PostgreSQLContainer("postgres:16-alpine")
        .withDatabaseName("riven_test")
        .withUsername("test")
        .withPassword("test")

    init {
        postgres.start()
    }
}
```

Use `@DynamicPropertySource` to inject the container's JDBC URL into Spring context:
```kotlin
companion object {
    // ...container setup above...

    @JvmStatic
    @DynamicPropertySource
    fun configureProperties(registry: DynamicPropertyRegistry) {
        registry.add("spring.datasource.url") { postgres.jdbcUrl }
        registry.add("spring.datasource.username") { postgres.username }
        registry.add("spring.datasource.password") { postgres.password }
    }
}
```

Annotations on the base class:
```kotlin
@SpringBootTest
@ActiveProfiles("integration")
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
```

**B) Autowired Dependencies**

Inject via `@Autowired`:
- `EntityQueryService` (the service under test)
- `EntityTypeRepository` (for creating entity types)
- `EntityRepository` (for creating entities)
- `EntityRelationshipRepository` (for creating relationships)
- `JdbcTemplate` (for truncate operations)

**C) Test Domain Model**

Create a realistic test domain with 3 entity types and 2 relationships in `@BeforeAll`:

1. **Company** entity type:
   - Attributes: `name` (STRING), `industry` (STRING), `revenue` (NUMBER), `active` (BOOLEAN - stored as string "true"/"false"), `founded` (STRING - year), `website` (STRING, nullable)
   - Use fixed UUIDs stored as `protected val` fields so tests can reference them by name

2. **Employee** entity type:
   - Attributes: `firstName` (STRING), `lastName` (STRING), `email` (STRING), `salary` (NUMBER), `department` (STRING)
   - Use fixed UUIDs stored as `protected val` fields

3. **Project** entity type (for polymorphic testing):
   - Attributes: `title` (STRING), `budget` (NUMBER), `status` (STRING)
   - Use fixed UUIDs stored as `protected val` fields

Relationships (stored as EntityRelationshipDefinition on Company entity type):
- `companyEmployeesRelId`: Company -> Employee (ONE_TO_MANY), defined on Company entity type
- `companyProjectsRelId`: Company -> Project (ONE_TO_MANY), defined on Company entity type
- `companyOwnerRelId`: Company -> [Employee, Project] polymorphic (for TargetTypeMatches testing)

Create entity types via `entityTypeRepository.save()` with proper schemas. Each attribute gets a fixed UUID key (e.g., `companyNameAttrId = UUID.fromString("...")`) so tests can reference them.

**D) Seed Data**

Create ~30 entities per type in `@BeforeAll` after entity types are saved:

Companies (create 10):
- "Acme Corp", industry="Technology", revenue=5000000, active="true", founded="2010", website="https://acme.com"
- "Beta Inc", industry="Technology", revenue=2000000, active="true", founded="2015", website=null
- "Gamma LLC", industry="Finance", revenue=10000000, active="true", founded="2005", website="https://gamma.io"
- "Delta Corp", industry="Finance", revenue=500000, active="false", founded="2020", website=null
- "Epsilon Ltd", industry="Healthcare", revenue=3000000, active="true", founded="2018", website="https://epsilon.health"
- "Zeta Systems", industry="Technology", revenue=8000000, active="true", founded="2012", website="https://zeta.dev"
- "Eta Solutions", industry="Consulting", revenue=1000000, active="false", founded="2019", website=null
- "Theta Group", industry="Finance", revenue=15000000, active="true", founded="2000", website="https://theta.com"
- "Iota Partners", industry="Consulting", revenue=750000, active="true", founded="2021", website=null
- "Kappa Industries", industry="Healthcare", revenue=6000000, active="true", founded="2008", website="https://kappa.med"

Store entity IDs in a `protected val companyEntities: Map<String, UUID>` keyed by name so tests can reference them.

Employees (create 20): Spread across companies. Use realistic names, emails, salaries (50000-150000), departments (Engineering, Sales, Marketing, Finance, HR). Store IDs similarly.

Projects (create 10): Spread across companies. Use realistic titles, budgets (100000-5000000), statuses (Active, Completed, Planning). Store IDs similarly.

**E) Relationship Data**

Create EntityRelationshipEntity rows linking:
- Each company to its employees (via `companyEmployeesRelId`)
- Each company to its projects (via `companyProjectsRelId`)
- A few polymorphic relationships for `companyOwnerRelId` (Company -> Employee and Company -> Project targets)

Use `entityRelationshipRepository.save()` for each relationship instance. The `fieldId` field corresponds to the relationship definition UUID. The `sourceTypeId` is the company entity type ID, and `targetTypeId` is the employee/project entity type ID.

**F) Table Truncation**

Add a protected `truncateAll()` method that uses JdbcTemplate to run:
```sql
TRUNCATE entity_relationships, entities, entity_types CASCADE
```
This is called at the start of `@BeforeAll` to clean state before seeding. Since we use `PER_CLASS` lifecycle and each test class extends this base, each class gets a clean re-seed.

**G) Workspace Setup**

Use a single shared `workspaceId` (fixed UUID) for the primary workspace. A secondary `otherWorkspaceId` (different fixed UUID) is also defined -- actual cross-workspace entities are seeded in Plan 02 for the workspace isolation test.

**IMPORTANT Implementation Notes:**
- The EntityTypeEntity `schema` field is `EntityTypeSchema` which is `Schema<UUID>`. Build schemas using the existing `Schema` data class from `riven.core.models.common.validation.Schema`.
- Each schema property maps UUID attribute key -> Schema with `key = SchemaType.TEXT` (or appropriate type), `type = DataType.STRING` (or NUMBER, BOOLEAN), `required = true/false`.
- The entity `payload` field is `Map<String, EntityAttributePrimitivePayload>` where keys are the attribute UUID strings and values are `EntityAttributePrimitivePayload` objects. Check the EntityAttributePrimitivePayload class to understand its structure (it has a `value` field).
- The `identifierKey` on EntityTypeEntity should point to the name/title attribute UUID.
- EntityRelationshipDefinition objects on the entity type should use `EntityTypeRelationshipType.ORIGIN` for the source side.
- The EntityEntity also needs `typeKey` (string key of the entity type) and `identifierKey` (same as entity type's identifier key).
- Use `runBlocking { entityQueryService.execute(...) }` when calling from tests since execute() is a suspend function.
  </action>
  <verify>
Verify the base class compiles: `./gradlew compileTestKotlin`. There are no tests to run yet -- the base class is abstract.
  </verify>
  <done>Abstract base class with singleton Testcontainers PostgreSQL, test domain (Company, Employee, Project), ~40 seed entities, relationship data, truncation support, and shared workspace ID. All attribute UUIDs and entity IDs stored as protected vals for test reference.</done>
</task>

<task type="auto">
  <name>Task 3: Create attribute filter and logical composition integration tests</name>
  <files>src/test/kotlin/riven/core/service/entity/query/EntityQueryAttributeFilterIntegrationTest.kt</files>
  <action>
Create `EntityQueryAttributeFilterIntegrationTest` extending `EntityQueryIntegrationTestBase`.

This test class validates ALL 14 FilterOperators and AND/OR logical composition against real PostgreSQL. Use `runBlocking` to call `entityQueryService.execute()`.

**FilterOperator Tests (one @Test per operator, querying Company entities):**

1. `EQUALS` -- Filter companies where industry EQUALS "Technology". Expect: Acme, Beta, Zeta (3 companies). Assert result.entities.size == 3, totalCount == 3L, all returned entities have industry = "Technology" in payload.

2. `NOT_EQUALS` -- Filter companies where industry NOT_EQUALS "Technology". Expect: all non-tech companies (7). Assert totalCount == 7L.

3. `CONTAINS` -- Filter companies where name CONTAINS "Corp". Expect: "Acme Corp" and "Delta Corp" (2). Case-insensitive, so also test with "corp" to verify ILIKE behavior.

4. `NOT_CONTAINS` -- Filter companies where name NOT_CONTAINS "Corp". Expect: 8 companies (all except Acme Corp and Delta Corp).

5. `STARTS_WITH` -- Filter companies where name STARTS_WITH "E". Expect: "Epsilon Ltd" and "Eta Solutions" (2).

6. `ENDS_WITH` -- Filter companies where name ENDS_WITH "Corp". Expect: "Acme Corp" and "Delta Corp" (2).

7. `IN` -- Filter companies where industry IN ["Technology", "Finance"]. Expect: Acme, Beta, Gamma, Delta, Theta, Zeta (6).

8. `NOT_IN` -- Filter companies where industry NOT_IN ["Technology", "Finance"]. Expect: Epsilon, Eta, Iota, Kappa (4).

9. `GREATER_THAN` -- Filter companies where revenue GT 5000000. Expect: Gamma (10M), Zeta (8M), Theta (15M), Kappa (6M) = 4 companies.

10. `GREATER_THAN_OR_EQUALS` -- Filter companies where revenue GTE 5000000. Expect: Acme (5M) + the 4 from GT = 5 companies.

11. `LESS_THAN` -- Filter companies where revenue LT 1000000. Expect: Delta (500K), Iota (750K) = 2 companies.

12. `LESS_THAN_OR_EQUALS` -- Filter companies where revenue LTE 1000000. Expect: Delta (500K), Eta (1M), Iota (750K) = 3 companies.

13. `IS_NULL` -- Filter companies where website IS_NULL. Expect: Beta, Delta, Eta, Iota (4 companies with null website).

14. `IS_NOT_NULL` -- Filter companies where website IS_NOT_NULL. Expect: Acme, Gamma, Epsilon, Zeta, Theta, Kappa (6 companies).

**AND/OR Composition Tests:**

15. `test AND composition` -- Filter companies where industry EQUALS "Technology" AND active EQUALS "true". Expect: Acme, Beta, Zeta (3 -- Delta is tech but inactive... wait, Delta is Finance. Let me re-check: Tech companies are Acme, Beta, Zeta -- all active). So expect 3.

16. `test OR composition` -- Filter companies where industry EQUALS "Technology" OR industry EQUALS "Finance". Expect: 6 companies.

17. `test nested AND(OR(a,b), c)` -- Filter companies where (industry = "Technology" OR industry = "Finance") AND active = "true". Expect: Acme (tech, active), Beta (tech, active), Gamma (finance, active), Theta (finance, active), Zeta (tech, active) = 5. Delta is finance but inactive.

18. `test deeply nested OR(AND(a,b), AND(c,d))` -- Filter where (industry = "Technology" AND revenue > 3000000) OR (industry = "Finance" AND revenue > 5000000). Expect: Acme (tech, 5M), Zeta (tech, 8M), Gamma (finance, 10M), Theta (finance, 15M) = 4.

**No-filter baseline test:**

19. `test query with no filter returns all entities` -- Query companies with null filter. Expect: 10 companies, totalCount == 10L.

**Assertion Pattern for each test:**
```kotlin
@Test
fun `test EQUALS filter returns matching entities`() = runBlocking {
    val query = EntityQuery(entityTypeId = companyTypeId)
    val filter = QueryFilter.Attribute(
        attributeId = companyIndustryAttrId,
        operator = FilterOperator.EQUALS,
        value = FilterValue.Literal("Technology")
    )
    val result = entityQueryService.execute(
        query = query.copy(filter = filter),
        workspaceId = workspaceId,
    )
    assertEquals(3, result.entities.size)
    assertEquals(3L, result.totalCount)
    // Verify all returned entities have the correct industry value
    result.entities.forEach { entity ->
        val industryPayload = entity.payload[companyIndustryAttrId]
        assertNotNull(industryPayload)
        // Check the primitive payload value
    }
}
```

Note: `entity.payload` is `Map<UUID, EntityAttribute>` and `EntityAttribute.payload` is polymorphic. For primitive attributes, it's `EntityAttributePrimitivePayload` which has a `value` field. Inspect the actual class to understand how to extract the value for assertions.

Use `@TestMethodOrder(MethodOrderer.OrderAnnotation::class)` and `@Order(N)` if ordering matters for readability, but tests should be independent.
  </action>
  <verify>
Run the integration tests: `./gradlew test --tests "riven.core.service.entity.query.EntityQueryAttributeFilterIntegrationTest"`. All 19+ tests must pass. This requires Docker running for Testcontainers.
  </verify>
  <done>All 14 FilterOperators tested individually with correct entity counts. AND, OR, and nested AND(OR) composition tests pass. No-filter baseline returns all entities. All tests run against real PostgreSQL via Testcontainers.</done>
</task>

</tasks>

<verification>
1. `./gradlew compileTestKotlin` succeeds (no compilation errors)
2. `./gradlew test --tests "riven.core.service.entity.query.EntityQueryAttributeFilterIntegrationTest"` -- all tests pass
3. Test output shows Testcontainers starting PostgreSQL container (not H2)
4. Each FilterOperator has at least one dedicated test with correct expected count
5. AND/OR composition with at least 3 levels of nesting tested and passing
</verification>

<success_criteria>
- Testcontainers PostgreSQL singleton runs across test classes
- All 14 FilterOperator variants produce correct results against real JSONB
- AND, OR, and nested AND(OR(a,b),c) logical composition works correctly
- IS_NULL/IS_NOT_NULL correctly handles missing JSONB keys
- No-filter query returns all entities of the type
- Test domain has 3 entity types with realistic attributes and ~40 seed entities
</success_criteria>

<output>
After completion, create `.planning/phases/06-end-to-end-testing/06-01-SUMMARY.md`
</output>
