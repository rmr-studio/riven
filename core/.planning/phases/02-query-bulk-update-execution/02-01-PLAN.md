---
phase: 02-query-bulk-update-execution
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/main/kotlin/riven/core/models/workflow/node/config/actions/WorkflowQueryEntityActionConfig.kt
autonomous: true

must_haves:
  truths:
    - "QueryEntityNode execute() fetches entities via EntityQueryService"
    - "Template values in query filters are resolved before query execution"
    - "QueryEntityNode returns QueryEntityOutput with entities list, totalCount, and hasMore"
    - "QueryEntityActionConfig declares outputMetadata matching QueryEntityOutput"
  artifacts:
    - path: "src/main/kotlin/riven/core/models/workflow/node/config/actions/WorkflowQueryEntityActionConfig.kt"
      provides: "Working execute() implementation and outputMetadata companion property"
      contains: "EntityQueryService"
  key_links:
    - from: "WorkflowQueryEntityActionConfig.execute()"
      to: "EntityQueryService.execute()"
      via: "services.service<EntityQueryService>()"
      pattern: "services\\.service<EntityQueryService>"
    - from: "WorkflowQueryEntityActionConfig.execute()"
      to: "QueryEntityOutput"
      via: "return QueryEntityOutput(...)"
      pattern: "QueryEntityOutput\\("
    - from: "WorkflowQueryEntityActionConfig.companion.outputMetadata"
      to: "QueryEntityOutput.toMap() keys"
      via: "key field matching"
      pattern: "outputMetadata.*=.*WorkflowNodeOutputMetadata"
---

<objective>
Implement QueryEntityNode execute() method and declare outputMetadata on the companion object.

Purpose: The QueryEntityActionConfig already exists with config, validation, and a TODO execute() stub. This plan implements the actual query execution by integrating with EntityQueryService, resolving template values in filter expressions, and returning a QueryEntityOutput. It also declares outputMetadata so the frontend knows what data this node produces.

Output: Working QueryEntity workflow node that fetches entities matching filter criteria during workflow execution, with outputMetadata declared for frontend consumption.
</objective>

<execution_context>
@/home/jared/.claude/get-shit-done/workflows/execute-plan.md
@/home/jared/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-infrastructure/01-01-SUMMARY.md

@src/main/kotlin/riven/core/models/workflow/node/config/actions/WorkflowQueryEntityActionConfig.kt
@src/main/kotlin/riven/core/models/workflow/node/config/actions/WorkflowCreateEntityActionConfig.kt
@src/main/kotlin/riven/core/models/workflow/engine/state/NodeOutput.kt
@src/main/kotlin/riven/core/service/entity/query/EntityQueryService.kt
@src/main/kotlin/riven/core/models/entity/query/EntityQueryResult.kt
@src/main/kotlin/riven/core/models/entity/Entity.kt
@src/main/kotlin/riven/core/service/workflow/state/WorkflowNodeInputResolverService.kt
@src/main/kotlin/riven/core/models/entity/query/filter/FilterValue.kt
@src/main/kotlin/riven/core/models/workflow/node/config/WorkflowNodeOutputField.kt
@src/main/kotlin/riven/core/models/workflow/node/config/WorkflowNodeOutputMetadata.kt
@src/main/kotlin/riven/core/enums/workflow/OutputFieldType.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement QueryEntityActionConfig execute() with template resolution and outputMetadata</name>
  <files>src/main/kotlin/riven/core/models/workflow/node/config/actions/WorkflowQueryEntityActionConfig.kt</files>
  <action>
Replace the TODO/NotImplementedError execute() method with a working implementation. Follow the established pattern from CreateEntityActionConfig.execute() and UpdateEntityActionConfig.execute().

**execute() implementation steps:**

1. Get EntityQueryService from services: `val entityQueryService = services.service<EntityQueryService>()`

2. Resolve template values in the filter tree. The `inputs` parameter already contains resolved config values (WorkflowCoordinationService calls resolveAll on config map before execute). However, the filter is an object tree with FilterValue.Template instances that need special handling. Walk the resolved filter structure and convert any FilterValue.Template expressions that were resolved to their literal values. The inputs map will have "filter" as a resolved nested map structure. Reconstruct an EntityQuery from the resolved inputs:
   - `entityTypeId` from `inputs["entityTypeId"]` (already a string, parse to UUID)
   - For the filter: the existing config already passes `query.filter` as-is into the config map. The WorkflowNodeInputResolverService.resolveAll recursively resolves template strings within nested maps/lists. Since FilterValue.Template has an `expression` field that is a string, template resolution will resolve it. However, the filter is a complex Jackson-polymorphic object, not a plain map. The simplest approach: resolve template FilterValues BEFORE building the query. Walk the existing `query.filter` tree, and for any FilterValue.Template found, resolve its expression using the dataStore (passed to execute). Use `services.service<WorkflowNodeInputResolverService>()` to resolve each template expression against the dataStore. Create a helper method `resolveFilterTemplates(filter: QueryFilter?, dataStore: WorkflowDataStore, resolver: WorkflowNodeInputResolverService): QueryFilter?` that recursively walks the filter tree and replaces FilterValue.Template with FilterValue.Literal containing the resolved value.

3. Build the query with resolved filter: Create the EntityQuery using the original query's entityTypeId and the resolved filter.

4. Apply system-wide default limit (per Claude's discretion, use 100). Set pagination to use min(configured pagination limit, 100) to prevent runaway queries. Define a companion constant `private const val DEFAULT_QUERY_LIMIT = 100`.

5. Execute the query: Call `kotlinx.coroutines.runBlocking { entityQueryService.execute(resolvedQuery, workspaceId, pagination, projection) }` since EntityQueryService.execute is a suspend function but WorkflowNodeConfig.execute is not. Get workspaceId from `dataStore.metadata.workspaceId`.

6. Transform EntityQueryResult to QueryEntityOutput:
   - Map each Entity to a Map<String, Any?> containing: "id" (entity.id), "typeId" (entity.typeId), "payload" (entity.payload as Map<UUID, Any?>), "icon" (entity.icon), "identifierKey" (entity.identifierKey), "createdAt" (entity.createdAt), "updatedAt" (entity.updatedAt). This gives downstream nodes full entity objects per the locked decision.
   - totalCount: result.totalCount.toInt()
   - hasMore: result.hasNextPage

7. Return `QueryEntityOutput(entities = entityMaps, totalCount = totalCount, hasMore = hasMore)`

**outputMetadata declaration:**

Add to the companion object (following CreateEntityActionConfig pattern):
```kotlin
val outputMetadata = WorkflowNodeOutputMetadata(
    fields = listOf(
        WorkflowNodeOutputField(
            key = "entities",
            label = "Matching Entities",
            type = OutputFieldType.ENTITY_LIST,
            description = "List of entities matching the query filters",
            entityTypeId = null,  // Dynamic - resolved from query.entityTypeId at runtime
            exampleValue = listOf(
                mapOf(
                    "id" to "550e8400-e29b-41d4-a716-446655440000",
                    "typeId" to "660e8400-e29b-41d4-a716-446655440001",
                    "payload" to mapOf("attr-uuid" to "Example Value")
                )
            )
        ),
        WorkflowNodeOutputField(
            key = "totalCount",
            label = "Total Count",
            type = OutputFieldType.NUMBER,
            description = "Total number of matching entities (before pagination limit)",
            exampleValue = 42
        ),
        WorkflowNodeOutputField(
            key = "hasMore",
            label = "Has More",
            type = OutputFieldType.BOOLEAN,
            description = "Whether more results exist beyond the system limit",
            exampleValue = false
        )
    )
)
```

**Add required imports:**
- `import kotlinx.coroutines.runBlocking`
- `import riven.core.models.workflow.node.config.WorkflowNodeOutputField`
- `import riven.core.models.workflow.node.config.WorkflowNodeOutputMetadata`
- `import riven.core.enums.workflow.OutputFieldType`
- `import riven.core.service.entity.query.EntityQueryService`
- `import riven.core.service.workflow.state.WorkflowNodeInputResolverService`
- `import riven.core.models.entity.query.pagination.QueryPagination` (if not already imported)

**No sorting support** per locked decision -- pass pagination with no orderBy fields, or use existing pagination.orderBy only if already present.
  </action>
  <verify>
Run the full test suite: `./gradlew test` from project root. All existing tests pass (including OutputMetadataValidationTest which will now validate QueryEntityActionConfig.outputMetadata keys against QueryEntityOutput.toMap() keys). Verify the file compiles with no errors.
  </verify>
  <done>
QueryEntityActionConfig.execute() invokes EntityQueryService, resolves template FilterValues, respects system query limit of 100, transforms results to QueryEntityOutput with full entity objects. outputMetadata declared in companion with entities (ENTITY_LIST), totalCount (NUMBER), hasMore (BOOLEAN). All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `./gradlew test` passes with zero failures
2. OutputMetadataValidationTest validates QueryEntityActionConfig.outputMetadata keys match QueryEntityOutput.toMap() keys
3. No NotImplementedError remains in execute()
4. Template FilterValues are resolved before query execution
</verification>

<success_criteria>
- QueryEntityActionConfig.execute() is fully implemented (no TODO/throw)
- Templates in filter values are resolved via WorkflowNodeInputResolverService
- System-wide query limit of 100 applied
- EntityQueryResult transformed to QueryEntityOutput with full entity maps
- outputMetadata declared in companion matching QueryEntityOutput.toMap() keys
- All tests pass including parameterized output metadata validation
</success_criteria>

<output>
After completion, create `.planning/phases/02-query-bulk-update-execution/02-01-SUMMARY.md`
</output>
