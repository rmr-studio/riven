---
phase: 07-error-handling-retry-logic
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - src/main/kotlin/riven/core/service/workflow/engine/WorkflowOrchestrationService.kt
  - src/main/kotlin/riven/core/service/workflow/engine/coordinator/WorkflowCoordinationService.kt
autonomous: true
user_setup: []

must_haves:
  truths:
    - "4xx HTTP errors, validation errors, and CONDITION node failures do not retry"
    - "5xx HTTP errors, network errors, and database errors retry with exponential backoff"
    - "Failed nodes have structured error details persisted to database"
    - "ApplicationFailure is thrown with error type for Temporal retry control"
  artifacts:
    - path: "src/main/kotlin/riven/core/service/workflow/engine/WorkflowOrchestrationService.kt"
      provides: "Temporal RetryOptions with non-retryable error types"
      contains: "setDoNotRetry"
    - path: "src/main/kotlin/riven/core/service/workflow/engine/coordinator/WorkflowCoordinationService.kt"
      provides: "Error classification and ApplicationFailure throwing"
      contains: "ApplicationFailure"
  key_links:
    - from: "WorkflowCoordinationService"
      to: "ApplicationFailure"
      via: "io.temporal.failure.ApplicationFailure import"
      pattern: "ApplicationFailure\\.(newNonRetryableFailure|newFailureWithCause)"
    - from: "WorkflowOrchestrationService"
      to: "RetryOptions.setDoNotRetry"
      via: "Non-retryable error type strings"
      pattern: "setDoNotRetry.*HTTP_CLIENT_ERROR|VALIDATION_ERROR|CONTROL_FLOW_ERROR"
---

<objective>
Integrate Temporal retry policies with error classification in workflow execution services.

Purpose: Configure Temporal to automatically retry transient errors while immediately failing on non-retryable errors (4xx, validation, deterministic failures). Classify exceptions and throw appropriate ApplicationFailure for Temporal to handle.

Output:
- WorkflowOrchestrationServiceImpl with enhanced RetryOptions including doNotRetry list
- WorkflowCoordinationService with error classification logic
- Structured errors persisted to workflow_node_executions table
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-error-handling-retry-logic/07-RESEARCH.md
@.planning/phases/07-error-handling-retry-logic/07-CONTEXT.md
@.planning/phases/07-error-handling-retry-logic/07-01-SUMMARY.md
@src/main/kotlin/riven/core/service/workflow/engine/WorkflowOrchestrationService.kt
@src/main/kotlin/riven/core/service/workflow/engine/coordinator/WorkflowCoordinationService.kt
@src/main/kotlin/riven/core/enums/workflow/WorkflowNodeType.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update WorkflowOrchestrationServiceImpl with enhanced RetryOptions</name>
  <files>
    src/main/kotlin/riven/core/service/workflow/engine/WorkflowOrchestrationService.kt
  </files>
  <action>
Update the RetryOptions in WorkflowOrchestrationServiceImpl to include non-retryable error types.

The existing code has:
```kotlin
.setRetryOptions(
    RetryOptions.newBuilder()
        .setMaximumAttempts(3)
        .setInitialInterval(Duration.ofSeconds(1))
        .setBackoffCoefficient(2.0)
        .setMaximumInterval(Duration.ofMinutes(1))
        .build()
)
```

Update to add doNotRetry for non-retryable error types:
```kotlin
.setRetryOptions(
    RetryOptions.newBuilder()
        .setMaximumAttempts(3)
        .setInitialInterval(Duration.ofSeconds(1))
        .setBackoffCoefficient(2.0)
        .setMaximumInterval(Duration.ofSeconds(30))  // Changed from 1 min to 30s per CONTEXT.md
        .setDoNotRetry(
            // Non-retryable error types (matches WorkflowErrorType enum names)
            "HTTP_CLIENT_ERROR",      // 4xx HTTP errors
            "VALIDATION_ERROR",       // Schema/input validation
            "CONTROL_FLOW_ERROR",     // CONDITION node deterministic failure
            "SECURITY_ERROR"          // Auth/authz errors
        )
        .build()
)
```

Note: The doNotRetry strings must match the error "type" parameter passed to ApplicationFailure in WorkflowCoordinationService.

Keep the existing workflow implementation (execute method) unchanged - it delegates to the activity which handles all error classification.
  </action>
  <verify>
File compiles: `./gradlew compileKotlin`
  </verify>
  <done>
RetryOptions includes setDoNotRetry with HTTP_CLIENT_ERROR, VALIDATION_ERROR, CONTROL_FLOW_ERROR, SECURITY_ERROR. Maximum interval changed to 30 seconds.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add error classification and ApplicationFailure handling to WorkflowCoordinationService</name>
  <files>
    src/main/kotlin/riven/core/service/workflow/engine/coordinator/WorkflowCoordinationService.kt
  </files>
  <action>
Enhance WorkflowCoordinationService to classify errors and throw appropriate ApplicationFailure.

1. Add imports:
```kotlin
import io.temporal.failure.ApplicationFailure
import org.springframework.web.reactive.function.client.WebClientResponseException
import riven.core.enums.workflow.WorkflowErrorType
import riven.core.models.workflow.engine.error.NodeExecutionError
import riven.core.models.workflow.engine.error.RetryAttempt
```

2. Add a helper function to classify exceptions and throw ApplicationFailure:
```kotlin
/**
 * Classifies an exception and throws appropriate ApplicationFailure.
 *
 * Non-retryable (fails immediately):
 * - 4xx HTTP errors (client errors - data won't change)
 * - Validation errors (input invalid)
 * - CONDITION node errors (deterministic evaluation)
 * - Security exceptions (auth/authz)
 *
 * Retryable (Temporal will retry):
 * - 5xx HTTP errors (server issues - transient)
 * - Database connection errors (transient)
 * - Network timeouts (transient)
 */
private fun classifyAndThrowError(
    e: Exception,
    nodeId: UUID,
    nodeName: String,
    nodeType: WorkflowNodeType,
    attempt: Int
): Nothing {
    val (errorType, message) = when {
        // HTTP 4xx - client error, non-retryable
        e is WebClientResponseException && e.statusCode.is4xxClientError -> {
            WorkflowErrorType.HTTP_CLIENT_ERROR to "HTTP ${e.statusCode.value()}: ${e.message}"
        }
        // HTTP 5xx - server error, retryable
        e is WebClientResponseException && e.statusCode.is5xxServerError -> {
            WorkflowErrorType.HTTP_SERVER_ERROR to "HTTP ${e.statusCode.value()}: ${e.message}"
        }
        // Validation errors - non-retryable
        e is IllegalArgumentException || e is SchemaValidationException -> {
            WorkflowErrorType.VALIDATION_ERROR to "Validation failed: ${e.message}"
        }
        // Security errors - non-retryable
        e is SecurityException -> {
            WorkflowErrorType.SECURITY_ERROR to "Security error: ${e.message}"
        }
        // CONTROL_FLOW nodes - deterministic, non-retryable
        nodeType == WorkflowNodeType.CONTROL_FLOW -> {
            WorkflowErrorType.CONTROL_FLOW_ERROR to "Control flow failed: ${e.message}"
        }
        // Default - retryable
        else -> {
            WorkflowErrorType.EXECUTION_ERROR to "Execution error: ${e.message}"
        }
    }

    logger.error(e) { "Node $nodeName failed (attempt $attempt): $message [${errorType.name}]" }

    // Throw ApplicationFailure with error type as the "type" parameter
    // Temporal uses this to match against doNotRetry list
    if (errorType.retryable) {
        throw ApplicationFailure.newFailureWithCause(
            message,
            errorType.name,  // Must match doNotRetry strings in WorkflowOrchestrationService
            e
        )
    } else {
        throw ApplicationFailure.newNonRetryableFailure(
            message,
            errorType.name
        )
    }
}
```

3. Import SchemaValidationException:
```kotlin
import riven.core.exceptions.SchemaValidationException
```

4. Update executeNode() method's catch block to use the new classification:

Replace the existing catch block at the end of executeNode() (around line 237-271) with:
```kotlin
} catch (e: Exception) {
    // Get current attempt from Temporal activity context
    val attempt = Activity.getExecutionContext().info.attempt

    logger.error(e) { "Error executing node $nodeId (attempt $attempt): ${e.message}" }

    // Try to persist error state (best effort)
    try {
        val activityInfo = Activity.getExecutionContext().info
        val workflowExecutionId = UUID.fromString(
            activityInfo.workflowId.substringAfter("execution-")
        )

        // Build retry attempt record
        val retryAttempt = RetryAttempt(
            attemptNumber = attempt,
            timestamp = ZonedDateTime.now(),
            errorType = classifyErrorType(e, node.type),
            errorMessage = e.message ?: "Unknown error",
            durationMs = java.time.Duration.between(startTime, ZonedDateTime.now()).toMillis()
        )

        // Build structured error
        val errorDetails = NodeExecutionError(
            errorType = classifyErrorType(e, node.type),
            message = e.message ?: "Unknown error",
            httpStatusCode = (e as? WebClientResponseException)?.statusCode?.value(),
            retryAttempts = listOf(retryAttempt),
            isFinal = !classifyErrorType(e, node.type).retryable || attempt >= 3,
            stackTrace = e.stackTraceToString().take(10240)  // Truncate to 10KB
        )

        val executionNodeRecord = createExecutionNode(
            workflowExecutionId = workflowExecutionId,
            nodeId = nodeId,
            workspaceId = workspaceId,
            startTime = startTime
        )

        updateExecutionNodeWithError(
            executionNode = executionNodeRecord,
            error = errorDetails,
            completedTime = ZonedDateTime.now(),
            startTime = startTime
        )
    } catch (persistError: Exception) {
        logger.error(persistError) { "Failed to persist error state for node $nodeId" }
    }

    // Classify and throw ApplicationFailure for Temporal retry handling
    classifyAndThrowError(e, nodeId, node.name, node.type, attempt)
}
```

5. Add a helper function to classify error type without throwing:
```kotlin
private fun classifyErrorType(e: Exception, nodeType: WorkflowNodeType): WorkflowErrorType {
    return when {
        e is WebClientResponseException && e.statusCode.is4xxClientError -> WorkflowErrorType.HTTP_CLIENT_ERROR
        e is WebClientResponseException && e.statusCode.is5xxServerError -> WorkflowErrorType.HTTP_SERVER_ERROR
        e is IllegalArgumentException || e is SchemaValidationException -> WorkflowErrorType.VALIDATION_ERROR
        e is SecurityException -> WorkflowErrorType.SECURITY_ERROR
        nodeType == WorkflowNodeType.CONTROL_FLOW -> WorkflowErrorType.CONTROL_FLOW_ERROR
        else -> WorkflowErrorType.EXECUTION_ERROR
    }
}
```

6. Add a new method to update execution node with structured error:
```kotlin
private fun updateExecutionNodeWithError(
    executionNode: WorkflowExecutionNodeEntity,
    error: NodeExecutionError,
    completedTime: ZonedDateTime,
    startTime: ZonedDateTime
) {
    val durationMs = java.time.Duration.between(startTime, completedTime).toMillis()

    val updated = executionNode.copy(
        status = WorkflowStatus.FAILED,
        completedAt = completedTime,
        durationMs = durationMs,
        output = null,
        error = error  // Now stores structured NodeExecutionError
    )

    workflowExecutionNodeRepository.save(updated)
}
```

7. Update the existing updateExecutionNode to handle both success and simple error cases, but prefer updateExecutionNodeWithError for failures.
  </action>
  <verify>
File compiles: `./gradlew compileKotlin`
  </verify>
  <done>
WorkflowCoordinationService classifies exceptions by type and throws ApplicationFailure with matching error type names. Structured NodeExecutionError persisted to database. Non-retryable errors use newNonRetryableFailure(), retryable use newFailureWithCause().
  </done>
</task>

</tasks>

<verification>
All files compile without errors:
```bash
./gradlew compileKotlin
```

Check that imports are correct and ApplicationFailure is from io.temporal.failure package.
</verification>

<success_criteria>
- [ ] WorkflowOrchestrationServiceImpl has setDoNotRetry with 4 non-retryable error types
- [ ] Maximum retry interval reduced to 30 seconds (per CONTEXT.md)
- [ ] WorkflowCoordinationService imports ApplicationFailure from io.temporal.failure
- [ ] classifyAndThrowError() method classifies exceptions by type
- [ ] Non-retryable errors throw ApplicationFailure.newNonRetryableFailure()
- [ ] Retryable errors throw ApplicationFailure.newFailureWithCause()
- [ ] Structured NodeExecutionError persisted on failure
- [ ] Error type names match between doNotRetry list and ApplicationFailure type parameter
- [ ] All code compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/07-error-handling-retry-logic/07-02-SUMMARY.md`
</output>
