---
phase: 07-error-handling-retry-logic
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - src/main/kotlin/riven/core/service/workflow/engine/WorkflowOrchestrationService.kt
  - src/main/kotlin/riven/core/service/workflow/engine/coordinator/WorkflowCoordinationService.kt
  - src/main/kotlin/riven/core/service/workflow/engine/error/WorkflowErrorClassifier.kt
autonomous: true
user_setup: []

must_haves:
  truths:
    - "4xx HTTP errors, validation errors, and CONDITION node failures do not retry"
    - "5xx HTTP errors, network errors, and database errors retry with exponential backoff"
    - "Failed nodes have structured error details persisted to database"
    - "ApplicationFailure is thrown with error type for Temporal retry control"
    - "Retry configuration is externalized and configurable"
  artifacts:
    - path: "src/main/kotlin/riven/core/service/workflow/engine/error/WorkflowErrorClassifier.kt"
      provides: "Error classification utility for testability"
      exports: ["WorkflowErrorClassifier", "classifyError"]
    - path: "src/main/kotlin/riven/core/service/workflow/engine/WorkflowOrchestrationService.kt"
      provides: "Temporal RetryOptions with non-retryable error types"
      contains: "setDoNotRetry"
    - path: "src/main/kotlin/riven/core/service/workflow/engine/coordinator/WorkflowCoordinationService.kt"
      provides: "Error classification and ApplicationFailure throwing"
      contains: "ApplicationFailure"
  key_links:
    - from: "WorkflowCoordinationService"
      to: "WorkflowErrorClassifier"
      via: "classifyError function call"
      pattern: "WorkflowErrorClassifier\\.classifyError"
    - from: "WorkflowCoordinationService"
      to: "ApplicationFailure"
      via: "io.temporal.failure.ApplicationFailure import"
      pattern: "ApplicationFailure\\.(newNonRetryableFailure|newFailureWithCause)"
    - from: "WorkflowOrchestrationService"
      to: "RetryOptions.setDoNotRetry"
      via: "Non-retryable error type strings"
      pattern: "setDoNotRetry.*HTTP_CLIENT_ERROR|VALIDATION_ERROR|CONTROL_FLOW_ERROR"
---

<objective>
Integrate Temporal retry policies with error classification in workflow execution services.

Purpose: Configure Temporal to automatically retry transient errors while immediately failing on non-retryable errors (4xx, validation, deterministic failures). Extract error classification to a testable utility class. Classify exceptions and throw appropriate ApplicationFailure for Temporal to handle.

Output:
- WorkflowErrorClassifier utility class with classifyError() function (testable)
- WorkflowOrchestrationServiceImpl with enhanced RetryOptions including doNotRetry list
- WorkflowCoordinationService using error classifier and throwing appropriate ApplicationFailure
- Structured errors persisted to workflow_node_executions table
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-error-handling-retry-logic/07-RESEARCH.md
@.planning/phases/07-error-handling-retry-logic/07-CONTEXT.md
@.planning/phases/07-error-handling-retry-logic/07-01-SUMMARY.md
@src/main/kotlin/riven/core/service/workflow/engine/WorkflowOrchestrationService.kt
@src/main/kotlin/riven/core/service/workflow/engine/coordinator/WorkflowCoordinationService.kt
@src/main/kotlin/riven/core/enums/workflow/WorkflowNodeType.kt
@src/main/kotlin/riven/core/configuration/workflow/WorkflowRetryConfigurationProperties.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create WorkflowErrorClassifier utility class</name>
  <files>
    src/main/kotlin/riven/core/service/workflow/engine/error/WorkflowErrorClassifier.kt
  </files>
  <action>
Create a new utility class WorkflowErrorClassifier in service/workflow/engine/error/ that extracts error classification logic into a testable component.

```kotlin
package riven.core.service.workflow.engine.error

import org.springframework.web.reactive.function.client.WebClientResponseException
import riven.core.enums.workflow.WorkflowErrorType
import riven.core.enums.workflow.WorkflowNodeType
import riven.core.exceptions.SchemaValidationException

/**
 * Utility object for classifying workflow execution errors.
 *
 * Error classification determines retry behavior:
 * - Non-retryable errors fail immediately (4xx, validation, security, control flow)
 * - Retryable errors trigger Temporal retry with exponential backoff (5xx, network, db)
 *
 * This is an object (singleton) to allow direct function calls without Spring injection,
 * making it easy to test and use from both Spring beans and non-Spring contexts.
 */
object WorkflowErrorClassifier {

    /**
     * Classifies an exception into a WorkflowErrorType.
     *
     * Classification rules:
     * - HTTP 4xx -> HTTP_CLIENT_ERROR (non-retryable: client error, data won't change)
     * - HTTP 5xx -> HTTP_SERVER_ERROR (retryable: server issue, transient)
     * - IllegalArgumentException, SchemaValidationException -> VALIDATION_ERROR (non-retryable)
     * - SecurityException -> SECURITY_ERROR (non-retryable)
     * - CONTROL_FLOW node + any error -> CONTROL_FLOW_ERROR (non-retryable: deterministic)
     * - All other exceptions -> EXECUTION_ERROR (retryable: assume transient)
     *
     * @param e The exception to classify
     * @param nodeType The type of node that threw the exception (affects classification for CONTROL_FLOW)
     * @return The classified error type
     */
    fun classifyError(e: Exception, nodeType: WorkflowNodeType): WorkflowErrorType {
        return when {
            // HTTP 4xx - client error, non-retryable
            e is WebClientResponseException && e.statusCode.is4xxClientError ->
                WorkflowErrorType.HTTP_CLIENT_ERROR

            // HTTP 5xx - server error, retryable
            e is WebClientResponseException && e.statusCode.is5xxServerError ->
                WorkflowErrorType.HTTP_SERVER_ERROR

            // Validation errors - non-retryable
            e is IllegalArgumentException || e is SchemaValidationException ->
                WorkflowErrorType.VALIDATION_ERROR

            // Security errors - non-retryable
            e is SecurityException ->
                WorkflowErrorType.SECURITY_ERROR

            // CONTROL_FLOW nodes - deterministic evaluation, non-retryable
            nodeType == WorkflowNodeType.CONTROL_FLOW ->
                WorkflowErrorType.CONTROL_FLOW_ERROR

            // Default - assume transient, retryable
            else ->
                WorkflowErrorType.EXECUTION_ERROR
        }
    }

    /**
     * Classifies an exception and returns both the error type and a formatted message.
     *
     * @param e The exception to classify
     * @param nodeType The type of node that threw the exception
     * @return Pair of (WorkflowErrorType, formatted message)
     */
    fun classifyErrorWithMessage(e: Exception, nodeType: WorkflowNodeType): Pair<WorkflowErrorType, String> {
        val errorType = classifyError(e, nodeType)
        val message = when (errorType) {
            WorkflowErrorType.HTTP_CLIENT_ERROR -> {
                val status = (e as WebClientResponseException).statusCode.value()
                "HTTP $status: ${e.message}"
            }
            WorkflowErrorType.HTTP_SERVER_ERROR -> {
                val status = (e as WebClientResponseException).statusCode.value()
                "HTTP $status: ${e.message}"
            }
            WorkflowErrorType.VALIDATION_ERROR -> "Validation failed: ${e.message}"
            WorkflowErrorType.SECURITY_ERROR -> "Security error: ${e.message}"
            WorkflowErrorType.CONTROL_FLOW_ERROR -> "Control flow failed: ${e.message}"
            else -> "Execution error: ${e.message}"
        }
        return errorType to message
    }
}
```

This utility:
- Is an `object` (Kotlin singleton) so it can be called directly without injection
- Exposes `classifyError()` for simple classification
- Exposes `classifyErrorWithMessage()` for classification with formatted message
- Is easily unit-testable since it's a pure function with no dependencies
  </action>
  <verify>
File compiles: `./gradlew compileKotlin`
  </verify>
  <done>
WorkflowErrorClassifier object exists with classifyError() and classifyErrorWithMessage() functions. Logic handles HTTP 4xx/5xx, validation, security, and control flow errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update WorkflowOrchestrationServiceImpl with enhanced RetryOptions</name>
  <files>
    src/main/kotlin/riven/core/service/workflow/engine/WorkflowOrchestrationService.kt
  </files>
  <action>
Update the RetryOptions in WorkflowOrchestrationServiceImpl to include non-retryable error types.

The existing code has:
```kotlin
.setRetryOptions(
    RetryOptions.newBuilder()
        .setMaximumAttempts(3)
        .setInitialInterval(Duration.ofSeconds(1))
        .setBackoffCoefficient(2.0)
        .setMaximumInterval(Duration.ofMinutes(1))
        .build()
)
```

Update to add doNotRetry for non-retryable error types:
```kotlin
.setRetryOptions(
    RetryOptions.newBuilder()
        .setMaximumAttempts(3)
        .setInitialInterval(Duration.ofSeconds(1))
        .setBackoffCoefficient(2.0)
        .setMaximumInterval(Duration.ofSeconds(30))  // Changed from 1 min to 30s per CONTEXT.md
        .setDoNotRetry(
            // Non-retryable error types (matches WorkflowErrorType enum names)
            "HTTP_CLIENT_ERROR",      // 4xx HTTP errors
            "VALIDATION_ERROR",       // Schema/input validation
            "CONTROL_FLOW_ERROR",     // CONDITION node deterministic failure
            "SECURITY_ERROR"          // Auth/authz errors
        )
        .build()
)
```

Note: The doNotRetry strings must match the error "type" parameter passed to ApplicationFailure in WorkflowCoordinationService. These match the WorkflowErrorType enum names exactly.

**Configuration wiring note:** WorkflowOrchestrationServiceImpl is NOT a Spring bean (it's a Temporal workflow registered via worker auto-discovery), so it cannot inject WorkflowRetryConfigurationProperties directly. The current hardcoded values match the configuration defaults. To make this configurable:

Option A (simple - current approach): Keep values hardcoded in workflow, they match config defaults
Option B (advanced - future): Pass retry config via workflow input from the starter service
Option C (advanced - future): Use a Temporal local activity to fetch config at workflow start

For now, keep hardcoded values matching the application.yml defaults. Document this limitation in the code comments.

Add a comment explaining this:
```kotlin
// Note: Retry values are hardcoded here because WorkflowOrchestrationServiceImpl is not a Spring bean.
// Values match application.yml riven.workflow.retry.default.* for consistency.
// To make configurable: pass via workflow input or use local activity to fetch config.
```
  </action>
  <verify>
File compiles: `./gradlew compileKotlin`
  </verify>
  <done>
RetryOptions includes setDoNotRetry with HTTP_CLIENT_ERROR, VALIDATION_ERROR, CONTROL_FLOW_ERROR, SECURITY_ERROR. Maximum interval changed to 30 seconds. Comment documents why values are hardcoded.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add error classification and ApplicationFailure handling to WorkflowCoordinationService</name>
  <files>
    src/main/kotlin/riven/core/service/workflow/engine/coordinator/WorkflowCoordinationService.kt
  </files>
  <action>
Enhance WorkflowCoordinationService to use WorkflowErrorClassifier and throw appropriate ApplicationFailure.

1. Add imports:
```kotlin
import io.temporal.failure.ApplicationFailure
import org.springframework.web.reactive.function.client.WebClientResponseException
import riven.core.enums.workflow.WorkflowErrorType
import riven.core.models.workflow.engine.error.NodeExecutionError
import riven.core.models.workflow.engine.error.RetryAttempt
import riven.core.service.workflow.engine.error.WorkflowErrorClassifier
```

2. Add a helper function to classify and throw ApplicationFailure:
```kotlin
/**
 * Classifies an exception and throws appropriate ApplicationFailure.
 *
 * Uses WorkflowErrorClassifier for classification logic.
 * Temporal uses the ApplicationFailure "type" parameter to match against doNotRetry list.
 *
 * @param e The exception that occurred
 * @param nodeId UUID of the failing node
 * @param nodeName Human-readable node name
 * @param nodeType Type of node (affects classification for CONTROL_FLOW)
 * @param attempt Current retry attempt number
 * @throws ApplicationFailure always (return type is Nothing)
 */
private fun classifyAndThrowError(
    e: Exception,
    nodeId: UUID,
    nodeName: String,
    nodeType: WorkflowNodeType,
    attempt: Int
): Nothing {
    val (errorType, message) = WorkflowErrorClassifier.classifyErrorWithMessage(e, nodeType)

    logger.error(e) { "Node $nodeName failed (attempt $attempt): $message [${errorType.name}]" }

    // Throw ApplicationFailure with error type as the "type" parameter
    // Temporal uses this to match against doNotRetry list in WorkflowOrchestrationService
    if (errorType.retryable) {
        throw ApplicationFailure.newFailureWithCause(
            message,
            errorType.name,  // Must match doNotRetry strings
            e
        )
    } else {
        throw ApplicationFailure.newNonRetryableFailure(
            message,
            errorType.name
        )
    }
}
```

3. Update executeNode() method's catch block (around line 237-271) to use error classification:

Note: The `startTime` variable is defined at line 146 (`val startTime = ZonedDateTime.now()`) at the beginning of executeNode() and remains in scope throughout the entire method including the catch block.

Replace the existing catch block with:
```kotlin
} catch (e: Exception) {
    // Get current attempt from Temporal activity context
    val attempt = Activity.getExecutionContext().info.attempt

    logger.error(e) { "Error executing node $nodeId (attempt $attempt): ${e.message}" }

    // Try to persist error state (best effort)
    try {
        val activityInfo = Activity.getExecutionContext().info
        val workflowExecutionId = UUID.fromString(
            activityInfo.workflowId.substringAfter("execution-")
        )

        // Classify error using utility
        val errorType = WorkflowErrorClassifier.classifyError(e, node.type)

        // Build retry attempt record
        // Note: startTime is defined at line 146 (method start) and is in scope here
        val retryAttempt = RetryAttempt(
            attemptNumber = attempt,
            timestamp = ZonedDateTime.now(),
            errorType = errorType,
            errorMessage = e.message ?: "Unknown error",
            durationMs = java.time.Duration.between(startTime, ZonedDateTime.now()).toMillis()
        )

        // Build structured error
        val errorDetails = NodeExecutionError(
            errorType = errorType,
            message = e.message ?: "Unknown error",
            httpStatusCode = (e as? WebClientResponseException)?.statusCode?.value(),
            retryAttempts = listOf(retryAttempt),
            isFinal = !errorType.retryable || attempt >= 3,
            stackTrace = e.stackTraceToString().take(10240)  // Truncate to 10KB
        )

        val executionNodeRecord = createExecutionNode(
            workflowExecutionId = workflowExecutionId,
            nodeId = nodeId,
            workspaceId = workspaceId,
            startTime = startTime
        )

        updateExecutionNodeWithError(
            executionNode = executionNodeRecord,
            error = errorDetails,
            completedTime = ZonedDateTime.now(),
            startTime = startTime
        )
    } catch (persistError: Exception) {
        logger.error(persistError) { "Failed to persist error state for node $nodeId" }
    }

    // Classify and throw ApplicationFailure for Temporal retry handling
    classifyAndThrowError(e, nodeId, node.name, node.type, attempt)
}
```

4. Add a new method to update execution node with structured error:
```kotlin
private fun updateExecutionNodeWithError(
    executionNode: WorkflowExecutionNodeEntity,
    error: NodeExecutionError,
    completedTime: ZonedDateTime,
    startTime: ZonedDateTime
) {
    val durationMs = java.time.Duration.between(startTime, completedTime).toMillis()

    val updated = executionNode.copy(
        status = WorkflowStatus.FAILED,
        completedAt = completedTime,
        durationMs = durationMs,
        output = null,
        error = error  // Now stores structured NodeExecutionError
    )

    workflowExecutionNodeRepository.save(updated)
}
```

5. Import WorkflowNodeType if not already imported:
```kotlin
import riven.core.enums.workflow.WorkflowNodeType
```
  </action>
  <verify>
File compiles: `./gradlew compileKotlin`
  </verify>
  <done>
WorkflowCoordinationService uses WorkflowErrorClassifier to classify exceptions. Throws ApplicationFailure with matching error type names. Structured NodeExecutionError persisted to database. Non-retryable errors use newNonRetryableFailure(), retryable use newFailureWithCause().
  </done>
</task>

</tasks>

<verification>
All files compile without errors:
```bash
./gradlew compileKotlin
```

Check that imports are correct and ApplicationFailure is from io.temporal.failure package.
Check that WorkflowErrorClassifier is imported and used for classification.
</verification>

<success_criteria>
- [ ] WorkflowErrorClassifier utility class exists with classifyError() and classifyErrorWithMessage()
- [ ] WorkflowOrchestrationServiceImpl has setDoNotRetry with 4 non-retryable error types
- [ ] Maximum retry interval reduced to 30 seconds (per CONTEXT.md)
- [ ] Comment documents why retry values are hardcoded (workflow is not a Spring bean)
- [ ] WorkflowCoordinationService imports and uses WorkflowErrorClassifier
- [ ] classifyAndThrowError() method uses WorkflowErrorClassifier.classifyErrorWithMessage()
- [ ] Non-retryable errors throw ApplicationFailure.newNonRetryableFailure()
- [ ] Retryable errors throw ApplicationFailure.newFailureWithCause()
- [ ] Structured NodeExecutionError persisted on failure
- [ ] Error type names match between doNotRetry list and ApplicationFailure type parameter
- [ ] All code compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/07-error-handling-retry-logic/07-02-SUMMARY.md`
</output>
