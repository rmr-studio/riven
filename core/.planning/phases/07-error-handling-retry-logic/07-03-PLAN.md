---
phase: 07-error-handling-retry-logic
plan: 03
type: execute
wave: 3
depends_on: ["07-02"]
files_modified:
  - src/main/kotlin/riven/core/service/workflow/WorkflowExecutionService.kt
  - src/main/kotlin/riven/core/models/response/workflow/execution/WorkflowExecutionSummaryResponse.kt
  - src/test/kotlin/riven/core/service/workflow/engine/error/WorkflowErrorClassifierTest.kt
autonomous: true
user_setup: []

must_haves:
  truths:
    - "API responses include structured error details when execution fails"
    - "Error classification is tested for all major error types"
    - "Execution summary includes node-level error information"
  artifacts:
    - path: "src/main/kotlin/riven/core/models/response/workflow/execution/WorkflowExecutionSummaryResponse.kt"
      provides: "Enhanced response with error surfacing"
      exports: ["WorkflowExecutionSummaryResponse"]
    - path: "src/test/kotlin/riven/core/service/workflow/engine/error/WorkflowErrorClassifierTest.kt"
      provides: "Unit tests for error classification utility"
      min_lines: 80
  key_links:
    - from: "WorkflowExecutionService"
      to: "WorkflowExecutionError"
      via: "Error model mapping in getExecutionSummary"
      pattern: "WorkflowExecutionError"
    - from: "WorkflowErrorClassifierTest"
      to: "WorkflowErrorClassifier"
      via: "Direct function calls to classifyError"
      pattern: "WorkflowErrorClassifier\\.classifyError"
---

<objective>
Surface structured errors in API responses and add unit tests for WorkflowErrorClassifier.

Purpose: Ensure errors are visible to API consumers with actionable details (which node failed, why, retry count). Validate error classification logic through unit tests covering all major error types by testing the extracted WorkflowErrorClassifier utility directly.

Output:
- Enhanced WorkflowExecutionSummaryResponse with error details
- Unit tests for WorkflowErrorClassifier covering HTTP 4xx/5xx, validation, security, CONDITION nodes
- Error details surfaced in execution queries
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-error-handling-retry-logic/07-RESEARCH.md
@.planning/phases/07-error-handling-retry-logic/07-CONTEXT.md
@.planning/phases/07-error-handling-retry-logic/07-01-SUMMARY.md
@.planning/phases/07-error-handling-retry-logic/07-02-SUMMARY.md
@src/main/kotlin/riven/core/service/workflow/WorkflowExecutionService.kt
@src/main/kotlin/riven/core/models/response/workflow/execution/WorkflowExecutionSummaryResponse.kt
@src/main/kotlin/riven/core/controller/workflow/WorkflowExecutionController.kt
@src/main/kotlin/riven/core/service/workflow/engine/error/WorkflowErrorClassifier.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance WorkflowExecutionSummaryResponse with error details</name>
  <files>
    src/main/kotlin/riven/core/models/response/workflow/execution/WorkflowExecutionSummaryResponse.kt
  </files>
  <action>
Read the existing WorkflowExecutionSummaryResponse and enhance it to include error information.

The response currently contains:
- execution: WorkflowExecutionRecord
- nodes: List<WorkflowExecutionNodeRecord>

The error fields already exist in the underlying records (execution.error, node.error as Any?). The enhancement is to ensure the structured error models are properly typed and documented.

Check if WorkflowExecutionSummaryResponse needs any changes. If the existing structure already supports returning error details via the `error: Any?` field, document that it will contain:
- For workflow execution: WorkflowExecutionError (or null if successful)
- For node execution: NodeExecutionError (or null if successful)

If the response class is minimal, consider adding a computed property or helper method to extract error summary:

```kotlin
data class WorkflowExecutionSummaryResponse(
    val execution: WorkflowExecutionRecord,
    val nodes: List<WorkflowExecutionNodeRecord>
) {
    /**
     * Returns the first failed node's error details, if any.
     * Error is stored as NodeExecutionError in the node's error field.
     */
    val failedNode: WorkflowExecutionNodeRecord?
        get() = nodes.firstOrNull { it.status == WorkflowStatus.FAILED }

    /**
     * Returns true if any node in the execution failed.
     */
    val hasErrors: Boolean
        get() = nodes.any { it.status == WorkflowStatus.FAILED }
}
```

Import WorkflowStatus if needed:
```kotlin
import riven.core.enums.workflow.WorkflowStatus
```

The existing JSONB serialization will automatically serialize NodeExecutionError to JSON in the response since it's a data class with Jackson-compatible fields.
  </action>
  <verify>
File compiles: `./gradlew compileKotlin`
  </verify>
  <done>
WorkflowExecutionSummaryResponse provides access to error details via computed properties or existing error fields. Failed node can be identified from response.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create unit tests for WorkflowErrorClassifier</name>
  <files>
    src/test/kotlin/riven/core/service/workflow/engine/error/WorkflowErrorClassifierTest.kt
  </files>
  <action>
Create a new test file for WorkflowErrorClassifier that tests the extracted utility class directly.

The tests should verify:
1. HTTP 4xx errors are classified as HTTP_CLIENT_ERROR (non-retryable)
2. HTTP 5xx errors are classified as HTTP_SERVER_ERROR (retryable)
3. IllegalArgumentException is classified as VALIDATION_ERROR (non-retryable)
4. SchemaValidationException is classified as VALIDATION_ERROR (non-retryable)
5. SecurityException is classified as SECURITY_ERROR (non-retryable)
6. CONTROL_FLOW node errors are classified as CONTROL_FLOW_ERROR (non-retryable)
7. Generic exceptions are classified as EXECUTION_ERROR (retryable)
8. classifyErrorWithMessage returns both type and formatted message

Since WorkflowErrorClassifier is a Kotlin object (singleton), we can test it directly without any mocking.

Create the test file:
```kotlin
package riven.core.service.workflow.engine.error

import org.junit.jupiter.api.Test
import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.DisplayName
import org.junit.jupiter.api.Nested
import org.springframework.http.HttpHeaders
import org.springframework.web.reactive.function.client.WebClientResponseException
import riven.core.enums.workflow.WorkflowErrorType
import riven.core.enums.workflow.WorkflowNodeType
import riven.core.exceptions.SchemaValidationException
import java.nio.charset.Charset

/**
 * Unit tests for WorkflowErrorClassifier.
 *
 * Tests the error classification logic directly without mocking,
 * since WorkflowErrorClassifier is a stateless utility object.
 */
class WorkflowErrorClassifierTest {

    @Nested
    @DisplayName("HTTP Error Classification")
    inner class HttpErrorClassification {

        @Test
        @DisplayName("HTTP 400 Bad Request should be classified as HTTP_CLIENT_ERROR (non-retryable)")
        fun `HTTP 400 should be non-retryable HTTP_CLIENT_ERROR`() {
            val exception = WebClientResponseException.create(
                400, "Bad Request", HttpHeaders.EMPTY, ByteArray(0), Charset.defaultCharset()
            )

            val errorType = WorkflowErrorClassifier.classifyError(exception, WorkflowNodeType.ACTION)

            assertEquals(WorkflowErrorType.HTTP_CLIENT_ERROR, errorType)
            assertFalse(errorType.retryable, "HTTP 4xx errors should not be retryable")
        }

        @Test
        @DisplayName("HTTP 401 Unauthorized should be classified as HTTP_CLIENT_ERROR (non-retryable)")
        fun `HTTP 401 should be non-retryable HTTP_CLIENT_ERROR`() {
            val exception = WebClientResponseException.create(
                401, "Unauthorized", HttpHeaders.EMPTY, ByteArray(0), Charset.defaultCharset()
            )

            val errorType = WorkflowErrorClassifier.classifyError(exception, WorkflowNodeType.ACTION)

            assertEquals(WorkflowErrorType.HTTP_CLIENT_ERROR, errorType)
            assertFalse(errorType.retryable)
        }

        @Test
        @DisplayName("HTTP 404 Not Found should be classified as HTTP_CLIENT_ERROR (non-retryable)")
        fun `HTTP 404 should be non-retryable HTTP_CLIENT_ERROR`() {
            val exception = WebClientResponseException.create(
                404, "Not Found", HttpHeaders.EMPTY, ByteArray(0), Charset.defaultCharset()
            )

            val errorType = WorkflowErrorClassifier.classifyError(exception, WorkflowNodeType.ACTION)

            assertEquals(WorkflowErrorType.HTTP_CLIENT_ERROR, errorType)
            assertFalse(errorType.retryable)
        }

        @Test
        @DisplayName("HTTP 500 Internal Server Error should be classified as HTTP_SERVER_ERROR (retryable)")
        fun `HTTP 500 should be retryable HTTP_SERVER_ERROR`() {
            val exception = WebClientResponseException.create(
                500, "Internal Server Error", HttpHeaders.EMPTY, ByteArray(0), Charset.defaultCharset()
            )

            val errorType = WorkflowErrorClassifier.classifyError(exception, WorkflowNodeType.ACTION)

            assertEquals(WorkflowErrorType.HTTP_SERVER_ERROR, errorType)
            assertTrue(errorType.retryable, "HTTP 5xx errors should be retryable")
        }

        @Test
        @DisplayName("HTTP 502 Bad Gateway should be classified as HTTP_SERVER_ERROR (retryable)")
        fun `HTTP 502 should be retryable HTTP_SERVER_ERROR`() {
            val exception = WebClientResponseException.create(
                502, "Bad Gateway", HttpHeaders.EMPTY, ByteArray(0), Charset.defaultCharset()
            )

            val errorType = WorkflowErrorClassifier.classifyError(exception, WorkflowNodeType.ACTION)

            assertEquals(WorkflowErrorType.HTTP_SERVER_ERROR, errorType)
            assertTrue(errorType.retryable)
        }

        @Test
        @DisplayName("HTTP 503 Service Unavailable should be classified as HTTP_SERVER_ERROR (retryable)")
        fun `HTTP 503 should be retryable HTTP_SERVER_ERROR`() {
            val exception = WebClientResponseException.create(
                503, "Service Unavailable", HttpHeaders.EMPTY, ByteArray(0), Charset.defaultCharset()
            )

            val errorType = WorkflowErrorClassifier.classifyError(exception, WorkflowNodeType.ACTION)

            assertEquals(WorkflowErrorType.HTTP_SERVER_ERROR, errorType)
            assertTrue(errorType.retryable)
        }
    }

    @Nested
    @DisplayName("Validation Error Classification")
    inner class ValidationErrorClassification {

        @Test
        @DisplayName("IllegalArgumentException should be classified as VALIDATION_ERROR (non-retryable)")
        fun `IllegalArgumentException should be non-retryable VALIDATION_ERROR`() {
            val exception = IllegalArgumentException("Invalid input parameter")

            val errorType = WorkflowErrorClassifier.classifyError(exception, WorkflowNodeType.ACTION)

            assertEquals(WorkflowErrorType.VALIDATION_ERROR, errorType)
            assertFalse(errorType.retryable, "Validation errors should not be retryable")
        }

        @Test
        @DisplayName("SchemaValidationException should be classified as VALIDATION_ERROR (non-retryable)")
        fun `SchemaValidationException should be non-retryable VALIDATION_ERROR`() {
            val exception = SchemaValidationException(listOf("Field 'email' is required"))

            val errorType = WorkflowErrorClassifier.classifyError(exception, WorkflowNodeType.ACTION)

            assertEquals(WorkflowErrorType.VALIDATION_ERROR, errorType)
            assertFalse(errorType.retryable)
        }
    }

    @Nested
    @DisplayName("Security Error Classification")
    inner class SecurityErrorClassification {

        @Test
        @DisplayName("SecurityException should be classified as SECURITY_ERROR (non-retryable)")
        fun `SecurityException should be non-retryable SECURITY_ERROR`() {
            val exception = SecurityException("Access denied to resource")

            val errorType = WorkflowErrorClassifier.classifyError(exception, WorkflowNodeType.ACTION)

            assertEquals(WorkflowErrorType.SECURITY_ERROR, errorType)
            assertFalse(errorType.retryable, "Security errors should not be retryable")
        }
    }

    @Nested
    @DisplayName("Control Flow Error Classification")
    inner class ControlFlowErrorClassification {

        @Test
        @DisplayName("Any exception in CONTROL_FLOW node should be classified as CONTROL_FLOW_ERROR (non-retryable)")
        fun `CONTROL_FLOW node errors should be non-retryable CONTROL_FLOW_ERROR`() {
            val exception = RuntimeException("Condition evaluation failed")

            val errorType = WorkflowErrorClassifier.classifyError(exception, WorkflowNodeType.CONTROL_FLOW)

            assertEquals(WorkflowErrorType.CONTROL_FLOW_ERROR, errorType)
            assertFalse(errorType.retryable, "Control flow errors should not be retryable")
        }

        @Test
        @DisplayName("NullPointerException in CONTROL_FLOW node should be CONTROL_FLOW_ERROR")
        fun `NPE in CONTROL_FLOW should be CONTROL_FLOW_ERROR`() {
            val exception = NullPointerException("Null value in condition")

            val errorType = WorkflowErrorClassifier.classifyError(exception, WorkflowNodeType.CONTROL_FLOW)

            assertEquals(WorkflowErrorType.CONTROL_FLOW_ERROR, errorType)
            assertFalse(errorType.retryable)
        }
    }

    @Nested
    @DisplayName("Generic Error Classification")
    inner class GenericErrorClassification {

        @Test
        @DisplayName("Generic RuntimeException in ACTION node should be classified as EXECUTION_ERROR (retryable)")
        fun `RuntimeException in ACTION should be retryable EXECUTION_ERROR`() {
            val exception = RuntimeException("Something unexpected happened")

            val errorType = WorkflowErrorClassifier.classifyError(exception, WorkflowNodeType.ACTION)

            assertEquals(WorkflowErrorType.EXECUTION_ERROR, errorType)
            assertTrue(errorType.retryable, "Generic execution errors should be retryable")
        }

        @Test
        @DisplayName("Generic Exception in ACTION node should be classified as EXECUTION_ERROR (retryable)")
        fun `Exception in ACTION should be retryable EXECUTION_ERROR`() {
            val exception = Exception("Generic error")

            val errorType = WorkflowErrorClassifier.classifyError(exception, WorkflowNodeType.ACTION)

            assertEquals(WorkflowErrorType.EXECUTION_ERROR, errorType)
            assertTrue(errorType.retryable)
        }
    }

    @Nested
    @DisplayName("classifyErrorWithMessage")
    inner class ClassifyErrorWithMessage {

        @Test
        @DisplayName("Should return HTTP status code in message for HTTP errors")
        fun `should include HTTP status in message for HTTP errors`() {
            val exception = WebClientResponseException.create(
                404, "Not Found", HttpHeaders.EMPTY, ByteArray(0), Charset.defaultCharset()
            )

            val (errorType, message) = WorkflowErrorClassifier.classifyErrorWithMessage(
                exception, WorkflowNodeType.ACTION
            )

            assertEquals(WorkflowErrorType.HTTP_CLIENT_ERROR, errorType)
            assertTrue(message.contains("404"), "Message should contain HTTP status code")
        }

        @Test
        @DisplayName("Should return 'Validation failed' prefix for validation errors")
        fun `should prefix validation error messages`() {
            val exception = IllegalArgumentException("Email format is invalid")

            val (errorType, message) = WorkflowErrorClassifier.classifyErrorWithMessage(
                exception, WorkflowNodeType.ACTION
            )

            assertEquals(WorkflowErrorType.VALIDATION_ERROR, errorType)
            assertTrue(message.startsWith("Validation failed:"), "Message should start with 'Validation failed:'")
        }

        @Test
        @DisplayName("Should return 'Security error' prefix for security errors")
        fun `should prefix security error messages`() {
            val exception = SecurityException("Insufficient permissions")

            val (errorType, message) = WorkflowErrorClassifier.classifyErrorWithMessage(
                exception, WorkflowNodeType.ACTION
            )

            assertEquals(WorkflowErrorType.SECURITY_ERROR, errorType)
            assertTrue(message.startsWith("Security error:"), "Message should start with 'Security error:'")
        }

        @Test
        @DisplayName("Should return 'Control flow failed' prefix for control flow errors")
        fun `should prefix control flow error messages`() {
            val exception = RuntimeException("Condition returned null")

            val (errorType, message) = WorkflowErrorClassifier.classifyErrorWithMessage(
                exception, WorkflowNodeType.CONTROL_FLOW
            )

            assertEquals(WorkflowErrorType.CONTROL_FLOW_ERROR, errorType)
            assertTrue(message.startsWith("Control flow failed:"), "Message should start with 'Control flow failed:'")
        }
    }
}
```

This test file:
- Tests WorkflowErrorClassifier.classifyError() directly (no mocking needed)
- Covers all error types: HTTP 4xx/5xx, validation, security, control flow, generic
- Tests the retryable property for each error type
- Tests classifyErrorWithMessage() for message formatting
- Uses nested test classes for organization
- Uses @DisplayName for readable test output
  </action>
  <verify>
Tests pass: `./gradlew test --tests "riven.core.service.workflow.engine.error.WorkflowErrorClassifierTest"`
  </verify>
  <done>
Unit tests exist for all major error classification scenarios: HTTP 4xx/5xx, validation errors, security errors, CONTROL_FLOW errors, and generic exceptions. Tests call WorkflowErrorClassifier directly. All tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify error surfacing in API responses</name>
  <files>
    src/main/kotlin/riven/core/service/workflow/WorkflowExecutionService.kt
  </files>
  <action>
Review WorkflowExecutionService.getExecutionSummary() to ensure it correctly surfaces error information.

The existing implementation already:
1. Fetches execution with node executions via JOIN query
2. Maps to WorkflowExecutionSummaryResponse
3. Includes error field in both WorkflowExecutionRecord and WorkflowExecutionNodeRecord

Verify the error field flows through:
- WorkflowExecutionEntity.error (JSONB) -> WorkflowExecutionRecord.error (Any?)
- WorkflowExecutionNodeEntity.error (JSONB) -> WorkflowExecutionNodeRecord.error (Any?)

The JSONB columns already store the error details. When NodeExecutionError is persisted (from Plan 02), it will be serialized to JSONB by Hypersistence Utils and deserialized back when queried.

If the existing code already handles this correctly, add a brief comment documenting the error flow:

```kotlin
/**
 * Get execution summary including the execution record and all node executions
 * with their associated workflow node definitions.
 *
 * Error details are surfaced in the error field of both execution and node records:
 * - execution.error: WorkflowExecutionError (when workflow fails)
 * - node.error: NodeExecutionError (when node fails, includes retry history)
 *
 * Uses a single JOIN query to fetch all related data efficiently.
 */
```

If any mapping issues exist (e.g., error field not being included), fix them.

Also verify the WorkflowExecutionRecord and WorkflowExecutionNodeRecord include the error field in their data class definitions (they should already have `val error: Any?`).
  </action>
  <verify>
Code compiles: `./gradlew compileKotlin`
Review getExecutionSummary implementation manually to confirm error flow.
  </verify>
  <done>
Error details flow from database JSONB columns through entity mapping to API response. Documentation updated to clarify error structure.
  </done>
</task>

</tasks>

<verification>
All code compiles and tests pass:
```bash
./gradlew build
```

Manual verification: Review that error fields are present in response models.
</verification>

<success_criteria>
- [ ] WorkflowExecutionSummaryResponse has helper properties or existing error field access
- [ ] Unit tests exist for WorkflowErrorClassifier (not duplicated logic in tests)
- [ ] Tests call WorkflowErrorClassifier.classifyError() directly
- [ ] HTTP 4xx classified as non-retryable HTTP_CLIENT_ERROR
- [ ] HTTP 5xx classified as retryable HTTP_SERVER_ERROR
- [ ] Validation errors classified as non-retryable VALIDATION_ERROR
- [ ] Security errors classified as non-retryable SECURITY_ERROR
- [ ] CONTROL_FLOW errors classified as non-retryable CONTROL_FLOW_ERROR
- [ ] Generic errors classified as retryable EXECUTION_ERROR
- [ ] All tests pass
- [ ] Error details flow to API responses
</success_criteria>

<output>
After completion, create `.planning/phases/07-error-handling-retry-logic/07-03-SUMMARY.md`
</output>
