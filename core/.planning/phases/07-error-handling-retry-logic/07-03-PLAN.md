---
phase: 07-error-handling-retry-logic
plan: 03
type: execute
wave: 3
depends_on: ["07-02"]
files_modified:
  - src/main/kotlin/riven/core/service/workflow/WorkflowExecutionService.kt
  - src/main/kotlin/riven/core/models/response/workflow/execution/WorkflowExecutionSummaryResponse.kt
  - src/test/kotlin/riven/core/service/workflow/engine/coordinator/WorkflowCoordinationServiceTest.kt
autonomous: true
user_setup: []

must_haves:
  truths:
    - "API responses include structured error details when execution fails"
    - "Error classification is tested for all major error types"
    - "Execution summary includes node-level error information"
  artifacts:
    - path: "src/main/kotlin/riven/core/models/response/workflow/execution/WorkflowExecutionSummaryResponse.kt"
      provides: "Enhanced response with error surfacing"
      exports: ["WorkflowExecutionSummaryResponse"]
    - path: "src/test/kotlin/riven/core/service/workflow/engine/coordinator/WorkflowCoordinationServiceTest.kt"
      provides: "Unit tests for error classification"
      min_lines: 50
  key_links:
    - from: "WorkflowExecutionService"
      to: "WorkflowExecutionError"
      via: "Error model mapping in getExecutionSummary"
      pattern: "WorkflowExecutionError"
    - from: "WorkflowCoordinationServiceTest"
      to: "ApplicationFailure"
      via: "Test assertions for error type"
      pattern: "ApplicationFailure"
---

<objective>
Surface structured errors in API responses and add unit tests for error classification.

Purpose: Ensure errors are visible to API consumers with actionable details (which node failed, why, retry count). Validate error classification logic through unit tests covering all major error types.

Output:
- Enhanced WorkflowExecutionSummaryResponse with error details
- Unit tests for error classification covering HTTP 4xx/5xx, validation, security, CONDITION nodes
- Error details surfaced in execution queries
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-error-handling-retry-logic/07-RESEARCH.md
@.planning/phases/07-error-handling-retry-logic/07-CONTEXT.md
@.planning/phases/07-error-handling-retry-logic/07-01-SUMMARY.md
@.planning/phases/07-error-handling-retry-logic/07-02-SUMMARY.md
@src/main/kotlin/riven/core/service/workflow/WorkflowExecutionService.kt
@src/main/kotlin/riven/core/models/response/workflow/execution/WorkflowExecutionSummaryResponse.kt
@src/main/kotlin/riven/core/controller/workflow/WorkflowExecutionController.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance WorkflowExecutionSummaryResponse with error details</name>
  <files>
    src/main/kotlin/riven/core/models/response/workflow/execution/WorkflowExecutionSummaryResponse.kt
  </files>
  <action>
Read the existing WorkflowExecutionSummaryResponse and enhance it to include error information.

The response currently contains:
- execution: WorkflowExecutionRecord
- nodes: List<WorkflowExecutionNodeRecord>

The error fields already exist in the underlying records (execution.error, node.error as Any?). The enhancement is to ensure the structured error models are properly typed and documented.

Check if WorkflowExecutionSummaryResponse needs any changes. If the existing structure already supports returning error details via the `error: Any?` field, document that it will contain:
- For workflow execution: WorkflowExecutionError (or null if successful)
- For node execution: NodeExecutionError (or null if successful)

If the response class is minimal, consider adding a computed property or helper method to extract error summary:

```kotlin
data class WorkflowExecutionSummaryResponse(
    val execution: WorkflowExecutionRecord,
    val nodes: List<WorkflowExecutionNodeRecord>
) {
    /**
     * Returns the first failed node's error details, if any.
     * Error is stored as NodeExecutionError in the node's error field.
     */
    val failedNode: WorkflowExecutionNodeRecord?
        get() = nodes.firstOrNull { it.status == WorkflowStatus.FAILED }

    /**
     * Returns true if any node in the execution failed.
     */
    val hasErrors: Boolean
        get() = nodes.any { it.status == WorkflowStatus.FAILED }
}
```

Import WorkflowStatus if needed:
```kotlin
import riven.core.enums.workflow.WorkflowStatus
```

The existing JSONB serialization will automatically serialize NodeExecutionError to JSON in the response since it's a data class with Jackson-compatible fields.
  </action>
  <verify>
File compiles: `./gradlew compileKotlin`
  </verify>
  <done>
WorkflowExecutionSummaryResponse provides access to error details via computed properties or existing error fields. Failed node can be identified from response.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create unit tests for error classification</name>
  <files>
    src/test/kotlin/riven/core/service/workflow/engine/coordinator/WorkflowCoordinationServiceTest.kt
  </files>
  <action>
Create a new test file for WorkflowCoordinationService error classification.

The tests should verify:
1. HTTP 4xx errors are classified as HTTP_CLIENT_ERROR (non-retryable)
2. HTTP 5xx errors are classified as HTTP_SERVER_ERROR (retryable)
3. IllegalArgumentException is classified as VALIDATION_ERROR (non-retryable)
4. SchemaValidationException is classified as VALIDATION_ERROR (non-retryable)
5. SecurityException is classified as SECURITY_ERROR (non-retryable)
6. CONTROL_FLOW node errors are classified as CONTROL_FLOW_ERROR (non-retryable)
7. Generic exceptions are classified as EXECUTION_ERROR (retryable)

Since the classifyErrorType function is private, test it indirectly by creating a small test utility or making the function internal for testing.

Alternative approach: Test the classifyErrorType logic by extracting it to a companion object or utility function that can be tested directly.

Create the test file:
```kotlin
package riven.core.service.workflow.engine.coordinator

import org.junit.jupiter.api.Test
import org.junit.jupiter.api.Assertions.*
import org.springframework.http.HttpStatus
import org.springframework.web.reactive.function.client.WebClientResponseException
import riven.core.enums.workflow.WorkflowErrorType
import riven.core.enums.workflow.WorkflowNodeType
import riven.core.exceptions.SchemaValidationException

class WorkflowCoordinationServiceTest {

    @Test
    fun `HTTP 4xx errors should be non-retryable`() {
        val errorType = classifyErrorType(
            WebClientResponseException.create(400, "Bad Request", null, null, null),
            WorkflowNodeType.ACTION
        )
        assertEquals(WorkflowErrorType.HTTP_CLIENT_ERROR, errorType)
        assertFalse(errorType.retryable)
    }

    @Test
    fun `HTTP 401 Unauthorized should be non-retryable`() {
        val errorType = classifyErrorType(
            WebClientResponseException.create(401, "Unauthorized", null, null, null),
            WorkflowNodeType.ACTION
        )
        assertEquals(WorkflowErrorType.HTTP_CLIENT_ERROR, errorType)
        assertFalse(errorType.retryable)
    }

    @Test
    fun `HTTP 5xx errors should be retryable`() {
        val errorType = classifyErrorType(
            WebClientResponseException.create(500, "Internal Server Error", null, null, null),
            WorkflowNodeType.ACTION
        )
        assertEquals(WorkflowErrorType.HTTP_SERVER_ERROR, errorType)
        assertTrue(errorType.retryable)
    }

    @Test
    fun `HTTP 503 Service Unavailable should be retryable`() {
        val errorType = classifyErrorType(
            WebClientResponseException.create(503, "Service Unavailable", null, null, null),
            WorkflowNodeType.ACTION
        )
        assertEquals(WorkflowErrorType.HTTP_SERVER_ERROR, errorType)
        assertTrue(errorType.retryable)
    }

    @Test
    fun `IllegalArgumentException should be non-retryable validation error`() {
        val errorType = classifyErrorType(
            IllegalArgumentException("Invalid input"),
            WorkflowNodeType.ACTION
        )
        assertEquals(WorkflowErrorType.VALIDATION_ERROR, errorType)
        assertFalse(errorType.retryable)
    }

    @Test
    fun `SchemaValidationException should be non-retryable validation error`() {
        val errorType = classifyErrorType(
            SchemaValidationException(listOf("Field required")),
            WorkflowNodeType.ACTION
        )
        assertEquals(WorkflowErrorType.VALIDATION_ERROR, errorType)
        assertFalse(errorType.retryable)
    }

    @Test
    fun `SecurityException should be non-retryable`() {
        val errorType = classifyErrorType(
            SecurityException("Access denied"),
            WorkflowNodeType.ACTION
        )
        assertEquals(WorkflowErrorType.SECURITY_ERROR, errorType)
        assertFalse(errorType.retryable)
    }

    @Test
    fun `CONTROL_FLOW node errors should be non-retryable`() {
        val errorType = classifyErrorType(
            RuntimeException("Condition evaluation failed"),
            WorkflowNodeType.CONTROL_FLOW
        )
        assertEquals(WorkflowErrorType.CONTROL_FLOW_ERROR, errorType)
        assertFalse(errorType.retryable)
    }

    @Test
    fun `Generic RuntimeException should be retryable`() {
        val errorType = classifyErrorType(
            RuntimeException("Something went wrong"),
            WorkflowNodeType.ACTION
        )
        assertEquals(WorkflowErrorType.EXECUTION_ERROR, errorType)
        assertTrue(errorType.retryable)
    }

    // Utility function for testing - mirrors the private function in WorkflowCoordinationService
    // Consider extracting to a shared utility or making internal in the service
    private fun classifyErrorType(e: Exception, nodeType: WorkflowNodeType): WorkflowErrorType {
        return when {
            e is WebClientResponseException && e.statusCode.is4xxClientError -> WorkflowErrorType.HTTP_CLIENT_ERROR
            e is WebClientResponseException && e.statusCode.is5xxServerError -> WorkflowErrorType.HTTP_SERVER_ERROR
            e is IllegalArgumentException || e is SchemaValidationException -> WorkflowErrorType.VALIDATION_ERROR
            e is SecurityException -> WorkflowErrorType.SECURITY_ERROR
            nodeType == WorkflowNodeType.CONTROL_FLOW -> WorkflowErrorType.CONTROL_FLOW_ERROR
            else -> WorkflowErrorType.EXECUTION_ERROR
        }
    }
}
```

If WebClientResponseException.create requires additional parameters, adjust accordingly. The key is testing the classification logic.
  </action>
  <verify>
Tests pass: `./gradlew test --tests "riven.core.service.workflow.engine.coordinator.WorkflowCoordinationServiceTest"`
  </verify>
  <done>
Unit tests exist for all major error classification scenarios: HTTP 4xx/5xx, validation errors, security errors, CONTROL_FLOW errors, and generic exceptions. All tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify error surfacing in API responses</name>
  <files>
    src/main/kotlin/riven/core/service/workflow/WorkflowExecutionService.kt
  </files>
  <action>
Review WorkflowExecutionService.getExecutionSummary() to ensure it correctly surfaces error information.

The existing implementation already:
1. Fetches execution with node executions via JOIN query
2. Maps to WorkflowExecutionSummaryResponse
3. Includes error field in both WorkflowExecutionRecord and WorkflowExecutionNodeRecord

Verify the error field flows through:
- WorkflowExecutionEntity.error (JSONB) -> WorkflowExecutionRecord.error (Any?)
- WorkflowExecutionNodeEntity.error (JSONB) -> WorkflowExecutionNodeRecord.error (Any?)

The JSONB columns already store the error details. When NodeExecutionError is persisted (from Plan 02), it will be serialized to JSONB by Hypersistence Utils and deserialized back when queried.

If the existing code already handles this correctly, add a brief comment documenting the error flow:

```kotlin
/**
 * Get execution summary including the execution record and all node executions
 * with their associated workflow node definitions.
 *
 * Error details are surfaced in the error field of both execution and node records:
 * - execution.error: WorkflowExecutionError (when workflow fails)
 * - node.error: NodeExecutionError (when node fails, includes retry history)
 *
 * Uses a single JOIN query to fetch all related data efficiently.
 */
```

If any mapping issues exist (e.g., error field not being included), fix them.

Also verify the WorkflowExecutionRecord and WorkflowExecutionNodeRecord include the error field in their data class definitions (they should already have `val error: Any?`).
  </action>
  <verify>
Code compiles: `./gradlew compileKotlin`
Review getExecutionSummary implementation manually to confirm error flow.
  </verify>
  <done>
Error details flow from database JSONB columns through entity mapping to API response. Documentation updated to clarify error structure.
  </done>
</task>

</tasks>

<verification>
All code compiles and tests pass:
```bash
./gradlew build
```

Manual verification: Review that error fields are present in response models.
</verification>

<success_criteria>
- [ ] WorkflowExecutionSummaryResponse has helper properties or existing error field access
- [ ] Unit tests exist for all error classification scenarios
- [ ] HTTP 4xx classified as non-retryable HTTP_CLIENT_ERROR
- [ ] HTTP 5xx classified as retryable HTTP_SERVER_ERROR
- [ ] Validation errors classified as non-retryable VALIDATION_ERROR
- [ ] Security errors classified as non-retryable SECURITY_ERROR
- [ ] CONTROL_FLOW errors classified as non-retryable CONTROL_FLOW_ERROR
- [ ] Generic errors classified as retryable EXECUTION_ERROR
- [ ] All tests pass
- [ ] Error details flow to API responses
</success_criteria>

<output>
After completion, create `.planning/phases/07-error-handling-retry-logic/07-03-SUMMARY.md`
</output>
