---
phase: 01-semantic-metadata-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/main/kotlin/riven/core/service/entity/EntityTypeSemanticMetadataService.kt
  - src/main/kotlin/riven/core/models/request/entity/type/SaveSemanticMetadataRequest.kt
  - src/main/kotlin/riven/core/models/request/entity/type/BulkSaveSemanticMetadataRequest.kt
  - src/main/kotlin/riven/core/service/entity/type/EntityTypeService.kt
  - src/main/kotlin/riven/core/service/entity/type/EntityTypeAttributeService.kt
  - src/main/kotlin/riven/core/service/entity/type/EntityTypeRelationshipService.kt
  - src/test/kotlin/riven/core/service/entity/EntityTypeSemanticMetadataServiceTest.kt
autonomous: true

must_haves:
  truths:
    - "Empty metadata records are auto-created when entity types are published (1:1 guarantee)"
    - "Empty metadata records are auto-created for initial identifier attribute on entity type creation"
    - "Metadata for attributes is hard-deleted when attribute is removed from entity type schema"
    - "Metadata for relationships is hard-deleted when relationship is removed"
    - "Metadata is soft-deleted when parent entity type is soft-deleted"
    - "PUT semantics: metadata update replaces all fields (definition, classification, tags)"
    - "Bulk upsert updates multiple attribute metadata records in a single transaction"
    - "Service validates entity type belongs to workspace before operating on metadata"
    - "Classification validation rejects unknown values via enum deserialization"
    - "No activity logging for metadata mutations (locked decision)"
  artifacts:
    - path: "src/main/kotlin/riven/core/service/entity/EntityTypeSemanticMetadataService.kt"
      provides: "Full CRUD service with lifecycle hooks"
      exports: ["EntityTypeSemanticMetadataService"]
      min_lines: 100
    - path: "src/main/kotlin/riven/core/models/request/entity/type/SaveSemanticMetadataRequest.kt"
      provides: "Single-target metadata update request DTO"
      exports: ["SaveSemanticMetadataRequest"]
    - path: "src/main/kotlin/riven/core/models/request/entity/type/BulkSaveSemanticMetadataRequest.kt"
      provides: "Bulk attribute metadata update request DTO"
      exports: ["BulkSaveSemanticMetadataRequest"]
    - path: "src/test/kotlin/riven/core/service/entity/EntityTypeSemanticMetadataServiceTest.kt"
      provides: "Unit tests for service CRUD and lifecycle hooks"
      min_lines: 100
  key_links:
    - from: "EntityTypeSemanticMetadataService"
      to: "EntityTypeSemanticMetadataRepository"
      via: "constructor injection"
      pattern: "private val repository: EntityTypeSemanticMetadataRepository"
    - from: "EntityTypeService.publishEntityType"
      to: "EntityTypeSemanticMetadataService.initializeForEntityType"
      via: "direct service call after save"
      pattern: "semanticMetadataService\\.initializeForEntityType"
    - from: "EntityTypeAttributeService.removeAttributeDefinition"
      to: "EntityTypeSemanticMetadataService.deleteForTarget"
      via: "cleanup call at end of method"
      pattern: "semanticMetadataService\\.deleteForTarget"
    - from: "EntityTypeSemanticMetadataService"
      to: "EntityTypeRepository"
      via: "workspace ownership verification"
      pattern: "entityTypeRepository"
---

<objective>
Build the EntityTypeSemanticMetadataService with full CRUD operations and wire lifecycle hooks into existing entity type services.

Purpose: This is the core business logic layer -- it manages metadata creation, reading, updating, and deletion, and ensures metadata lifecycle stays in sync with entity type/attribute/relationship lifecycle. The service enforces workspace security, validates ownership, and provides the API that the KnowledgeController (Plan 03) will delegate to.

Output: Service class, two request DTOs, lifecycle hooks in three existing services, unit test class.
</objective>

<execution_context>
@/home/jared/.claude/get-shit-done/workflows/execute-plan.md
@/home/jared/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-semantic-metadata-foundation/01-CONTEXT.md
@.planning/phases/01-semantic-metadata-foundation/01-RESEARCH.md
@.planning/phases/01-semantic-metadata-foundation/01-01-SUMMARY.md
@src/main/kotlin/riven/core/service/entity/type/EntityTypeService.kt
@src/main/kotlin/riven/core/service/entity/type/EntityTypeAttributeService.kt
@src/main/kotlin/riven/core/service/entity/type/EntityTypeRelationshipService.kt
@src/main/kotlin/riven/core/entity/entity/EntityTypeSemanticMetadataEntity.kt
@src/main/kotlin/riven/core/repository/entity/EntityTypeSemanticMetadataRepository.kt
@src/main/kotlin/riven/core/models/entity/EntityTypeSemanticMetadata.kt
@src/test/kotlin/riven/core/service/util/BaseServiceTest.kt
@src/test/kotlin/riven/core/service/entity/type/EntityTypeRelationshipServiceTest.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Request DTOs and EntityTypeSemanticMetadataService</name>
  <files>
    src/main/kotlin/riven/core/models/request/entity/type/SaveSemanticMetadataRequest.kt
    src/main/kotlin/riven/core/models/request/entity/type/BulkSaveSemanticMetadataRequest.kt
    src/main/kotlin/riven/core/service/entity/EntityTypeSemanticMetadataService.kt
  </files>
  <action>
1. Create `SaveSemanticMetadataRequest` data class in `riven.core.models.request.entity.type`:
   ```kotlin
   data class SaveSemanticMetadataRequest(
       val definition: String? = null,
       val classification: SemanticAttributeClassification? = null,
       val tags: List<String> = emptyList(),
   )
   ```
   Classification is nullable (users can set description/tags first and classify later per locked decision). Jackson will reject unknown classification values with a 400 via HttpMessageNotReadableException since the enum uses exact lowercase constants.

2. Create `BulkSaveSemanticMetadataRequest` data class in `riven.core.models.request.entity.type`:
   ```kotlin
   data class BulkSaveSemanticMetadataRequest(
       val targetId: UUID,
       val definition: String? = null,
       val classification: SemanticAttributeClassification? = null,
       val tags: List<String> = emptyList(),
   )
   ```

3. Create `EntityTypeSemanticMetadataService` in `riven.core.service.entity` (NOT in `service.entity.type` -- this is a new domain concern at the entity level, not a sub-service of EntityTypeService):

Constructor dependencies:
- `private val repository: EntityTypeSemanticMetadataRepository`
- `private val entityTypeRepository: EntityTypeRepository`
- `private val authTokenService: AuthTokenService`
- `private val logger: KLogger`

Organize methods using section comment blocks per CLAUDE.md:

**// ------ Public read operations ------**

- `getForEntityType(workspaceId: UUID, entityTypeId: UUID): EntityTypeSemanticMetadata`
  - `@PreAuthorize("@workspaceSecurity.hasWorkspace(#workspaceId)")`
  - Verify entity type belongs to workspace: call `verifyEntityTypeBelongsToWorkspace(workspaceId, entityTypeId)` (private helper)
  - Lookup via `repository.findByEntityTypeIdAndTargetTypeAndTargetId(entityTypeId, ENTITY_TYPE, entityTypeId)` -- for entity type metadata, targetId == entityTypeId
  - Use `ServiceUtil.findOrThrow` pattern for the Optional
  - Return `.toModel()`

- `getAttributeMetadata(workspaceId: UUID, entityTypeId: UUID): List<EntityTypeSemanticMetadata>`
  - `@PreAuthorize("@workspaceSecurity.hasWorkspace(#workspaceId)")`
  - Verify entity type belongs to workspace
  - `repository.findByEntityTypeIdAndTargetType(entityTypeId, ATTRIBUTE)` -> map to models

- `getRelationshipMetadata(workspaceId: UUID, entityTypeId: UUID): List<EntityTypeSemanticMetadata>`
  - Same pattern as getAttributeMetadata but with `RELATIONSHIP` target type

- `getAllMetadataForEntityType(workspaceId: UUID, entityTypeId: UUID): List<EntityTypeSemanticMetadata>`
  - `@PreAuthorize("@workspaceSecurity.hasWorkspace(#workspaceId)")`
  - Returns ALL metadata (entity type + attributes + relationships) for a single entity type
  - Used by `?include=semantics` feature

- `getMetadataForEntityTypes(entityTypeIds: List<UUID>): List<EntityTypeSemanticMetadata>`
  - No @PreAuthorize (called internally from EntityTypeController which already has workspace context)
  - `repository.findByEntityTypeIdIn(entityTypeIds)` -> map to models
  - Used for batch `?include=semantics` on workspace entity type list

**// ------ Public mutations ------**

- `upsertMetadata(workspaceId: UUID, entityTypeId: UUID, targetType: SemanticMetadataTargetType, targetId: UUID, request: SaveSemanticMetadataRequest): EntityTypeSemanticMetadata`
  - `@Transactional` + `@PreAuthorize("@workspaceSecurity.hasWorkspace(#workspaceId)")`
  - Verify entity type belongs to workspace
  - Find existing via `repository.findByEntityTypeIdAndTargetTypeAndTargetId(entityTypeId, targetType, targetId)`
  - If present: update `definition`, `classification`, `tags` fields (PUT semantics = full replacement)
  - If absent: create new entity with all fields
  - Save and return `.toModel()`
  - No activity logging per locked decision

- `bulkUpsertAttributeMetadata(workspaceId: UUID, entityTypeId: UUID, requests: List<BulkSaveSemanticMetadataRequest>): List<EntityTypeSemanticMetadata>`
  - `@Transactional` + `@PreAuthorize("@workspaceSecurity.hasWorkspace(#workspaceId)")`
  - Verify entity type belongs to workspace
  - For each request: delegate to upsert logic (but avoid N+1 -- fetch all existing attribute metadata for this entity type first, then update/create as needed)
  - Save all and return models

**// ------ Lifecycle hooks (called from other services) ------**

- `initializeForEntityType(entityTypeId: UUID, workspaceId: UUID, attributeIds: List<UUID>)`
  - No @PreAuthorize (called within existing @Transactional/@PreAuthorize context from EntityTypeService)
  - Create empty metadata record for the entity type itself: targetType=ENTITY_TYPE, targetId=entityTypeId
  - Create empty metadata records for each attributeId: targetType=ATTRIBUTE, targetId=attributeId
  - Batch save via `repository.saveAll()`
  - Log at debug level: "Initialized semantic metadata for entity type $entityTypeId with ${attributeIds.size} attributes"

- `initializeForTarget(entityTypeId: UUID, workspaceId: UUID, targetType: SemanticMetadataTargetType, targetId: UUID)`
  - Create a single empty metadata record for a new attribute or relationship added after initial creation
  - Save via `repository.save()`

- `deleteForTarget(entityTypeId: UUID, targetType: SemanticMetadataTargetType, targetId: UUID)`
  - Hard-delete via `repository.hardDeleteByTarget(entityTypeId, targetType, targetId)` per locked decision (attribute/relationship metadata hard-deleted on removal)

- `softDeleteForEntityType(entityTypeId: UUID)`
  - Soft-delete all metadata for entity type via `repository.softDeleteByEntityTypeId(entityTypeId)`
  - Called when entity type is soft-deleted

- `restoreForEntityType(entityTypeId: UUID)`
  - Placeholder for future restore functionality
  - Log warning: "restoreForEntityType not yet implemented - requires native query to bypass @SQLRestriction"
  - This is noted in research pitfall 1 as out of scope but must not be forgotten

**// ------ Private helpers ------**

- `verifyEntityTypeBelongsToWorkspace(workspaceId: UUID, entityTypeId: UUID): EntityTypeEntity`
  - Fetch entity type by ID via `ServiceUtil.findOrThrow { entityTypeRepository.findById(entityTypeId) }`
  - `require(entityType.workspaceId == workspaceId) { "Entity type $entityTypeId does not belong to workspace $workspaceId" }`
  - Return the entity (callers may need it)
  - This prevents the pitfall where a user supplies an entityTypeId from another workspace

IMPORTANT: Use `val userId = authTokenService.getUserId()` at the top of public methods (NOT `.let { userId -> ... }`). Per CLAUDE.md, do not wrap entire method body in a .let block.
  </action>
  <verify>Run `./gradlew build` -- project must compile. Verify service has @PreAuthorize on all public read/mutation methods. Verify no activity logging calls exist in the service.</verify>
  <done>Service class exists with all CRUD methods, lifecycle hooks, workspace verification, and @PreAuthorize annotations. Two request DTO classes exist. No activity logging present per locked decision.</done>
</task>

<task type="auto">
  <name>Task 2: Lifecycle hooks in existing services</name>
  <files>
    src/main/kotlin/riven/core/service/entity/type/EntityTypeService.kt
    src/main/kotlin/riven/core/service/entity/type/EntityTypeAttributeService.kt
    src/main/kotlin/riven/core/service/entity/type/EntityTypeRelationshipService.kt
  </files>
  <action>
1. Modify `EntityTypeService`:
   - Add `private val semanticMetadataService: EntityTypeSemanticMetadataService` to constructor parameters
   - In `publishEntityType()`: After the entity is saved (after `entityTypeRepository.save(this)`) and before the activity log, add:
     ```kotlin
     val entityTypeId = requireNotNull(savedEntity.id)
     semanticMetadataService.initializeForEntityType(
         entityTypeId = entityTypeId,
         workspaceId = workspaceId,
         attributeIds = listOf(primaryId) // primaryId is the identifier attribute UUID
     )
     ```
     NOTE: The existing code uses `.run { ... }.also { ... }.let { ... }` chaining (known inconsistency #8). Do NOT refactor the entire method -- just add the metadata initialization call at the right point within the existing chain. The saved entity's `id` is available inside the `.also { }` block.
   - In `deleteEntityType()`: Before `entityTypeRepository.delete(existing)`, add:
     ```kotlin
     semanticMetadataService.softDeleteForEntityType(requireNotNull(existing.id))
     ```
     This cascades the soft-delete to metadata records.

2. Modify `EntityTypeAttributeService`:
   - Add `private val semanticMetadataService: EntityTypeSemanticMetadataService` to constructor parameters
   - In `saveAttributeDefinition()`: After the schema is updated on the entity type (at the end of the method), check if this is a NEW attribute (not in the previous schema properties). If new, call:
     ```kotlin
     semanticMetadataService.initializeForTarget(
         entityTypeId = requireNotNull(type.id),
         workspaceId = requireNotNull(type.workspaceId),
         targetType = SemanticMetadataTargetType.ATTRIBUTE,
         targetId = id // the attribute UUID from the request destructuring
     )
     ```
     Detect "new" by checking: `type.schema.properties?.containsKey(id) != true` BEFORE applying the schema update (check before the `type.schema.copy(...)` call, store result in a `val isNewAttribute` flag).
   - In `removeAttributeDefinition()`: After the schema update is applied to the entity type, add:
     ```kotlin
     semanticMetadataService.deleteForTarget(
         entityTypeId = requireNotNull(type.id),
         targetType = SemanticMetadataTargetType.ATTRIBUTE,
         targetId = attributeId
     )
     ```
     This hard-deletes the metadata per locked decision.

3. Modify `EntityTypeRelationshipService`:
   - Add `private val semanticMetadataService: EntityTypeSemanticMetadataService` to constructor parameters
   - Find the method that adds new relationships (likely in `updateRelationships` where `diff.added` is processed). After a new relationship definition is saved to the entity type's relationships JSONB, call:
     ```kotlin
     semanticMetadataService.initializeForTarget(
         entityTypeId = requireNotNull(entityType.id),
         workspaceId = requireNotNull(entityType.workspaceId),
         targetType = SemanticMetadataTargetType.RELATIONSHIP,
         targetId = relationship.id // the relationship definition UUID
     )
     ```
   - Find the method that removes relationships (likely in `removeRelationships`). After a relationship definition is removed from the entity type's relationships JSONB, call:
     ```kotlin
     semanticMetadataService.deleteForTarget(
         entityTypeId = requireNotNull(entityType.id),
         targetType = SemanticMetadataTargetType.RELATIONSHIP,
         targetId = relationship.id
     )
     ```

IMPORTANT: Read the full source of `EntityTypeRelationshipService.kt` before modifying -- it is a large file (~1400 lines). Identify the exact methods and insertion points. Do not refactor unrelated code. When fixing a bug, do not refactor unrelated code in the same change.
  </action>
  <verify>Run `./gradlew build` -- project must compile. Run `./gradlew test` -- all existing tests must pass. The semanticMetadataService is a new constructor dependency, so existing tests that mock EntityTypeService/EntityTypeAttributeService/EntityTypeRelationshipService will need a `@MockitoBean` for it. Check test compilation and fix any missing mock declarations.</verify>
  <done>EntityTypeService.publishEntityType creates metadata on entity type creation. EntityTypeService.deleteEntityType soft-deletes metadata. EntityTypeAttributeService creates metadata for new attributes and hard-deletes metadata on attribute removal. EntityTypeRelationshipService creates metadata for new relationships and hard-deletes metadata on relationship removal. All existing tests pass.</done>
</task>

<task type="auto">
  <name>Task 3: Unit tests for EntityTypeSemanticMetadataService</name>
  <files>
    src/test/kotlin/riven/core/service/entity/EntityTypeSemanticMetadataServiceTest.kt
  </files>
  <action>
Create unit test class following the established pattern from `EntityTypeRelationshipServiceTest`:

```kotlin
@SpringBootTest(
    classes = [
        AuthTokenService::class,
        WorkspaceSecurity::class,
        EntityTypeSemanticMetadataServiceTest.TestConfig::class,
        EntityTypeSemanticMetadataService::class
    ]
)
@WithUserPersona(
    userId = "f8b1c2d3-4e5f-6789-abcd-ef0123456789",
    email = "test@test.com",
    displayName = "Test User",
    roles = [
        WorkspaceRole(
            workspaceId = "f8b1c2d3-4e5f-6789-abcd-ef9876543210",
            role = WorkspaceRoles.OWNER
        )
    ]
)
class EntityTypeSemanticMetadataServiceTest : BaseServiceTest() {
    @Configuration
    class TestConfig

    @MockitoBean private lateinit var repository: EntityTypeSemanticMetadataRepository
    @MockitoBean private lateinit var entityTypeRepository: EntityTypeRepository
    @MockitoBean private lateinit var authTokenService: AuthTokenService

    @Autowired private lateinit var service: EntityTypeSemanticMetadataService
```

Test cases to implement (use backtick function names per convention):

**Read operations:**
- `getForEntityType - returns metadata when exists`: Mock repository to return an entity, verify toModel() result
- `getForEntityType - throws NotFoundException when entity type not found`: Mock entityTypeRepository.findById to return empty
- `getForEntityType - throws when entity type belongs to different workspace`: Mock entity type with different workspaceId, verify IllegalArgumentException
- `getAttributeMetadata - returns all attribute metadata for entity type`: Mock repository to return list filtered by ATTRIBUTE target type
- `getRelationshipMetadata - returns all relationship metadata for entity type`: Same pattern with RELATIONSHIP

**Mutations:**
- `upsertMetadata - creates new metadata when none exists`: Mock repository find to return empty, verify save called with correct fields
- `upsertMetadata - updates existing metadata with full replacement`: Mock repository find to return existing entity, verify all fields replaced (definition, classification, tags)
- `bulkUpsertAttributeMetadata - creates and updates multiple attributes`: Mix of new and existing, verify correct save calls

**Lifecycle hooks:**
- `initializeForEntityType - creates metadata for entity type and attributes`: Verify saveAll called with correct number of entities (1 entity type + N attributes)
- `initializeForTarget - creates single metadata record`: Verify save called once
- `deleteForTarget - hard deletes metadata`: Verify repository.hardDeleteByTarget called with correct args
- `softDeleteForEntityType - soft deletes all metadata`: Verify repository.softDeleteByEntityTypeId called

**Workspace verification:**
- `upsertMetadata - rejects when entity type not in workspace`: Verify IllegalArgumentException thrown

Use `whenever` from mockito-kotlin (not `Mockito.when`). Use `verify` from mockito-kotlin. Create test helper factory methods for building test `EntityTypeSemanticMetadataEntity` and `EntityTypeEntity` instances.
  </action>
  <verify>Run `./gradlew test --tests "riven.core.service.entity.EntityTypeSemanticMetadataServiceTest"` -- all tests pass.</verify>
  <done>Unit test class exists with 12+ test cases covering reads, mutations, lifecycle hooks, and workspace verification. All tests pass.</done>
</task>

</tasks>

<verification>
1. `./gradlew test` passes with all existing and new tests
2. `EntityTypeSemanticMetadataService` has @PreAuthorize on all public read/mutation methods
3. `EntityTypeService.publishEntityType` calls `semanticMetadataService.initializeForEntityType`
4. `EntityTypeAttributeService.removeAttributeDefinition` calls `semanticMetadataService.deleteForTarget`
5. Relationship add/remove in EntityTypeRelationshipService calls appropriate metadata lifecycle methods
6. No activity logging in metadata service
7. Request DTOs use nullable classification field
</verification>

<success_criteria>
- `./gradlew test` passes (all existing + new tests)
- Service has workspace verification on all public methods
- Lifecycle hooks are wired: create entity type -> auto-create metadata, remove attribute -> hard-delete metadata, remove relationship -> hard-delete metadata, soft-delete entity type -> soft-delete metadata
- Unit tests cover CRUD operations, lifecycle hooks, and workspace security enforcement
- PUT semantics confirmed: upsert replaces all fields
</success_criteria>

<output>
After completion, create `.planning/phases/01-semantic-metadata-foundation/01-02-SUMMARY.md`
</output>
