---
phase: 01-semantic-metadata-foundation
plan: 03
type: execute
wave: 3
depends_on: ["01-02"]
files_modified:
  - src/main/kotlin/riven/core/controller/knowledge/KnowledgeController.kt
  - src/main/kotlin/riven/core/models/response/entity/type/EntityTypeWithSemanticsResponse.kt
  - src/main/kotlin/riven/core/models/response/entity/type/SemanticMetadataBundle.kt
  - src/main/kotlin/riven/core/controller/entity/EntityTypeController.kt
  - src/main/kotlin/riven/core/service/entity/type/EntityTypeService.kt
  - src/test/kotlin/riven/core/service/entity/EntityTypeSemanticMetadataServiceTest.kt
autonomous: true

must_haves:
  truths:
    - "User can GET/PUT semantic metadata for entity types via /api/v1/knowledge/workspace/{workspaceId}/entity-type/{entityTypeId}"
    - "User can GET/PUT attribute metadata individually and in bulk via dedicated endpoints"
    - "User can GET/PUT relationship metadata via dedicated endpoints"
    - "?include=semantics on entity type list endpoint returns metadata bundle alongside entity types"
    - "All KnowledgeController endpoints enforce workspace security via service-layer @PreAuthorize"
    - "Invalid classification values return 400 (Jackson enum deserialization)"
    - "All endpoints have Swagger @Operation and @ApiResponses annotations"
    - "KnowledgeController is tagged with @Tag(name = 'knowledge') for OpenAPI grouping"
  artifacts:
    - path: "src/main/kotlin/riven/core/controller/knowledge/KnowledgeController.kt"
      provides: "REST endpoints for semantic metadata CRUD"
      exports: ["KnowledgeController"]
      min_lines: 80
    - path: "src/main/kotlin/riven/core/models/response/entity/type/EntityTypeWithSemanticsResponse.kt"
      provides: "Wrapper response for entity type + optional semantics"
      exports: ["EntityTypeWithSemanticsResponse"]
    - path: "src/main/kotlin/riven/core/models/response/entity/type/SemanticMetadataBundle.kt"
      provides: "Bundle of entity type + attribute + relationship metadata"
      exports: ["SemanticMetadataBundle"]
  key_links:
    - from: "KnowledgeController"
      to: "EntityTypeSemanticMetadataService"
      via: "constructor injection"
      pattern: "private val semanticMetadataService: EntityTypeSemanticMetadataService"
    - from: "EntityTypeController.getEntityTypesForWorkspace"
      to: "EntityTypeSemanticMetadataService.getMetadataForEntityTypes"
      via: "conditional call when include=semantics"
      pattern: "include.*semantics"
    - from: "KnowledgeController"
      to: "/api/v1/knowledge"
      via: "@RequestMapping"
      pattern: "RequestMapping.*api/v1/knowledge"
---

<objective>
Create the KnowledgeController with semantic metadata CRUD endpoints and add the ?include=semantics query parameter to the existing EntityTypeController.

Purpose: This is the API layer that makes semantic metadata user-accessible. It exposes dedicated endpoints for reading and writing metadata on entity types, attributes, and relationships, plus a bulk endpoint for attribute metadata (needed for Phase 2 template installation). It also adds the opt-in semantics inclusion to existing entity type list/detail endpoints so clients can fetch entity types with their metadata in one request.

Output: KnowledgeController, two response model classes, modified EntityTypeController with ?include=semantics support.
</objective>

<execution_context>
@/home/jared/.claude/get-shit-done/workflows/execute-plan.md
@/home/jared/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-semantic-metadata-foundation/01-CONTEXT.md
@.planning/phases/01-semantic-metadata-foundation/01-RESEARCH.md
@.planning/phases/01-semantic-metadata-foundation/01-01-SUMMARY.md
@.planning/phases/01-semantic-metadata-foundation/01-02-SUMMARY.md
@src/main/kotlin/riven/core/controller/entity/EntityTypeController.kt
@src/main/kotlin/riven/core/service/entity/EntityTypeSemanticMetadataService.kt
@src/main/kotlin/riven/core/service/entity/type/EntityTypeService.kt
@src/main/kotlin/riven/core/models/entity/EntityType.kt
@src/main/kotlin/riven/core/models/entity/EntityTypeSemanticMetadata.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Response models and KnowledgeController</name>
  <files>
    src/main/kotlin/riven/core/models/response/entity/type/SemanticMetadataBundle.kt
    src/main/kotlin/riven/core/models/response/entity/type/EntityTypeWithSemanticsResponse.kt
    src/main/kotlin/riven/core/controller/knowledge/KnowledgeController.kt
  </files>
  <action>
1. Create `SemanticMetadataBundle` data class in `riven.core.models.response.entity.type`:
   ```kotlin
   data class SemanticMetadataBundle(
       val entityType: EntityTypeSemanticMetadata?,
       val attributes: Map<UUID, EntityTypeSemanticMetadata>,
       val relationships: Map<UUID, EntityTypeSemanticMetadata>,
   )
   ```
   This bundles all metadata for a single entity type into one object. Used by `?include=semantics` and by the GET-all-metadata endpoint. Keys in the maps are the target_id (attribute UUID or relationship UUID).

2. Create `EntityTypeWithSemanticsResponse` data class in `riven.core.models.response.entity.type`:
   ```kotlin
   data class EntityTypeWithSemanticsResponse(
       val entityType: EntityType,
       val semantics: SemanticMetadataBundle? = null,
   )
   ```
   Used as the response when `?include=semantics` is specified on entity type endpoints.

3. Create `KnowledgeController` in `riven.core.controller.knowledge` (new package):
   - `@RestController`, `@RequestMapping("/api/v1/knowledge")`, `@Tag(name = "knowledge")`
   - Constructor inject `EntityTypeSemanticMetadataService`
   - Controller is THIN -- delegates all logic to service, returns ResponseEntity

   Endpoints (all with `@Operation` + `@ApiResponses`):

   **Entity type metadata:**
   ```
   GET  /workspace/{workspaceId}/entity-type/{entityTypeId}
   ```
   - Summary: "Get semantic metadata for an entity type"
   - Calls `semanticMetadataService.getForEntityType(workspaceId, entityTypeId)`
   - Returns `ResponseEntity.ok(metadata)`

   ```
   PUT  /workspace/{workspaceId}/entity-type/{entityTypeId}
   ```
   - Summary: "Set semantic metadata for an entity type (full replacement)"
   - `@RequestBody request: SaveSemanticMetadataRequest`
   - Calls `semanticMetadataService.upsertMetadata(workspaceId, entityTypeId, ENTITY_TYPE, entityTypeId, request)` -- for entity type, targetId == entityTypeId
   - Returns `ResponseEntity.ok(metadata)`

   **Attribute metadata:**
   ```
   GET  /workspace/{workspaceId}/entity-type/{entityTypeId}/attributes
   ```
   - Summary: "Get semantic metadata for all attributes of an entity type"
   - Calls `semanticMetadataService.getAttributeMetadata(workspaceId, entityTypeId)`
   - Returns `ResponseEntity.ok(metadataList)`

   ```
   PUT  /workspace/{workspaceId}/entity-type/{entityTypeId}/attribute/{attributeId}
   ```
   - Summary: "Set semantic metadata for a single attribute (full replacement)"
   - `@RequestBody request: SaveSemanticMetadataRequest`
   - Calls `semanticMetadataService.upsertMetadata(workspaceId, entityTypeId, ATTRIBUTE, attributeId, request)`
   - Returns `ResponseEntity.ok(metadata)`

   ```
   PUT  /workspace/{workspaceId}/entity-type/{entityTypeId}/attributes/bulk
   ```
   - Summary: "Set semantic metadata for multiple attributes (full replacement per attribute)"
   - `@RequestBody requests: List<BulkSaveSemanticMetadataRequest>`
   - Calls `semanticMetadataService.bulkUpsertAttributeMetadata(workspaceId, entityTypeId, requests)`
   - Returns `ResponseEntity.ok(metadataList)`

   **Relationship metadata:**
   ```
   GET  /workspace/{workspaceId}/entity-type/{entityTypeId}/relationships
   ```
   - Summary: "Get semantic metadata for all relationships of an entity type"
   - Calls `semanticMetadataService.getRelationshipMetadata(workspaceId, entityTypeId)`
   - Returns `ResponseEntity.ok(metadataList)`

   ```
   PUT  /workspace/{workspaceId}/entity-type/{entityTypeId}/relationship/{relationshipId}
   ```
   - Summary: "Set semantic metadata for a single relationship (full replacement)"
   - `@RequestBody request: SaveSemanticMetadataRequest`
   - Calls `semanticMetadataService.upsertMetadata(workspaceId, entityTypeId, RELATIONSHIP, relationshipId, request)`
   - Returns `ResponseEntity.ok(metadata)`

   **Full bundle:**
   ```
   GET  /workspace/{workspaceId}/entity-type/{entityTypeId}/all
   ```
   - Summary: "Get all semantic metadata for an entity type (entity type + attributes + relationships)"
   - Calls `semanticMetadataService.getAllMetadataForEntityType(workspaceId, entityTypeId)`
   - Group results into `SemanticMetadataBundle`: partition by targetType, build maps keyed by targetId
   - Returns `ResponseEntity.ok(bundle)`

Note: Controllers do NOT add @PreAuthorize -- per CLAUDE.md, security enforcement is on SERVICE methods. Controller just delegates and returns.
Note: Do NOT add KDoc to controllers per CLAUDE.md -- the @Operation annotation serves that purpose.
  </action>
  <verify>Run `./gradlew build` -- project must compile. Verify all endpoints have @Operation and @ApiResponses annotations. Verify no @PreAuthorize on controller methods.</verify>
  <done>KnowledgeController exists with 8 endpoints covering entity type, attribute, relationship, and bundle metadata operations. Two response model classes exist. All endpoints delegate to service layer.</done>
</task>

<task type="auto">
  <name>Task 2: ?include=semantics on EntityTypeController</name>
  <files>
    src/main/kotlin/riven/core/controller/entity/EntityTypeController.kt
    src/main/kotlin/riven/core/service/entity/type/EntityTypeService.kt
  </files>
  <action>
1. Modify `EntityTypeController`:

   - Add `EntityTypeSemanticMetadataService` to constructor parameters

   - Modify `getEntityTypesForWorkspace`:
     - Add parameter: `@RequestParam(required = false, defaultValue = "") include: List<String>`
     - After getting entityTypes, check if `"semantics" in include`
     - If yes: call `semanticMetadataService.getMetadataForEntityTypes(entityTypes.map { it.id })` to get all metadata in one query. Group into bundles per entity type. Return `ResponseEntity.ok(entityTypes.map { entityType -> EntityTypeWithSemanticsResponse(entityType, bundleMap[entityType.id]) })`
     - If no: return existing behavior unchanged -- `ResponseEntity.ok(entityTypes)` (this preserves backward compatibility; clients that don't pass `?include=semantics` see no change)
     - NOTE: The return type changes from `ResponseEntity<List<EntityType>>` to `ResponseEntity<*>` (or `ResponseEntity<Any>`) since the response shape differs based on the include parameter. Alternatively, always return `List<EntityTypeWithSemanticsResponse>` where `semantics` is null when not requested. Prefer the latter for consistent typing.

   - Modify `getEntityTypeByKeyForWorkspace`:
     - Add parameter: `@RequestParam(required = false, defaultValue = "") include: List<String>`
     - Same pattern: if semantics requested, fetch and attach bundle
     - Return `EntityTypeWithSemanticsResponse` consistently

   Implementation note for building the bundle from a flat metadata list:
   ```kotlin
   private fun buildBundle(
       entityTypeId: UUID,
       allMetadata: List<EntityTypeSemanticMetadata>
   ): SemanticMetadataBundle {
       val grouped = allMetadata.filter { it.entityTypeId == entityTypeId }
       return SemanticMetadataBundle(
           entityType = grouped.firstOrNull { it.targetType == SemanticMetadataTargetType.ENTITY_TYPE },
           attributes = grouped.filter { it.targetType == SemanticMetadataTargetType.ATTRIBUTE }
               .associateBy { it.targetId },
           relationships = grouped.filter { it.targetType == SemanticMetadataTargetType.RELATIONSHIP }
               .associateBy { it.targetId },
       )
   }
   ```
   This helper can be a private method on the controller or extracted to a companion object. Keep it in the controller since it is simple response mapping logic.

2. Update @Operation descriptions on modified endpoints to mention the `include` parameter.

IMPORTANT: When modifying EntityTypeController, ONLY change what is needed. Do not refactor existing endpoints. Do not change existing return types or behavior when `include` is empty. The `?include=semantics` feature is opt-in.
  </action>
  <verify>Run `./gradlew build` -- project must compile. Run `./gradlew test` -- all tests pass. Verify that existing EntityTypeController tests (if any) still pass without modification (they don't send ?include=semantics so behavior is unchanged).</verify>
  <done>EntityTypeController accepts ?include=semantics and returns EntityTypeWithSemanticsResponse with SemanticMetadataBundle attached. Without ?include, response is backward-compatible (semantics field is null). All existing tests pass.</done>
</task>

<task type="auto">
  <name>Task 3: End-to-end compilation and test verification</name>
  <files>
    src/test/kotlin/riven/core/service/entity/EntityTypeSemanticMetadataServiceTest.kt
  </files>
  <action>
1. Run the full test suite: `./gradlew test`
   - Fix any test compilation failures caused by the new constructor dependency on `EntityTypeSemanticMetadataService` in `EntityTypeController`, `EntityTypeService`, `EntityTypeAttributeService`, or `EntityTypeRelationshipService`
   - Any test class that creates or mocks these services needs a `@MockitoBean` for `EntityTypeSemanticMetadataService`
   - Check these test files specifically:
     - `EntityTypeRelationshipServiceTest.kt` (already mocks EntityTypeService deps)
     - Any test that uses `EntityTypeService` or `EntityTypeAttributeService`

2. Add additional test cases to `EntityTypeSemanticMetadataServiceTest` if any edge cases were discovered during implementation:
   - Verify that `getForEntityType` with a non-existent entityTypeId throws NotFoundException
   - Verify that `bulkUpsertAttributeMetadata` handles empty list gracefully
   - Verify the bundle assembly logic groups metadata correctly by target type

3. Run `./gradlew build` to confirm full compilation including all test code.

4. Verify the OpenAPI spec is valid by checking that the application context loads: `./gradlew test` with no Spring context failures.
  </action>
  <verify>Run `./gradlew test` -- ALL tests pass (zero failures). Run `./gradlew build` -- clean build with no errors.</verify>
  <done>Full test suite passes. All new constructor dependencies are properly mocked in existing tests. Application compiles cleanly. The entire semantic metadata CRUD API is operational.</done>
</task>

</tasks>

<verification>
1. `./gradlew test` passes with zero failures
2. `./gradlew build` succeeds
3. KnowledgeController has 8 endpoints with Swagger annotations
4. EntityTypeController accepts `?include=semantics` on list and detail endpoints
5. Without `?include=semantics`, entity type endpoints return unchanged response shape (backward compatible)
6. All endpoints delegate to service layer (no business logic in controllers)
7. Invalid classification values in request body return 400
</verification>

<success_criteria>
- Full build and test suite pass: `./gradlew build` and `./gradlew test`
- KnowledgeController reachable at `/api/v1/knowledge/workspace/{workspaceId}/entity-type/{entityTypeId}`
- PUT endpoints accept SaveSemanticMetadataRequest with nullable classification
- Bulk endpoint at `/attributes/bulk` accepts list of BulkSaveSemanticMetadataRequest
- `?include=semantics` on entity type list endpoint attaches SemanticMetadataBundle
- No regressions in existing entity type tests
- Phase 1 success criteria fully met:
  1. User can set/get semantic definition on entity type
  2. User can assign classification + description to attribute with validation
  3. User can set semantic context on relationship
  4. All endpoints enforce workspace security
  5. Metadata in separate table, existing CRUD unaffected
</success_criteria>

<output>
After completion, create `.planning/phases/01-semantic-metadata-foundation/01-03-SUMMARY.md`
</output>
