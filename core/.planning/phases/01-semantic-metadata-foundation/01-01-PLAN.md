---
phase: 01-semantic-metadata-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - db/schema/00_extensions/extensions.sql
  - db/schema/01_tables/entity_semantic_metadata.sql
  - src/main/kotlin/riven/core/enums/entity/SemanticMetadataTargetType.kt
  - src/main/kotlin/riven/core/enums/entity/SemanticAttributeClassification.kt
  - src/main/kotlin/riven/core/entity/entity/EntityTypeSemanticMetadataEntity.kt
  - src/main/kotlin/riven/core/models/entity/EntityTypeSemanticMetadata.kt
  - src/main/kotlin/riven/core/repository/entity/EntityTypeSemanticMetadataRepository.kt
  - src/test/kotlin/riven/core/service/entity/query/EntityQueryIntegrationTestBase.kt
autonomous: true

must_haves:
  truths:
    - "Semantic metadata is stored in a separate table from entity_types (INFRA-06)"
    - "pgvector extension is registered in PostgreSQL (INFRA-01)"
    - "Integration tests use pgvector-enabled PostgreSQL image (INFRA-04)"
    - "Classification enum has exactly 6 values: identifier, categorical, quantitative, temporal, freetext, relational_reference"
    - "JPA entity extends AuditableSoftDeletableEntity and supports soft-delete filtering"
  artifacts:
    - path: "db/schema/01_tables/entity_semantic_metadata.sql"
      provides: "entity_type_semantic_metadata table DDL with target_type discriminator, indexes, unique constraint"
      contains: "CREATE TABLE IF NOT EXISTS public.entity_type_semantic_metadata"
    - path: "db/schema/00_extensions/extensions.sql"
      provides: "pgvector extension registration"
      contains: "vector"
    - path: "src/main/kotlin/riven/core/enums/entity/SemanticMetadataTargetType.kt"
      provides: "ENTITY_TYPE, ATTRIBUTE, RELATIONSHIP discriminator enum"
      exports: ["SemanticMetadataTargetType"]
    - path: "src/main/kotlin/riven/core/enums/entity/SemanticAttributeClassification.kt"
      provides: "6-value classification enum with lowercase constants"
      exports: ["SemanticAttributeClassification"]
    - path: "src/main/kotlin/riven/core/entity/entity/EntityTypeSemanticMetadataEntity.kt"
      provides: "JPA entity with toModel() mapping"
      exports: ["EntityTypeSemanticMetadataEntity"]
    - path: "src/main/kotlin/riven/core/models/entity/EntityTypeSemanticMetadata.kt"
      provides: "Domain model data class"
      exports: ["EntityTypeSemanticMetadata"]
    - path: "src/main/kotlin/riven/core/repository/entity/EntityTypeSemanticMetadataRepository.kt"
      provides: "JPA repository with discriminator-aware queries"
      exports: ["EntityTypeSemanticMetadataRepository"]
  key_links:
    - from: "EntityTypeSemanticMetadataEntity"
      to: "AuditableSoftDeletableEntity"
      via: "class inheritance"
      pattern: "AuditableSoftDeletableEntity"
    - from: "EntityTypeSemanticMetadataEntity"
      to: "EntityTypeSemanticMetadata"
      via: "toModel() method"
      pattern: "fun toModel\\(\\)"
    - from: "EntityTypeSemanticMetadataRepository"
      to: "EntityTypeSemanticMetadataEntity"
      via: "JpaRepository type parameter"
      pattern: "JpaRepository<EntityTypeSemanticMetadataEntity"
---

<objective>
Create the database schema and data layer for semantic metadata storage.

Purpose: Establishes the foundation that all subsequent plans build on -- the table, JPA entity, domain model, enums, and repository that represent semantic metadata for entity types, attributes, and relationships. Also registers the pgvector extension (INFRA-01) and switches integration tests to the pgvector-enabled Docker image (INFRA-04).

Output: SQL schema file, two enum classes, one JPA entity, one domain model, one repository interface, updated extensions.sql, updated Testcontainers config.
</objective>

<execution_context>
@/home/jared/.claude/get-shit-done/workflows/execute-plan.md
@/home/jared/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-semantic-metadata-foundation/01-CONTEXT.md
@.planning/phases/01-semantic-metadata-foundation/01-RESEARCH.md
@src/main/kotlin/riven/core/entity/entity/EntityTypeEntity.kt
@src/main/kotlin/riven/core/entity/util/AuditableSoftDeletableEntity.kt
@src/main/kotlin/riven/core/models/entity/EntityType.kt
@db/schema/00_extensions/extensions.sql
@db/schema/01_tables/entities.sql
@src/test/kotlin/riven/core/service/entity/query/EntityQueryIntegrationTestBase.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Database schema and pgvector extension</name>
  <files>
    db/schema/00_extensions/extensions.sql
    db/schema/01_tables/entity_semantic_metadata.sql
  </files>
  <action>
1. Append `CREATE EXTENSION IF NOT EXISTS vector;` to `db/schema/00_extensions/extensions.sql` (after the existing uuid-ossp line). This satisfies INFRA-01.

2. Create `db/schema/01_tables/entity_semantic_metadata.sql` with the following table:

```sql
CREATE TABLE IF NOT EXISTS public.entity_type_semantic_metadata
(
    "id"              UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    "workspace_id"    UUID    NOT NULL REFERENCES workspaces (id) ON DELETE CASCADE,
    "entity_type_id"  UUID    NOT NULL REFERENCES entity_types (id) ON DELETE CASCADE,
    "target_type"     TEXT    NOT NULL CHECK (target_type IN ('ENTITY_TYPE', 'ATTRIBUTE', 'RELATIONSHIP')),
    "target_id"       UUID    NOT NULL,
    "definition"      TEXT,
    "classification"  TEXT    CHECK (classification IS NULL OR classification IN (
                          'identifier', 'categorical', 'quantitative',
                          'temporal', 'freetext', 'relational_reference'
                      )),
    "tags"            JSONB   NOT NULL DEFAULT '[]'::jsonb,
    "deleted"         BOOLEAN NOT NULL DEFAULT FALSE,
    "deleted_at"      TIMESTAMP WITH TIME ZONE DEFAULT NULL,
    "created_at"      TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    "updated_at"      TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    "created_by"      UUID,
    "updated_by"      UUID,

    UNIQUE (entity_type_id, target_type, target_id)
);
```

Add indexes after the table:
- `idx_entity_semantic_metadata_workspace` on `(workspace_id)`
- `idx_entity_semantic_metadata_entity_type` on `(entity_type_id) WHERE deleted = false`
- `idx_entity_semantic_metadata_target` on `(target_type, target_id) WHERE deleted = false`

Note: The `classification` CHECK constraint allows NULL (per locked decision: classification is optional/nullable) but rejects any non-null value outside the 6 predefined values.
  </action>
  <verify>SQL files parse correctly: `cat db/schema/00_extensions/extensions.sql` shows both uuid-ossp and vector extensions. `cat db/schema/01_tables/entity_semantic_metadata.sql` shows complete DDL with all constraints and indexes.</verify>
  <done>extensions.sql registers pgvector, entity_semantic_metadata.sql defines the table with discriminator, audit columns, soft-delete columns, and three indexes.</done>
</task>

<task type="auto">
  <name>Task 2: Enums, JPA entity, domain model, and repository</name>
  <files>
    src/main/kotlin/riven/core/enums/entity/SemanticMetadataTargetType.kt
    src/main/kotlin/riven/core/enums/entity/SemanticAttributeClassification.kt
    src/main/kotlin/riven/core/entity/entity/EntityTypeSemanticMetadataEntity.kt
    src/main/kotlin/riven/core/models/entity/EntityTypeSemanticMetadata.kt
    src/main/kotlin/riven/core/repository/entity/EntityTypeSemanticMetadataRepository.kt
  </files>
  <action>
1. Create `SemanticMetadataTargetType` enum in `riven.core.enums.entity`:
   - Three values: `ENTITY_TYPE`, `ATTRIBUTE`, `RELATIONSHIP`
   - Standard Kotlin enum (uppercase names match DB CHECK constraint values)

2. Create `SemanticAttributeClassification` enum in `riven.core.enums.entity`:
   - Six values: `identifier`, `categorical`, `quantitative`, `temporal`, `freetext`, `relational_reference`
   - CRITICAL: Use **lowercase** constant names exactly matching the API wire format. The project's ObjectMapperConfig does NOT enable ACCEPT_CASE_INSENSITIVE_ENUMS, so Jackson requires exact match. This means `SemanticAttributeClassification.identifier` not `SemanticAttributeClassification.IDENTIFIER`.

3. Create `EntityTypeSemanticMetadataEntity` JPA data class in `riven.core.entity.entity`:
   - Extends `AuditableSoftDeletableEntity()` (same pattern as `EntityTypeEntity`)
   - `@Entity` + `@Table(name = "entity_type_semantic_metadata")` with `uniqueConstraints` on `[entity_type_id, target_type, target_id]`
   - Fields: `id: UUID?` (GeneratedValue UUID), `workspaceId: UUID`, `entityTypeId: UUID`, `targetType: SemanticMetadataTargetType` (@Enumerated STRING), `targetId: UUID`, `definition: String?` (nullable var), `classification: SemanticAttributeClassification?` (nullable var, @Enumerated STRING), `tags: List<String>` (var, default emptyList(), `@Type(JsonBinaryType::class)` + `columnDefinition = "jsonb"`)
   - Include `fun toModel(): EntityTypeSemanticMetadata` that maps all fields including audit fields from superclass (createdAt, updatedAt, createdBy, updatedBy)
   - Use `@Column(name = "snake_case")` on every field per codebase convention

4. Create `EntityTypeSemanticMetadata` domain model data class in `riven.core.models.entity`:
   - All fields from the entity mirrored as `val`: `id: UUID`, `workspaceId: UUID`, `entityTypeId: UUID`, `targetType: SemanticMetadataTargetType`, `targetId: UUID`, `definition: String?`, `classification: SemanticAttributeClassification?`, `tags: List<String>`, `createdAt: ZonedDateTime?`, `updatedAt: ZonedDateTime?`, `createdBy: UUID?`, `updatedBy: UUID?`

5. Create `EntityTypeSemanticMetadataRepository` interface in `riven.core.repository.entity`:
   - Extends `JpaRepository<EntityTypeSemanticMetadataEntity, UUID>`
   - Derived query methods:
     - `findByEntityTypeIdAndTargetTypeAndTargetId(entityTypeId: UUID, targetType: SemanticMetadataTargetType, targetId: UUID): Optional<EntityTypeSemanticMetadataEntity>`
     - `findByEntityTypeIdIn(entityTypeIds: List<UUID>): List<EntityTypeSemanticMetadataEntity>`
     - `findByEntityTypeIdAndTargetType(entityTypeId: UUID, targetType: SemanticMetadataTargetType): List<EntityTypeSemanticMetadataEntity>`
     - `findByEntityTypeId(entityTypeId: UUID): List<EntityTypeSemanticMetadataEntity>`
   - Custom JPQL methods:
     - `@Modifying @Query("DELETE FROM EntityTypeSemanticMetadataEntity e WHERE e.entityTypeId = :entityTypeId AND e.targetType = :targetType AND e.targetId = :targetId") fun hardDeleteByTarget(entityTypeId: UUID, targetType: SemanticMetadataTargetType, targetId: UUID)` -- for attribute/relationship removal (hard-delete per locked decision)
     - `@Modifying @Query("UPDATE EntityTypeSemanticMetadataEntity e SET e.deleted = true, e.deletedAt = CURRENT_TIMESTAMP WHERE e.entityTypeId = :entityTypeId AND e.deleted = false") fun softDeleteByEntityTypeId(entityTypeId: UUID): Int` -- for entity type soft-delete cascade

6. Switch Testcontainers image in `EntityQueryIntegrationTestBase`:
   - Change `DockerImageName.parse("postgres:16-alpine")` to `DockerImageName.parse("pgvector/pgvector:pg16").asCompatibleSubstituteFor("postgres")`
   - This satisfies INFRA-04
  </action>
  <verify>Run `./gradlew build` -- project must compile with no errors. Verify all new files are in correct packages by checking imports resolve.</verify>
  <done>Two enums created with correct casing, JPA entity extends AuditableSoftDeletableEntity with toModel(), domain model mirrors entity fields, repository has all required query methods including hard-delete and soft-delete-cascade, integration test base uses pgvector image.</done>
</task>

</tasks>

<verification>
1. `./gradlew build` compiles successfully
2. SQL file exists at `db/schema/01_tables/entity_semantic_metadata.sql` with correct DDL
3. `extensions.sql` contains both `uuid-ossp` and `vector` extensions
4. `SemanticAttributeClassification` has exactly 6 lowercase values
5. `EntityTypeSemanticMetadataEntity.toModel()` returns `EntityTypeSemanticMetadata`
6. Repository has `hardDeleteByTarget` and `softDeleteByEntityTypeId` methods
7. Testcontainers config references `pgvector/pgvector:pg16`
</verification>

<success_criteria>
- Project compiles with `./gradlew build` (no errors)
- All 7 new/modified files exist in correct locations
- JPA entity follows exact same patterns as EntityTypeEntity (extends AuditableSoftDeletableEntity, has toModel(), uses @Type(JsonBinaryType) for tags)
- Classification enum uses lowercase constants matching wire format
- Repository provides all queries needed by the service layer (Plan 02)
</success_criteria>

<output>
After completion, create `.planning/phases/01-semantic-metadata-foundation/01-01-SUMMARY.md`
</output>
