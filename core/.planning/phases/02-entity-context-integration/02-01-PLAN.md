---
phase: 02-entity-context-integration
plan: 01
type: execute
---

<objective>
Build entity context integration enabling expression evaluation against dynamic entity data with field traversal and relationship resolution.

Purpose: Connect Phase 1's expression system with the existing entity system, allowing workflows to evaluate conditions against live entity data (e.g., `entity.status = 'active' AND client.address.city = 'London'`).

Output: EntityContextService with entity-to-context conversion, relationship traversal, and comprehensive test coverage proving expressions can evaluate against entity data.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-expression-system-foundation/01-01-SUMMARY.md

**Phase 1 Foundation:**
- ExpressionEvaluatorService evaluates expressions against `Map<String, Any?>` context
- Supports property access for nested fields (`client.address.city`)
- Type-safe evaluation with clear error messages
- 100% test coverage, 37 passing tests

**Entity System Architecture:**
- Entity has `payload: Map<UUID, EntityAttribute>` - attributes keyed by UUID
- EntityAttribute wraps EntityAttributePayload (sealed interface):
  - EntityAttributePrimitivePayload - primitive values (string, number, boolean, date, etc.)
  - EntityAttributeRelationPayload - relationships to other entities (List<EntityLink>)
- EntityType has `schema: Schema<UUID>` - defines attribute structure with labels
- Schema<UUID>.label provides human-readable field names for UUID keys
- Existing EntityService handles CRUD operations

**Tech Stack Available:**
- Spring Boot 3.5.3 + Kotlin 2.1.21
- Spring Data JPA with EntityRepository, EntityTypeRepository
- ExpressionEvaluatorService from Phase 1
- Comprehensive entity domain models

**Established Patterns:**
- Service layer with constructor injection
- Repository layer for data access
- Rich domain models (DTOs) separate from JPA entities
- Type-safe sealed interfaces for polymorphism
- Comprehensive JUnit 5 + Mockito test coverage

**Critical Files:**
@src/main/kotlin/riven/core/service/workflow/ExpressionEvaluatorService.kt
@src/main/kotlin/riven/core/models/entity/Entity.kt
@src/main/kotlin/riven/core/models/entity/EntityType.kt
@src/main/kotlin/riven/core/models/entity/payload/EntityAttributePayload.kt
@src/main/kotlin/riven/core/models/common/validation/Schema.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create EntityContextService with basic entity-to-context conversion</name>
  <files>src/main/kotlin/riven/core/service/workflow/EntityContextService.kt</files>
  <action>
Create EntityContextService as Spring @Service with constructor-injected EntityRepository and EntityTypeRepository.

Implement core method:
- `buildContext(entityId: UUID, workspaceId: UUID): Map<String, Any?>` - Fetches entity and converts to expression-compatible context

Conversion logic:
1. Fetch entity by ID using EntityRepository.findById()
2. Fetch entity type using EntityTypeRepository.findById(entity.typeId)
3. Iterate entity.payload (Map<UUID, EntityAttribute>)
4. For each UUID key, lookup schema field label from entityType.schema.properties[uuid].label
5. Extract value from EntityAttributePayload:
   - EntityAttributePrimitivePayload: Extract value.value (JsonValue) as primitive (String, Number, Boolean, null)
   - EntityAttributeRelationPayload: Skip for now (Task 2 handles relationships)
6. Build Map<String, Any?> with string keys (field labels) and primitive values
7. Return context map

Error handling:
- Throw IllegalArgumentException if entity not found
- Throw IllegalArgumentException if entity type not found
- Throw IllegalArgumentException if schema field label missing for UUID key
- Log warnings for fields without labels (defensive)

DO NOT implement relationship traversal yet - return null for relationship fields. Task 2 adds relationship resolution.
DO NOT use type assertions (as) - use type guards (is) with smart casts.
DO NOT inline complex logic - extract helper methods for clarity.
  </action>
  <verify>
./gradlew compileKotlin succeeds without errors
New EntityContextService.kt file exists with buildContext method
  </verify>
  <done>
EntityContextService created with:
- buildContext method fetching entity and building Map<String, Any?> context
- UUID-to-label conversion using entity type schema
- Primitive value extraction from EntityAttributePrimitivePayload
- Clear error messages for missing entities/types/labels
- Helper methods for context building
  </done>
</task>

<task type="auto">
  <name>Task 2: Add relationship traversal support for nested entity access</name>
  <files>src/main/kotlin/riven/core/service/workflow/EntityContextService.kt</files>
  <action>
Enhance EntityContextService to support relationship traversal for expressions like `client.address.city`.

Add new method:
- `buildContextWithRelationships(entityId: UUID, workspaceId: UUID, maxDepth: Int = 3): Map<String, Any?>` - Builds context with recursive relationship resolution

Relationship handling:
1. When processing EntityAttributeRelationPayload in buildContext:
   - Extract related entity IDs from payload.relations (List<EntityLink>)
   - For each related entity, recursively call buildContext to get nested map
   - If relationship is ONE-TO-ONE or MANY-TO-ONE: Store single nested map
   - If relationship is ONE-TO-MANY or MANY-TO-MANY: Store List<Map<String, Any?>>
2. Track recursion depth to prevent cycles (maxDepth parameter, default 3)
3. At maxDepth, return entity ID as string instead of recursing
4. Add depth parameter to buildContext (default 0), increment on recursive calls

Cardinality detection:
- Lookup relationship definition in entityType.relationships by field UUID
- Use relationship.cardinality to determine if result is single object or list
- If relationship definition not found, default to MANY (list)

Update buildContext to call buildContextWithRelationships internally with depth tracking.

Error handling:
- If related entity not found, set field to null (relationships may be broken)
- If depth exceeded, set field to entity ID string with prefix "entity:" for debugging
- Log warnings for missing related entities (not errors - relationships can be stale)

DO NOT fetch all entities eagerly - fetch on-demand as relationships are traversed.
DO NOT allow infinite recursion - enforce maxDepth limit strictly.
  </action>
  <verify>
./gradlew compileKotlin succeeds without errors
EntityContextService has buildContextWithRelationships method
Recursive relationship resolution implemented with depth limiting
  </verify>
  <done>
EntityContextService supports:
- Recursive relationship traversal up to maxDepth (default 3)
- Cardinality-aware relationship handling (single vs list)
- Cycle prevention via depth limiting
- Graceful handling of missing/stale relationships
- Clear depth exhaustion indicator ("entity:{id}")
  </done>
</task>

<task type="auto">
  <name>Task 3: Add comprehensive integration tests validating expression evaluation with entity context</name>
  <files>src/test/kotlin/riven/core/service/workflow/EntityContextServiceTest.kt</files>
  <action>
Create EntityContextServiceTest with comprehensive test coverage using JUnit 5, Mockito, and H2 in-memory database.

Test structure:
- Use @DataJpaTest for repository integration
- Mock EntityRepository and EntityTypeRepository with test data
- Use real ExpressionEvaluatorService (no mocking - test real integration)
- Create helper method `createTestEntity()` for test entity setup
- Create helper method `createTestEntityType()` for test schema setup

Test cases (minimum 12 tests):

**Basic context building:**
1. `testBuildContext_SimpleEntity_ReturnsCorrectMap()` - Single entity with primitive fields
2. `testBuildContext_EntityNotFound_ThrowsException()` - Missing entity ID
3. `testBuildContext_MissingEntityType_ThrowsException()` - Orphaned entity
4. `testBuildContext_MissingSchemaLabel_ThrowsException()` - Schema integrity violation
5. `testBuildContext_NullValues_HandlesGracefully()` - Null attribute values

**Expression evaluation integration:**
6. `testEvaluateExpression_SimpleComparison_ReturnsTrue()` - Expression `status = 'active'` with entity context
7. `testEvaluateExpression_LogicalAnd_ReturnsCorrectResult()` - Expression `status = 'active' AND count > 10`
8. `testEvaluateExpression_PropertyAccess_ResolvesField()` - Expression `entity.status` returns field value

**Relationship traversal:**
9. `testBuildContextWithRelationships_OneToOne_ReturnsNestedMap()` - Single related entity as nested map
10. `testBuildContextWithRelationships_OneToMany_ReturnsList()` - Multiple related entities as list
11. `testBuildContextWithRelationships_MaxDepthExceeded_ReturnsEntityId()` - Depth limit enforced
12. `testBuildContextWithRelationships_MissingRelatedEntity_SetsNull()` - Stale relationship handling

**Expression evaluation with relationships:**
13. `testEvaluateExpression_NestedProperty_ReturnsCorrectValue()` - Expression `client.address.city = 'London'`
14. `testEvaluateExpression_DeepNesting_HandlesMultipleLevels()` - Expression `project.client.address.city`

Use assertThat for assertions (AssertJ style).
Use descriptive test data (realistic entity structures, meaningful field names).
DO NOT use @SpringBootTest (slow) - use @DataJpaTest for focused repository testing.
DO NOT test ExpressionEvaluatorService internals - it has 100% coverage from Phase 1.
  </action>
  <verify>
./gradlew test succeeds with all EntityContextServiceTest tests passing
./gradlew test shows 12+ new tests added with 100% pass rate
No compilation errors or warnings
  </verify>
  <done>
EntityContextServiceTest created with:
- 12+ comprehensive test cases covering basic, relationship, and integration scenarios
- Mock repositories with realistic test data
- Real ExpressionEvaluatorService integration tests
- All tests passing (100% pass rate)
- Clear test names and assertions
- Coverage for error cases and edge conditions
  </done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `./gradlew compileKotlin` succeeds without errors
- [ ] `./gradlew test` succeeds with all new tests passing
- [ ] EntityContextService exists with buildContext and buildContextWithRelationships methods
- [ ] EntityContextServiceTest has 12+ passing tests
- [ ] Expression evaluation works end-to-end with entity data (test proves it)
- [ ] No TypeScript errors introduced (backend-only phase)
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- EntityContextService successfully converts entity data to expression-compatible context
- Relationship traversal supports nested property access up to maxDepth
- Comprehensive test coverage proves integration works end-to-end
- No errors or warnings introduced
- Expression evaluation against entity data demonstrated in tests
  </success_criteria>

<output>
After completion, create `.planning/phases/02-entity-context-integration/02-01-SUMMARY.md`:

---
phase: 02-entity-context-integration
plan: 01
subsystem: workflow-engine
type: standard
requires: [01-expression-system-foundation]
provides: [entity-context-resolution, relationship-traversal]
affects: [03-temporal-workflow-engine]
tags: [workflow, entity, integration, expression-evaluation]

tech-stack:
  added: [EntityContextService]
  patterns: [entity-to-context-conversion, recursive-relationship-traversal, depth-limited-recursion]

patterns-established:
  - Entity payload (UUID-keyed) converted to expression context (String-keyed) using schema labels
  - Relationship traversal with cardinality awareness (single vs list)
  - Depth-limited recursion preventing infinite cycles
  - Graceful handling of missing/stale relationships

key-files:
  - src/main/kotlin/riven/core/service/workflow/EntityContextService.kt
  - src/test/kotlin/riven/core/service/workflow/EntityContextServiceTest.kt

key-decisions:
  - maxDepth default of 3 prevents infinite recursion while supporting practical nesting
  - Stale relationships return null (not errors) - workflows handle missing data gracefully
  - Depth exhaustion returns "entity:{id}" string for debugging visibility
---

# Phase 2 Plan 1: Entity Context Integration Summary

**Built entity context provider enabling expression evaluation against dynamic entity data with relationship traversal**

## Accomplishments

- Created EntityContextService converting entity payload (UUID-keyed) to expression context (String-keyed) using schema labels
- Implemented relationship traversal supporting nested property access (`client.address.city`)
- Added depth-limited recursion (maxDepth=3) preventing infinite cycles
- Achieved comprehensive test coverage with 12+ tests proving end-to-end integration
- Established foundation for workflow conditional logic against live entity data

## Files Created/Modified

- `src/main/kotlin/riven/core/service/workflow/EntityContextService.kt` - Entity-to-context conversion service
  - buildContext() - Converts entity to Map<String, Any?> using schema labels
  - buildContextWithRelationships() - Recursive relationship traversal with depth limiting
  - Helper methods for value extraction and cardinality handling

- `src/test/kotlin/riven/core/service/workflow/EntityContextServiceTest.kt` - Comprehensive test suite
  - 12+ test cases covering basic context building, relationship traversal, and expression evaluation
  - Integration tests proving expression evaluation works with entity data
  - Edge case coverage for missing entities, stale relationships, and depth limits

## Decisions Made

**Context Conversion:**
- UUID-keyed entity payload converted to String-keyed context using schema labels - enables human-readable expressions like `status = 'active'`
- Primitive values extracted directly from EntityAttributePrimitivePayload - type-safe conversion maintains evaluator contract

**Relationship Traversal:**
- maxDepth default of 3 prevents infinite recursion - practical limit supports typical entity graphs without performance issues
- Depth exhaustion returns "entity:{id}" string - provides debugging visibility when limit reached
- Stale relationships return null (not errors) - workflows handle missing data gracefully, prevents cascade failures

**Cardinality Handling:**
- ONE-TO-ONE/MANY-TO-ONE relationships return single nested map - matches expression syntax `client.address.city`
- ONE-TO-MANY/MANY-TO-MANY relationships return List<Map<String, Any?>> - supports iteration in future phases

## Issues Encountered

None - all tasks completed as planned with no blockers or deviations.

## Next Phase Readiness

**Ready for Phase 3: Temporal Workflow Engine**

The entity context integration provides:
- Expression evaluation against live entity data
- Relationship traversal for nested property access
- Depth-limited recursion preventing cycles
- Graceful handling of missing/stale relationships
- Comprehensive test coverage (12+ tests, 100% pass rate)

Next phase can build Temporal workflows with:
- Conditional logic based on entity data (`entity.status = 'active' AND count > 10`)
- Workflow gates using expression evaluation
- Action executors accessing entity context
- DAG execution with entity-driven branching

</output>
