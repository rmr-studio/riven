---
phase: 07.2-workflow-state-management
plan: 04
type: execute
wave: 2
depends_on: ["07.2-01", "07.2-02", "07.2-03"]
files_modified:
  - src/main/kotlin/riven/core/models/workflow/engine/datastore/WorkflowDataStore.kt
  - src/main/kotlin/riven/core/models/workflow/engine/datastore/StepOutput.kt
  - src/main/kotlin/riven/core/service/workflow/state/WorkflowNodeInputResolverService.kt
  - src/test/kotlin/riven/core/service/workflow/state/WorkflowNodeInputResolverServiceTest.kt
autonomous: true

must_haves:
  truths:
    - "InputResolverService accepts WorkflowDataStore parameter"
    - "Template resolution supports trigger, steps, variables, loops prefixes"
    - "Resolution fails fast with clear error messages"
    - "Backward compatibility maintained for {{ steps.name.output.field }}"
  artifacts:
    - path: "src/main/kotlin/riven/core/service/workflow/state/WorkflowNodeInputResolverService.kt"
      provides: "Updated resolver with multi-prefix support"
      exports: ["WorkflowNodeInputResolverService"]
  key_links:
    - from: "WorkflowNodeInputResolverService.resolve()"
      to: "WorkflowDataStore"
      via: "parameter change"
      pattern: "dataStore: WorkflowDataStore"
    - from: "resolveTemplatePath()"
      to: "NodeOutput.toMap()"
      via: "step output property access"
      pattern: "stepOutput\\.output\\.toMap\\(\\)"
---

<objective>
Update WorkflowNodeInputResolverService to use WorkflowDataStore and support all template prefixes.

Purpose: Enable template resolution against unified datastore with trigger/steps/variables/loops paths
Output: Updated InputResolverService with full prefix support and backward compatibility
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07.2-workflow-state-management/07.2-CONTEXT.md
@.planning/phases/07.2-workflow-state-management/07.2-RESEARCH.md

# Current implementation
@src/main/kotlin/riven/core/service/workflow/state/WorkflowNodeInputResolverService.kt

# Prior plan summaries (from Wave 1)
# Note: These will exist after Wave 1 completes
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update StepOutput to use NodeOutput type and add type imports</name>
  <files>
    src/main/kotlin/riven/core/models/workflow/engine/datastore/StepOutput.kt
    src/main/kotlin/riven/core/models/workflow/engine/datastore/WorkflowDataStore.kt
  </files>
  <action>
**Update StepOutput.kt:**
Change `output: Any?` to `output: NodeOutput` (now that NodeOutput exists from plan 02):

```kotlin
data class StepOutput(
    val nodeId: UUID,
    val nodeName: String,
    val status: WorkflowStatus,
    val output: NodeOutput,  // Changed from Any?
    val executedAt: Instant,
    val durationMs: Long
)
```

**Update WorkflowDataStore.kt:**
- Update trigger to use TriggerContext type: `private var _trigger: TriggerContext? = null`
- Update setTrigger signature: `fun setTrigger(trigger: TriggerContext)`
- Update getTrigger return type: `fun getTrigger(): TriggerContext?`
- Add necessary imports for NodeOutput and TriggerContext
  </action>
  <verify>`./gradlew compileKotlin` passes</verify>
  <done>StepOutput uses typed NodeOutput, WorkflowDataStore uses typed TriggerContext</done>
</task>

<task type="auto">
  <name>Task 2: Update WorkflowNodeInputResolverService for multi-prefix support</name>
  <files>src/main/kotlin/riven/core/service/workflow/state/WorkflowNodeInputResolverService.kt</files>
  <action>
Update the service to:

1. **Change method signatures** from `WorkflowExecutionContext` to `WorkflowDataStore`:
   - `resolve(templateOrValue: Any?, dataStore: WorkflowDataStore): Any?`
   - `resolveAll(config: Map<String, Any?>, dataStore: WorkflowDataStore): Map<String, Any?>`
   - Update all private methods similarly

2. **Update resolveTemplatePath()** to handle multiple root segments:

```kotlin
private fun resolveTemplatePath(
    path: List<String>,
    dataStore: WorkflowDataStore
): Any? {
    if (path.isEmpty()) {
        throw IllegalArgumentException("Empty template path")
    }

    val rootSegment = path[0]

    return when (rootSegment) {
        "steps" -> resolveStepsPath(path.drop(1), dataStore)
        "trigger" -> resolveTriggerPath(path.drop(1), dataStore)
        "variables" -> resolveVariablesPath(path.drop(1), dataStore)
        "loops" -> resolveLoopsPath(path.drop(1), dataStore)
        else -> throw IllegalArgumentException(
            "Invalid root segment '$rootSegment'. Must be: steps, trigger, variables, loops"
        )
    }
}
```

3. **Implement resolveStepsPath()** - Updated to use NodeOutput.toMap():

```kotlin
private fun resolveStepsPath(path: List<String>, dataStore: WorkflowDataStore): Any? {
    if (path.isEmpty()) {
        throw IllegalArgumentException("Template path must include node name: steps.<nodeName>")
    }

    val nodeName = path[0]
    val stepOutput = dataStore.getStepOutput(nodeName)

    if (stepOutput == null) {
        logger.warn { "Node '$nodeName' not found in datastore. Available: ${dataStore.getAllStepOutputs().keys}" }
        return null
    }

    if (stepOutput.status != WorkflowStatus.COMPLETED) {
        logger.warn { "Node '$nodeName' did not complete (status: ${stepOutput.status})" }
        return null
    }

    // Convert NodeOutput to map for traversal
    var current: Any? = stepOutput.output.toMap()

    // Determine start index (skip "output" if present for backward compat)
    val startIndex = if (path.size > 1 && path[1] == "output") 2 else 1

    // Traverse remaining path
    for (i in startIndex until path.size) {
        current = traverseProperty(current, path[i], path)
        if (current == null) return null
    }

    return current
}
```

4. **Implement resolveTriggerPath()**:

```kotlin
private fun resolveTriggerPath(path: List<String>, dataStore: WorkflowDataStore): Any? {
    val trigger = dataStore.getTrigger()
        ?: throw IllegalStateException("Trigger not set. Cannot resolve {{ trigger.* }}")

    var current: Any? = trigger.toMap()

    for (segment in path) {
        current = traverseProperty(current, segment, listOf("trigger") + path)
        if (current == null) return null
    }

    return current
}
```

5. **Implement resolveVariablesPath()**:

```kotlin
private fun resolveVariablesPath(path: List<String>, dataStore: WorkflowDataStore): Any? {
    if (path.isEmpty()) {
        throw IllegalArgumentException("Template path must include variable name: variables.<name>")
    }

    val varName = path[0]
    var current: Any? = dataStore.getVariable(varName)

    if (current == null) {
        logger.debug { "Variable '$varName' not found" }
        return null
    }

    // Traverse nested properties if path continues
    for (i in 1 until path.size) {
        current = traverseProperty(current, path[i], listOf("variables") + path)
        if (current == null) return null
    }

    return current
}
```

6. **Implement resolveLoopsPath()**:

```kotlin
private fun resolveLoopsPath(path: List<String>, dataStore: WorkflowDataStore): Any? {
    if (path.isEmpty()) {
        throw IllegalArgumentException("Template path must include loop name: loops.<loopId>")
    }

    val loopId = path[0]
    val loopContext = dataStore.getLoopContext(loopId)

    if (loopContext == null) {
        logger.debug { "Loop context '$loopId' not found" }
        return null
    }

    // Convert to map for traversal
    var current: Any? = mapOf(
        "currentIndex" to loopContext.currentIndex,
        "currentItem" to loopContext.currentItem,
        "totalItems" to loopContext.totalItems,
        "loopId" to loopContext.loopId
    )

    for (i in 1 until path.size) {
        current = traverseProperty(current, path[i], listOf("loops") + path)
        if (current == null) return null
    }

    return current
}
```

7. **Add helper method traverseProperty()**:

```kotlin
private fun traverseProperty(current: Any?, segment: String, fullPath: List<String>): Any? {
    return when (current) {
        null -> {
            logger.debug { "Cannot traverse '$segment' - value is null. Path: $fullPath" }
            null
        }
        is Map<*, *> -> {
            val value = current[segment]
            if (value == null) {
                logger.debug { "Property '$segment' not found. Path: $fullPath" }
            }
            value
        }
        else -> {
            logger.warn { "Cannot access '$segment' on ${current::class.simpleName}. Path: $fullPath" }
            null
        }
    }
}
```

8. **Update resolveEmbeddedTemplates()** signature to use dataStore
  </action>
  <verify>`./gradlew compileKotlin` passes</verify>
  <done>InputResolverService supports all prefixes with WorkflowDataStore parameter</done>
</task>

<task type="auto">
  <name>Task 3: Unit tests for multi-prefix template resolution</name>
  <files>src/test/kotlin/riven/core/service/workflow/state/WorkflowNodeInputResolverServiceTest.kt</files>
  <action>
Update existing tests and add new tests for multi-prefix support:

**Update existing tests:**
- Change all `WorkflowExecutionContext` references to `WorkflowDataStore`
- Update test setup to create WorkflowDataStore with WorkflowMetadata

**Add new tests:**

```kotlin
@Test
fun `resolves trigger path`() {
    val trigger = EntityEventTrigger(
        eventType = EntityEventType.CREATED,
        entityId = UUID.randomUUID(),
        entityTypeId = UUID.randomUUID(),
        entity = mapOf("name" to "Test Entity")
    )
    dataStore.setTrigger(trigger)

    val result = resolver.resolve("{{ trigger.entity.name }}", dataStore)

    assertEquals("Test Entity", result)
}

@Test
fun `resolves trigger eventType`() {
    val trigger = EntityEventTrigger(...)
    dataStore.setTrigger(trigger)

    val result = resolver.resolve("{{ trigger.eventType }}", dataStore)

    assertEquals("CREATED", result)
}

@Test
fun `throws when trigger not set`() {
    assertThrows<IllegalStateException> {
        resolver.resolve("{{ trigger.entity.id }}", dataStore)
    }
}

@Test
fun `resolves variables path`() {
    dataStore.setVariable("counter", 42)

    val result = resolver.resolve("{{ variables.counter }}", dataStore)

    assertEquals(42, result)
}

@Test
fun `resolves nested variable`() {
    dataStore.setVariable("user", mapOf("name" to "Alice"))

    val result = resolver.resolve("{{ variables.user.name }}", dataStore)

    assertEquals("Alice", result)
}

@Test
fun `resolves loops path`() {
    dataStore.setLoopContext("processItems", LoopContext(
        loopId = "processItems",
        currentIndex = 2,
        currentItem = mapOf("id" to "item-3"),
        totalItems = 10
    ))

    val result = resolver.resolve("{{ loops.processItems.currentItem.id }}", dataStore)

    assertEquals("item-3", result)
}

@Test
fun `steps path maintains backward compatibility`() {
    // {{ steps.nodeName.output.field }} still works
    val stepOutput = StepOutput(
        nodeId = UUID.randomUUID(),
        nodeName = "fetch",
        status = WorkflowStatus.COMPLETED,
        output = CreateEntityOutput(UUID.randomUUID(), UUID.randomUUID(), emptyMap()),
        executedAt = Instant.now(),
        durationMs = 100
    )
    dataStore.setStepOutput("fetch", stepOutput)

    val result = resolver.resolve("{{ steps.fetch.output.entityId }}", dataStore)

    assertNotNull(result)
}

@Test
fun `throws on invalid root segment`() {
    assertThrows<IllegalArgumentException> {
        resolver.resolve("{{ invalid.path }}", dataStore)
    }
}
```
  </action>
  <verify>`./gradlew test --tests "riven.core.service.workflow.state.WorkflowNodeInputResolverServiceTest"` passes</verify>
  <done>All template resolution tests pass for all prefixes</done>
</task>

</tasks>

<verification>
- `./gradlew compileKotlin` - No compilation errors
- `./gradlew test --tests "*WorkflowNodeInputResolverServiceTest*"` - All tests pass
- Verify backward compatibility: `{{ steps.name.output.field }}` still works
- Verify new prefixes: trigger, variables, loops all resolve correctly
- Verify fail-fast: invalid paths throw clear exceptions
</verification>

<success_criteria>
- StepOutput.output is typed as NodeOutput
- WorkflowDataStore uses TriggerContext type
- InputResolverService accepts WorkflowDataStore
- All four prefixes resolve correctly: trigger, steps, variables, loops
- Backward compatibility maintained for steps.*.output.* paths
- Clear error messages for invalid paths
- Unit tests cover all resolution scenarios
</success_criteria>

<output>
After completion, create `.planning/phases/07.2-workflow-state-management/07.2-04-SUMMARY.md`
</output>
