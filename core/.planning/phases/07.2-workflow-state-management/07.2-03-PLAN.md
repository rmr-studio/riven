---
phase: 07.2-workflow-state-management
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/main/kotlin/riven/core/models/workflow/engine/datastore/TriggerContext.kt
  - src/test/kotlin/riven/core/models/workflow/engine/datastore/TriggerContextTest.kt
autonomous: true

must_haves:
  truths:
    - "TriggerContext is sealed interface with 4 subclasses"
    - "EntityEvent contains entity data and event type"
    - "Webhook contains headers, body, and query params"
    - "All trigger types have toMap() for template access"
  artifacts:
    - path: "src/main/kotlin/riven/core/models/workflow/engine/datastore/TriggerContext.kt"
      provides: "Sealed interface for workflow triggers"
      exports: ["TriggerContext", "EntityEventTrigger", "WebhookTrigger", "ScheduleTrigger", "FunctionTrigger"]
  key_links:
    - from: "TriggerContext implementations"
      to: "toMap()"
      via: "property access for templates"
      pattern: "fun toMap\\(\\): Map<String, Any\\?>"
---

<objective>
Create TriggerContext sealed interface with typed trigger classes for each trigger type.

Purpose: Provide typed access to trigger data in templates via {{ trigger.* }} paths
Output: TriggerContext.kt sealed interface with all trigger type implementations
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07.2-workflow-state-management/07.2-CONTEXT.md
@.planning/phases/07.2-workflow-state-management/07.2-RESEARCH.md

# Existing trigger config types
@src/main/kotlin/riven/core/models/workflow/node/config/WorkflowTriggerConfig.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TriggerContext sealed interface with all trigger types</name>
  <files>src/main/kotlin/riven/core/models/workflow/engine/datastore/TriggerContext.kt</files>
  <action>
Create sealed interface and implementations based on CONTEXT.md specification:

```kotlin
package riven.core.models.workflow.engine.datastore

import riven.core.enums.entity.EntityEventType
import riven.core.models.common.json.JsonObject
import java.time.Instant

/**
 * Sealed interface for workflow trigger context.
 *
 * Each trigger type provides context data accessible via {{ trigger.* }} templates.
 * The toMap() method enables template resolution to access properties dynamically.
 */
sealed interface TriggerContext {
    /**
     * Convert trigger data to map for template property access.
     * Keys match property names, enabling {{ trigger.propertyName }} resolution.
     */
    fun toMap(): Map<String, Any?>
}

/**
 * Trigger context for entity events (create, update, delete).
 *
 * Template access:
 * - {{ trigger.eventType }} - CREATED, UPDATED, DELETED
 * - {{ trigger.entity.id }} - Entity UUID
 * - {{ trigger.entity.payload }} - Entity data
 * - {{ trigger.previousEntity }} - Previous state (UPDATE only)
 */
data class EntityEventTrigger(
    val eventType: EntityEventType,
    val entityId: java.util.UUID,
    val entityTypeId: java.util.UUID,
    val entity: Map<String, Any?>,
    val previousEntity: Map<String, Any?>? = null
) : TriggerContext {
    override fun toMap(): Map<String, Any?> = mapOf(
        "eventType" to eventType.name,
        "entityId" to entityId,
        "entityTypeId" to entityTypeId,
        "entity" to entity,
        "previousEntity" to previousEntity
    )
}

/**
 * Trigger context for webhook invocations.
 *
 * Template access:
 * - {{ trigger.headers.Content-Type }}
 * - {{ trigger.body.fieldName }}
 * - {{ trigger.queryParams.paramName }}
 */
data class WebhookTrigger(
    val headers: Map<String, String>,
    val body: JsonObject,
    val queryParams: Map<String, String>
) : TriggerContext {
    override fun toMap(): Map<String, Any?> = mapOf(
        "headers" to headers,
        "body" to body,
        "queryParams" to queryParams
    )
}

/**
 * Trigger context for scheduled executions.
 *
 * Template access:
 * - {{ trigger.scheduledAt }} - ISO timestamp
 * - {{ trigger.cronExpression }} - Cron expression (if cron-based)
 * - {{ trigger.interval }} - Interval in seconds (if interval-based)
 */
data class ScheduleTrigger(
    val scheduledAt: Instant,
    val cronExpression: String? = null,
    val interval: Long? = null
) : TriggerContext {
    override fun toMap(): Map<String, Any?> = mapOf(
        "scheduledAt" to scheduledAt.toString(),
        "cronExpression" to cronExpression,
        "interval" to interval
    )
}

/**
 * Trigger context for function/API invocations.
 *
 * Template access:
 * - {{ trigger.arguments.argName }}
 */
data class FunctionTrigger(
    val arguments: JsonObject
) : TriggerContext {
    override fun toMap(): Map<String, Any?> = mapOf(
        "arguments" to arguments
    )
}
```

Note: EntityEventType enum should already exist in the codebase. Use entity as Map rather than Entity model to avoid circular dependencies and enable flexible payload structure.
  </action>
  <verify>`./gradlew compileKotlin` passes</verify>
  <done>TriggerContext sealed interface with 4 typed trigger classes</done>
</task>

<task type="auto">
  <name>Task 2: Unit tests for TriggerContext toMap() methods</name>
  <files>src/test/kotlin/riven/core/models/workflow/engine/datastore/TriggerContextTest.kt</files>
  <action>
Create unit tests verifying toMap() returns correct structure:

```kotlin
@Test
fun `EntityEventTrigger toMap contains all fields`() {
    val trigger = EntityEventTrigger(
        eventType = EntityEventType.CREATED,
        entityId = UUID.randomUUID(),
        entityTypeId = UUID.randomUUID(),
        entity = mapOf("name" to "Test"),
        previousEntity = null
    )
    val map = trigger.toMap()

    assertEquals("CREATED", map["eventType"])
    assertNotNull(map["entityId"])
    assertNotNull(map["entity"])
    assertNull(map["previousEntity"])
}

@Test
fun `WebhookTrigger toMap enables nested access`() {
    val trigger = WebhookTrigger(
        headers = mapOf("Content-Type" to "application/json"),
        body = mapOf("userId" to "123"),
        queryParams = mapOf("page" to "1")
    )
    val map = trigger.toMap()

    val headers = map["headers"] as Map<*, *>
    assertEquals("application/json", headers["Content-Type"])
}

@Test
fun `ScheduleTrigger toMap includes scheduledAt as string`() {
    val now = Instant.now()
    val trigger = ScheduleTrigger(
        scheduledAt = now,
        cronExpression = "0 * * * *"
    )
    val map = trigger.toMap()

    assertEquals(now.toString(), map["scheduledAt"])
    assertEquals("0 * * * *", map["cronExpression"])
}

@Test
fun `FunctionTrigger toMap contains arguments`() {
    val trigger = FunctionTrigger(
        arguments = mapOf("input" to "value", "count" to 5)
    )
    val map = trigger.toMap()

    val args = map["arguments"] as Map<*, *>
    assertEquals("value", args["input"])
}
```
  </action>
  <verify>`./gradlew test --tests "riven.core.models.workflow.engine.datastore.TriggerContextTest"` passes</verify>
  <done>All TriggerContext implementations have tested toMap() methods</done>
</task>

</tasks>

<verification>
- `./gradlew compileKotlin` - No compilation errors
- `./gradlew test --tests "*TriggerContextTest*"` - All tests pass
- Verify each trigger type exposes appropriate fields for template access
</verification>

<success_criteria>
- TriggerContext sealed interface exists
- 4 trigger classes: EntityEventTrigger, WebhookTrigger, ScheduleTrigger, FunctionTrigger
- Each has toMap() method for template access
- EntityEventTrigger includes previousEntity for UPDATE events
- ScheduleTrigger supports both cron and interval triggers
</success_criteria>

<output>
After completion, create `.planning/phases/07.2-workflow-state-management/07.2-03-SUMMARY.md`
</output>
