---
phase: 07.2-workflow-state-management
plan: 06
type: execute
wave: 3
depends_on: ["07.2-04", "07.2-05"]
files_modified:
  - src/main/kotlin/riven/core/models/workflow/node/config/WorkflowNodeConfig.kt
  - src/main/kotlin/riven/core/models/workflow/node/config/actions/WorkflowCreateEntityActionConfig.kt
  - src/main/kotlin/riven/core/models/workflow/node/config/actions/WorkflowUpdateEntityActionConfig.kt
  - src/main/kotlin/riven/core/models/workflow/node/config/actions/WorkflowDeleteEntityActionConfig.kt
  - src/main/kotlin/riven/core/models/workflow/node/config/actions/WorkflowQueryEntityActionConfig.kt
  - src/main/kotlin/riven/core/models/workflow/node/config/actions/WorkflowHttpRequestActionConfig.kt
  - src/main/kotlin/riven/core/models/workflow/node/config/controls/WorkflowConditionControlConfig.kt
  - src/main/kotlin/riven/core/models/workflow/node/WorkflowNode.kt
  - src/main/kotlin/riven/core/service/workflow/engine/coordinator/WorkflowCoordinationService.kt
  - src/main/kotlin/riven/core/models/workflow/engine/coordinator/WorkflowState.kt
  - src/main/kotlin/riven/core/models/workflow/engine/coordinator/StateTransition.kt
autonomous: true

must_haves:
  truths:
    - "WorkflowCoordinationService creates and uses WorkflowDataStore"
    - "Coordinator writes StepOutput to dataStore after node execution"
    - "Node configs receive WorkflowDataStore instead of WorkflowExecutionContext"
    - "WorkflowState.dataRegistry is removed"
  artifacts:
    - path: "src/main/kotlin/riven/core/service/workflow/engine/coordinator/WorkflowCoordinationService.kt"
      provides: "Updated coordination with WorkflowDataStore"
      exports: ["WorkflowCoordinationService"]
  key_links:
    - from: "WorkflowCoordinationService.executeWorkflowWithCoordinator()"
      to: "WorkflowDataStore"
      via: "creates datastore"
      pattern: "WorkflowDataStore\\(metadata\\)"
    - from: "executeAction()"
      to: "dataStore.setStepOutput()"
      via: "coordinator writes output"
      pattern: "dataStore\\.setStepOutput\\(nodeName, stepOutput\\)"
---

<objective>
Integrate WorkflowDataStore into coordination service and update node signatures.

Purpose: Complete the unification by wiring all components together
Output: Working coordination with WorkflowDataStore, old classes can be deprecated
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07.2-workflow-state-management/07.2-CONTEXT.md
@.planning/phases/07.2-workflow-state-management/07.2-RESEARCH.md

# Current coordination service
@src/main/kotlin/riven/core/service/workflow/engine/coordinator/WorkflowCoordinationService.kt
@src/main/kotlin/riven/core/models/workflow/engine/coordinator/WorkflowState.kt
@src/main/kotlin/riven/core/models/workflow/engine/coordinator/StateTransition.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update node config signatures to use WorkflowDataStore</name>
  <files>
    src/main/kotlin/riven/core/models/workflow/node/config/WorkflowNodeConfig.kt
    src/main/kotlin/riven/core/models/workflow/node/config/actions/WorkflowCreateEntityActionConfig.kt
    src/main/kotlin/riven/core/models/workflow/node/config/actions/WorkflowUpdateEntityActionConfig.kt
    src/main/kotlin/riven/core/models/workflow/node/config/actions/WorkflowDeleteEntityActionConfig.kt
    src/main/kotlin/riven/core/models/workflow/node/config/actions/WorkflowQueryEntityActionConfig.kt
    src/main/kotlin/riven/core/models/workflow/node/config/actions/WorkflowHttpRequestActionConfig.kt
    src/main/kotlin/riven/core/models/workflow/node/config/controls/WorkflowConditionControlConfig.kt
    src/main/kotlin/riven/core/models/workflow/node/WorkflowNode.kt
  </files>
  <action>
**Update WorkflowNodeConfig.kt:**
Change context parameter from `WorkflowExecutionContext` to `WorkflowDataStore`:

```kotlin
import riven.core.models.workflow.engine.datastore.WorkflowDataStore
import riven.core.models.workflow.engine.datastore.NodeOutput

fun execute(
    dataStore: WorkflowDataStore,  // Changed from context: WorkflowExecutionContext
    inputs: JsonObject,
    services: NodeServiceProvider
): NodeOutput
```

**Update WorkflowNode.kt:**
```kotlin
fun execute(
    dataStore: WorkflowDataStore,
    inputs: JsonObject,
    services: NodeServiceProvider
): NodeOutput {
    return config.execute(dataStore, inputs, services)
}
```

**Update all 6 node config implementations:**
- Change `context: WorkflowExecutionContext` to `dataStore: WorkflowDataStore`
- Update any references to `context.workspaceId` to `dataStore.metadata.workspaceId`
- Update imports

Example for WorkflowCreateEntityActionConfig:
```kotlin
override fun execute(
    dataStore: WorkflowDataStore,
    inputs: JsonObject,
    services: NodeServiceProvider
): NodeOutput {
    // ... implementation ...
    val result = entityService.saveEntity(
        dataStore.metadata.workspaceId,  // Changed from context.workspaceId
        resolvedEntityTypeId,
        saveRequest
    )
    // ...
}
```
  </action>
  <verify>`./gradlew compileKotlin` fails in WorkflowCoordinationService (expected)</verify>
  <done>All node signatures updated to use WorkflowDataStore</done>
</task>

<task type="auto">
  <name>Task 2: Update WorkflowCoordinationService to use WorkflowDataStore</name>
  <files>src/main/kotlin/riven/core/service/workflow/engine/coordinator/WorkflowCoordinationService.kt</files>
  <action>
Major refactor of WorkflowCoordinationService:

**1. Create WorkflowDataStore at workflow start:**

In `executeWorkflowWithCoordinator()`:
```kotlin
// Create workflow metadata
val metadata = WorkflowMetadata(
    executionId = workflowExecutionId,
    workspaceId = workspaceId,
    workflowDefinitionId = workflowDefinitionId,
    version = 1,  // TODO: Get from workflow definition
    startedAt = Instant.now()
)

// Create unified datastore
val dataStore = WorkflowDataStore(metadata)

// TODO: Set trigger context when trigger execution is implemented
// dataStore.setTrigger(triggerContext)
```

**2. Update nodeExecutor callback:**

Pass dataStore instead of context:
```kotlin
val nodeExecutor: (List<WorkflowNode>) -> List<Pair<UUID, Any?>> = { readyNodes ->
    readyNodes.map { node ->
        // Execute node with dataStore
        val result = executeNode(node, dataStore)

        // Return nodeId -> output mapping
        node.id to result.output
    }
}
```

**3. Refactor executeNode():**

Change signature and implementation:
```kotlin
private fun executeNode(node: WorkflowNode, dataStore: WorkflowDataStore): NodeExecutionResult {
    val startTime = ZonedDateTime.now()
    val nodeId = node.id
    val workspaceId = dataStore.metadata.workspaceId

    // ... workspace verification ...

    // Get execution context from Temporal
    val activityInfo = Activity.getExecutionContext().info
    val workflowExecutionId = dataStore.metadata.executionId

    // Create execution record
    val executionNode = createExecutionNode(...)

    try {
        // Resolve inputs using dataStore
        val configMap = ... // existing logic
        val resolvedInputs = workflowNodeInputResolverService.resolveAll(configMap, dataStore)

        // Execute node
        val executionStart = System.currentTimeMillis()
        val output = node.execute(dataStore, resolvedInputs, nodeServiceProvider)
        val duration = System.currentTimeMillis() - executionStart

        // Create StepOutput and store in dataStore (coordinator writes!)
        val stepOutput = StepOutput(
            nodeId = nodeId,
            nodeName = node.name,
            status = WorkflowStatus.COMPLETED,
            output = output,
            executedAt = Instant.now(),
            durationMs = duration
        )
        dataStore.setStepOutput(node.name, stepOutput)

        // Update execution record
        updateExecutionNode(...)

        return NodeExecutionResult(
            nodeId = nodeId,
            status = WorkflowStatus.COMPLETED,
            output = output.toMap()  // For backward compat with WorkflowState
        )
    } catch (e: Exception) {
        // ... existing error handling ...
    }
}
```

**4. Remove context creation in executeNode():**
Delete the old `WorkflowExecutionContext(...)` creation.

**5. Update executeAction():**
Change signature to use dataStore and NodeOutput:
```kotlin
private fun executeAction(
    nodeId: UUID,
    nodeName: String,
    nodeType: String,
    dataStore: WorkflowDataStore,
    execution: () -> NodeOutput
): NodeExecutionResult {
    // ... similar logic but with NodeOutput ...
}
```

Or consider inlining this since the coordinator now handles writing to dataStore.
  </action>
  <verify>`./gradlew compileKotlin` passes</verify>
  <done>WorkflowCoordinationService uses WorkflowDataStore throughout</done>
</task>

<task type="auto">
  <name>Task 3: Remove dataRegistry from WorkflowState and clean up</name>
  <files>
    src/main/kotlin/riven/core/models/workflow/engine/coordinator/WorkflowState.kt
    src/main/kotlin/riven/core/models/workflow/engine/coordinator/StateTransition.kt
  </files>
  <action>
**Update WorkflowState.kt:**

Remove dataRegistry field since data is now in WorkflowDataStore:
```kotlin
data class WorkflowState(
    val phase: WorkflowExecutionPhase,
    val activeNodes: Set<UUID> = emptySet(),
    val completedNodes: Set<UUID> = emptySet(),
    val failedNodes: Set<UUID> = emptySet()
    // REMOVED: val dataRegistry: Map<UUID, Any?> = emptyMap()
) {
    // ... existing methods ...

    // REMOVED: fun getNodeOutput(nodeId: UUID): Any? = dataRegistry[nodeId]
}
```

**Update StateTransition.kt:**

Remove dataRegistry from NodeCompleted handling:
```kotlin
is NodeCompleted -> state.copy(
    activeNodes = state.activeNodes - event.nodeId,
    completedNodes = state.completedNodes + event.nodeId
    // REMOVED: dataRegistry = state.dataRegistry + (event.nodeId to event.output)
)
```

Update NodeCompleted event:
```kotlin
// Changed: Remove output parameter since data is in WorkflowDataStore
data class NodeCompleted(val nodeId: UUID) : StateEvent
// Old was: data class NodeCompleted(val nodeId: UUID, val output: Any?) : StateEvent
```

**Update callers of NodeCompleted:**
In WorkflowGraphCoordinationService, update to not pass output:
```kotlin
state = StateTransition.apply(state, NodeCompleted(nodeId))
// Instead of: StateTransition.apply(state, NodeCompleted(nodeId, output))
```

Note: WorkflowState is now purely for orchestration tracking (phase, active/completed/failed nodes). All data lives in WorkflowDataStore.
  </action>
  <verify>`./gradlew compileKotlin` and `./gradlew test` pass</verify>
  <done>WorkflowState is pure orchestration state, dataRegistry removed</done>
</task>

</tasks>

<verification>
- `./gradlew compileKotlin` - No compilation errors
- `./gradlew test` - All tests pass (may need updates for changed signatures)
- Verify WorkflowDataStore is created at workflow start
- Verify coordinator writes StepOutput after node execution
- Verify WorkflowState no longer has dataRegistry
- Run integration test if available
</verification>

<success_criteria>
- WorkflowCoordinationService creates WorkflowDataStore at workflow start
- All node configs receive WorkflowDataStore parameter
- Coordinator writes StepOutput to dataStore (not node)
- WorkflowState is orchestration-only (no dataRegistry)
- StateTransition updated for simplified NodeCompleted
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/07.2-workflow-state-management/07.2-06-SUMMARY.md`
</output>
