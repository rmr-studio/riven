---
phase: 07.2-workflow-state-management
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/main/kotlin/riven/core/models/workflow/engine/datastore/NodeOutput.kt
  - src/test/kotlin/riven/core/models/workflow/engine/datastore/NodeOutputTest.kt
autonomous: true

must_haves:
  truths:
    - "NodeOutput is sealed interface with typed subclasses"
    - "Each action type has corresponding output class"
    - "Output classes have toMap() for template property access"
  artifacts:
    - path: "src/main/kotlin/riven/core/models/workflow/engine/datastore/NodeOutput.kt"
      provides: "Typed output sealed interface and implementations"
      exports: ["NodeOutput", "CreateEntityOutput", "UpdateEntityOutput", "DeleteEntityOutput", "QueryEntityOutput", "HttpResponseOutput", "ConditionOutput"]
  key_links:
    - from: "NodeOutput implementations"
      to: "toMap()"
      via: "property access for templates"
      pattern: "fun toMap\\(\\): Map<String, Any\\?>"
---

<objective>
Create NodeOutput sealed interface with typed output classes for each action type.

Purpose: Replace untyped Map<String, Any?> returns with type-safe outputs
Output: NodeOutput.kt sealed interface with all typed implementations
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07.2-workflow-state-management/07.2-CONTEXT.md
@.planning/phases/07.2-workflow-state-management/07.2-RESEARCH.md

# Current output patterns from node configs
@src/main/kotlin/riven/core/models/workflow/node/config/actions/WorkflowCreateEntityActionConfig.kt
@src/main/kotlin/riven/core/models/workflow/node/config/actions/WorkflowHttpRequestActionConfig.kt
@src/main/kotlin/riven/core/models/workflow/node/config/controls/WorkflowConditionControlConfig.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create NodeOutput sealed interface with all typed output classes</name>
  <files>src/main/kotlin/riven/core/models/workflow/engine/datastore/NodeOutput.kt</files>
  <action>
Create sealed interface and all implementations in single file:

```kotlin
package riven.core.models.workflow.engine.datastore

import java.util.UUID

/**
 * Sealed interface for typed node execution outputs.
 *
 * Each action/control type has a corresponding output class with typed fields.
 * The toMap() method enables template resolution to access properties dynamically.
 */
sealed interface NodeOutput {
    /**
     * Convert output to map for template property access.
     * Keys match property names, enabling {{ steps.node.output.propertyName }} resolution.
     */
    fun toMap(): Map<String, Any?>
}

// Entity action outputs

data class CreateEntityOutput(
    val entityId: UUID,
    val entityTypeId: UUID,
    val payload: Map<UUID, Any?>
) : NodeOutput {
    override fun toMap(): Map<String, Any?> = mapOf(
        "entityId" to entityId,
        "entityTypeId" to entityTypeId,
        "payload" to payload
    )
}

data class UpdateEntityOutput(
    val entityId: UUID,
    val updated: Boolean,
    val payload: Map<UUID, Any?>
) : NodeOutput {
    override fun toMap(): Map<String, Any?> = mapOf(
        "entityId" to entityId,
        "updated" to updated,
        "payload" to payload
    )
}

data class DeleteEntityOutput(
    val entityId: UUID,
    val deleted: Boolean,
    val impactedEntities: Int
) : NodeOutput {
    override fun toMap(): Map<String, Any?> = mapOf(
        "entityId" to entityId,
        "deleted" to deleted,
        "impactedEntities" to impactedEntities
    )
}

data class QueryEntityOutput(
    val entities: List<Map<String, Any?>>,  // Entity payload maps
    val totalCount: Int,
    val hasMore: Boolean
) : NodeOutput {
    override fun toMap(): Map<String, Any?> = mapOf(
        "entities" to entities,
        "totalCount" to totalCount,
        "hasMore" to hasMore
    )
}

// HTTP action output

data class HttpResponseOutput(
    val statusCode: Int,
    val headers: Map<String, String>,
    val body: String?,
    val url: String,
    val method: String
) : NodeOutput {
    /** Computed property: true if status code is 2xx */
    val success: Boolean get() = statusCode in 200..299

    override fun toMap(): Map<String, Any?> = mapOf(
        "statusCode" to statusCode,
        "headers" to headers,
        "body" to body,
        "url" to url,
        "method" to method,
        "success" to success
    )
}

// Control flow outputs

data class ConditionOutput(
    val result: Boolean,
    val evaluatedExpression: String
) : NodeOutput {
    override fun toMap(): Map<String, Any?> = mapOf(
        "result" to result,
        "conditionResult" to result,  // Backward compatibility with current usage
        "evaluatedExpression" to evaluatedExpression
    )
}
```

Note: The output property in CONTEXT.md used `conditionResult` but we standardize to `result` with backward compat alias.
  </action>
  <verify>`./gradlew compileKotlin` passes</verify>
  <done>NodeOutput sealed interface with 6 typed output classes, all with toMap() methods</done>
</task>

<task type="auto">
  <name>Task 2: Unit tests for NodeOutput toMap() methods</name>
  <files>src/test/kotlin/riven/core/models/workflow/engine/datastore/NodeOutputTest.kt</files>
  <action>
Create unit tests verifying toMap() returns correct structure:

```kotlin
@Test
fun `CreateEntityOutput toMap contains all fields`() {
    val output = CreateEntityOutput(
        entityId = UUID.randomUUID(),
        entityTypeId = UUID.randomUUID(),
        payload = mapOf(UUID.randomUUID() to "value")
    )
    val map = output.toMap()

    assertNotNull(map["entityId"])
    assertNotNull(map["entityTypeId"])
    assertNotNull(map["payload"])
    assertEquals(3, map.size)
}

@Test
fun `HttpResponseOutput success computed correctly`() {
    val success = HttpResponseOutput(200, emptyMap(), null, "http://test", "GET")
    val failure = HttpResponseOutput(404, emptyMap(), null, "http://test", "GET")

    assertTrue(success.success)
    assertTrue(success.toMap()["success"] as Boolean)
    assertFalse(failure.success)
    assertFalse(failure.toMap()["success"] as Boolean)
}

@Test
fun `ConditionOutput includes backward compatibility alias`() {
    val output = ConditionOutput(result = true, evaluatedExpression = "x > 5")
    val map = output.toMap()

    assertEquals(true, map["result"])
    assertEquals(true, map["conditionResult"])  // Backward compat
}
```

Test each output class's toMap() returns expected keys and values.
  </action>
  <verify>`./gradlew test --tests "riven.core.models.workflow.engine.datastore.NodeOutputTest"` passes</verify>
  <done>All NodeOutput implementations have tested toMap() methods</done>
</task>

</tasks>

<verification>
- `./gradlew compileKotlin` - No compilation errors
- `./gradlew test --tests "*NodeOutputTest*"` - All tests pass
- Verify each output class maps to current execute() return structure
</verification>

<success_criteria>
- NodeOutput sealed interface exists
- 6 output classes: CreateEntityOutput, UpdateEntityOutput, DeleteEntityOutput, QueryEntityOutput, HttpResponseOutput, ConditionOutput
- Each has toMap() method for template access
- HttpResponseOutput has computed `success` property
- ConditionOutput has backward compat `conditionResult` alias
</success_criteria>

<output>
After completion, create `.planning/phases/07.2-workflow-state-management/07.2-02-SUMMARY.md`
</output>
