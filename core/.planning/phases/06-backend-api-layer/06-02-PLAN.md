---
phase: 06-backend-api-layer
plan: 02
type: execute
wave: 2
depends_on: [06-01]
files_modified:
  - src/main/kotlin/riven/core/service/workflow/WorkflowGraphService.kt
  - src/main/kotlin/riven/core/controller/workflow/WorkflowGraphController.kt
  - src/main/kotlin/riven/core/models/request/workflow/CreateWorkflowNodeRequest.kt
  - src/main/kotlin/riven/core/models/request/workflow/UpdateWorkflowNodeRequest.kt
  - src/main/kotlin/riven/core/models/request/workflow/CreateWorkflowEdgeRequest.kt
  - src/main/kotlin/riven/core/models/workflow/WorkflowGraph.kt
autonomous: true

must_haves:
  truths:
    - "User can create workflow nodes via POST /api/v1/workflow/graph/nodes"
    - "User can update workflow nodes via PUT /api/v1/workflow/graph/nodes/{id}"
    - "User can delete workflow nodes via DELETE /api/v1/workflow/graph/nodes/{id}"
    - "User can create workflow edges via POST /api/v1/workflow/graph/edges"
    - "User can delete workflow edges via DELETE /api/v1/workflow/graph/edges/{id}"
    - "User can retrieve complete workflow graph (nodes + edges) via GET /api/v1/workflow/graph/workflow/{workflowDefinitionId}"
    - "Deleting a node cascades to delete all connected edges"
  artifacts:
    - path: "src/main/kotlin/riven/core/service/workflow/WorkflowGraphService.kt"
      provides: "Workflow graph management (nodes and edges)"
      min_lines: 200
    - path: "src/main/kotlin/riven/core/controller/workflow/WorkflowGraphController.kt"
      provides: "REST endpoints for workflow graph operations"
      exports: ["createNode", "updateNode", "deleteNode", "createEdge", "deleteEdge", "getGraph"]
    - path: "src/main/kotlin/riven/core/models/workflow/WorkflowGraph.kt"
      provides: "Complete workflow graph model"
      contains: "data class WorkflowGraph"
  key_links:
    - from: "src/main/kotlin/riven/core/controller/workflow/WorkflowGraphController.kt"
      to: "WorkflowGraphService"
      via: "constructor injection"
      pattern: "private val workflowGraphService: WorkflowGraphService"
    - from: "src/main/kotlin/riven/core/service/workflow/WorkflowGraphService.kt"
      to: "WorkflowNodeRepository"
      via: "node CRUD operations"
      pattern: "workflowNodeRepository\\.(save|findById|delete)"
    - from: "src/main/kotlin/riven/core/service/workflow/WorkflowGraphService.kt"
      to: "WorkflowEdgeRepository"
      via: "edge CRUD operations and cascade deletes"
      pattern: "workflowEdgeRepository\\.(save|findById|delete)"
---

<objective>
Implement REST APIs for workflow graph structure management (nodes and edges)

Purpose: Enable users to construct workflow DAGs by creating/updating/deleting nodes and edges, with cascade deletion for graph consistency.

Output: Complete graph management API with service layer business logic, request/response models, and cascade deletion handling.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase 6 Plan 1 outputs
@.planning/phases/06-backend-api-layer/06-01-SUMMARY.md

# Existing workflow infrastructure
@src/main/kotlin/riven/core/entity/workflow/WorkflowNodeEntity.kt
@src/main/kotlin/riven/core/entity/workflow/WorkflowEdgeEntity.kt
@src/main/kotlin/riven/core/repository/workflow/WorkflowNodeRepository.kt
@src/main/kotlin/riven/core/repository/workflow/WorkflowEdgeRepository.kt
@src/main/kotlin/riven/core/models/workflow/node/WorkflowNode.kt
@src/main/kotlin/riven/core/models/workflow/WorkflowEdge.kt

# Reference patterns
@src/main/kotlin/riven/core/controller/entity/EntityTypeController.kt
@src/main/kotlin/riven/core/service/entity/type/EntityTypeService.kt
@CLAUDE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create WorkflowGraphService with node and edge operations</name>
  <files>
    src/main/kotlin/riven/core/service/workflow/WorkflowGraphService.kt
    src/main/kotlin/riven/core/models/request/workflow/CreateWorkflowNodeRequest.kt
    src/main/kotlin/riven/core/models/request/workflow/UpdateWorkflowNodeRequest.kt
    src/main/kotlin/riven/core/models/request/workflow/CreateWorkflowEdgeRequest.kt
    src/main/kotlin/riven/core/models/workflow/WorkflowGraph.kt
  </files>
  <action>
    Create WorkflowGraphService following established service patterns:

    **Service structure:**
    - Constructor inject: WorkflowNodeRepository, WorkflowEdgeRepository, WorkflowDefinitionRepository, ActivityService, AuthTokenService
    - @Service annotation
    - KotlinLogging for logging

    **Node operations:**

    1. `createNode(workspaceId: UUID, request: CreateWorkflowNodeRequest): WorkflowNode`
       - Uses WorkflowNodeEntity.fromConfig() to create entity
       - Sets version=1, system=false, deleted=false
       - Saves to repository
       - Logs activity (CREATE, WORKFLOW_NODE)
       - Returns WorkflowNode via toModel()

    2. `updateNode(id: UUID, workspaceId: UUID, request: UpdateWorkflowNodeRequest): WorkflowNode`
       - Fetches existing node, verifies workspace access
       - Updates: name, description, config (using WorkflowNodeEntity.createNewVersion if config changes)
       - For config changes: Create new version (immutable pattern like BlockType)
       - For metadata changes only: Update in place
       - Logs activity (UPDATE)
       - Returns updated WorkflowNode

    3. `deleteNode(id: UUID, workspaceId: UUID): Unit`
       - Fetches node, verifies workspace access
       - CASCADE DELETE: Find all edges where sourceNodeId=id OR targetNodeId=id
       - Delete all connected edges (soft delete: deleted=true)
       - Delete node (soft delete: deleted=true, deletedAt=now)
       - Logs activity (DELETE) for node and each edge
       - Important: This maintains graph consistency

    **Edge operations:**

    4. `createEdge(workspaceId: UUID, request: CreateWorkflowEdgeRequest): WorkflowEdge`
       - Validates: sourceNodeId and targetNodeId exist in workspace
       - Creates WorkflowEdgeEntity
       - Saves to repository
       - Logs activity (CREATE, WORKFLOW_EDGE)
       - Returns WorkflowEdge via toModel() (fetch source/target nodes for model)

    5. `deleteEdge(id: UUID, workspaceId: UUID): Unit`
       - Fetches edge, verifies workspace access
       - Soft deletes edge
       - Logs activity (DELETE)

    **Graph query:**

    6. `getWorkflowGraph(workflowDefinitionId: UUID, workspaceId: UUID): WorkflowGraph`
       - Fetches workflow definition, verifies workspace access
       - Fetches current version's workflow JSON
       - Extracts node IDs from workflow structure
       - Fetches all WorkflowNodeEntity by IDs (using WorkflowNodeRepository.findByWorkspaceIdAndIdIn)
       - Fetches all WorkflowEdgeEntity for those nodes (using WorkflowEdgeRepository.findByWorkspaceIdAndNodeIds)
       - Constructs WorkflowGraph model with nodes and edges
       - Returns complete graph

    **Request models to create:**

    CreateWorkflowNodeRequest:
    ```kotlin
    data class CreateWorkflowNodeRequest(
        val key: String,
        val name: String,
        val description: String?,
        val config: WorkflowNodeConfig  // Polymorphic: ActionConfig, ControlConfig, etc.
    )
    ```

    UpdateWorkflowNodeRequest:
    ```kotlin
    data class UpdateWorkflowNodeRequest(
        val name: String?,
        val description: String?,
        val config: WorkflowNodeConfig?  // If provided, creates new version
    )
    ```

    CreateWorkflowEdgeRequest:
    ```kotlin
    data class CreateWorkflowEdgeRequest(
        val sourceNodeId: UUID,
        val targetNodeId: UUID,
        val label: String?
    )
    ```

    WorkflowGraph model:
    ```kotlin
    data class WorkflowGraph(
        val workflowDefinitionId: UUID,
        val nodes: List<WorkflowNode>,
        val edges: List<WorkflowEdge>
    )
    ```

    **Important patterns:**
    - Cascade deletion: When node deleted, delete all connected edges
    - Immutable versioning for nodes (like BlockType): Config changes create new version
    - Validation: Edges must reference existing nodes in same workspace
    - Use existing WorkflowNode.toModel() and WorkflowEdge.toModel(source, target)
  </action>
  <verify>
    ./gradlew compileKotlin - confirms service compiles with proper dependency injection
  </verify>
  <done>
    WorkflowGraphService exists with 6 methods (3 node ops, 2 edge ops, 1 graph query), request models created, compiles successfully
  </done>
</task>

<task type="auto">
  <name>Task 2: Create WorkflowGraphController with REST endpoints</name>
  <files>
    src/main/kotlin/riven/core/controller/workflow/WorkflowGraphController.kt
  </files>
  <action>
    Create WorkflowGraphController for graph operations:

    **Controller structure:**
    - @RestController
    - @RequestMapping("/api/v1/workflow/graph")
    - @Tag(name = "Workflow Graph Management", description = "Endpoints for managing workflow nodes and edges")
    - Constructor inject WorkflowGraphService
    - @PreAuthorize("isAuthenticated()") on all endpoints

    **Node endpoints:**

    1. **POST /api/v1/workflow/graph/nodes/workspace/{workspaceId}**
       - @Operation(summary = "Create a new workflow node")
       - Body: CreateWorkflowNodeRequest
       - @ApiResponses: 201, 400, 401
       - Returns: ResponseEntity&lt;WorkflowNode&gt; with HttpStatus.CREATED

    2. **PUT /api/v1/workflow/graph/nodes/{id}**
       - @Operation(summary = "Update workflow node")
       - @RequestParam workspaceId: UUID
       - Body: UpdateWorkflowNodeRequest
       - @ApiResponses: 200, 400, 404, 401
       - Returns: ResponseEntity&lt;WorkflowNode&gt;

    3. **DELETE /api/v1/workflow/graph/nodes/{id}**
       - @Operation(summary = "Delete workflow node (cascades to connected edges)")
       - @RequestParam workspaceId: UUID
       - @ApiResponses: 204, 404, 401
       - Returns: ResponseEntity&lt;Void&gt; with HttpStatus.NO_CONTENT
       - Note: Include cascade behavior in API docs

    **Edge endpoints:**

    4. **POST /api/v1/workflow/graph/edges/workspace/{workspaceId}**
       - @Operation(summary = "Create a new workflow edge")
       - Body: CreateWorkflowEdgeRequest
       - @ApiResponses: 201, 400, 401
       - Returns: ResponseEntity&lt;WorkflowEdge&gt; with HttpStatus.CREATED

    5. **DELETE /api/v1/workflow/graph/edges/{id}**
       - @Operation(summary = "Delete workflow edge")
       - @RequestParam workspaceId: UUID
       - @ApiResponses: 204, 404, 401
       - Returns: ResponseEntity&lt;Void&gt; with HttpStatus.NO_CONTENT

    **Graph query endpoint:**

    6. **GET /api/v1/workflow/graph/workflow/{workflowDefinitionId}**
       - @Operation(summary = "Get complete workflow graph (nodes and edges)")
       - @RequestParam workspaceId: UUID
       - @ApiResponses: 200, 404, 401
       - Returns: ResponseEntity&lt;WorkflowGraph&gt;
       - Description: "Returns the complete DAG structure with all nodes and edges for the workflow"

    **Important patterns:**
    - Follow WorkflowDefinitionController patterns from Plan 1
    - Log requests with KotlinLogging
    - Use proper HTTP status codes
    - OpenAPI annotations for clear API documentation
  </action>
  <verify>
    ./gradlew build -x test - confirms controller compiles and wires correctly
  </verify>
  <done>
    WorkflowGraphController exists with 6 REST endpoints (3 node, 2 edge, 1 graph query), follows established patterns, compiles successfully
  </done>
</task>

<task type="auto">
  <name>Task 3: Add integration test for workflow graph operations</name>
  <files>
    src/test/kotlin/riven/core/service/workflow/WorkflowGraphServiceTest.kt
  </files>
  <action>
    Create integration test for WorkflowGraphService focusing on cascade deletion and graph consistency:

    **Test class structure:**
    - JUnit 5 with Mockito
    - Mock: WorkflowNodeRepository, WorkflowEdgeRepository, WorkflowDefinitionRepository, ActivityService, AuthTokenService
    - @ExtendWith(MockitoExtension::class)

    **Critical test cases (minimum 10 tests):**

    1. `createNode_success_createsNodeWithVersion1()`
       - Verify WorkflowNodeEntity created with version=1, system=false
       - Assert toModel() called and WorkflowNode returned

    2. `updateNode_metadataOnly_updatesInPlace()`
       - Update name/description only (no config change)
       - Verify save called on same entity (no version increment)

    3. `updateNode_configChange_createsNewVersion()`
       - Update config field
       - Verify WorkflowNodeEntity.createNewVersion called
       - Verify new version has version=2, sourceId=originalId

    4. `deleteNode_withEdges_cascadesDelete()`
       - **CRITICAL TEST**: Create node with 2 connected edges
       - Mock edgeRepository to return 2 edges when querying for node
       - Call deleteNode()
       - Verify node deleted (deleted=true)
       - Verify both edges deleted (verify called twice with deleted=true)
       - Verify 3 activity logs (1 node + 2 edges)

    5. `createEdge_success_validatesNodesExist()`
       - Mock nodes exist in repository
       - Verify WorkflowEdgeEntity created
       - Verify edge toModel() fetches source/target nodes

    6. `createEdge_sourceNotFound_throwsNotFoundException()`
       - Mock sourceNode returns empty
       - Assert NotFoundException thrown

    7. `createEdge_targetNotFound_throwsNotFoundException()`
       - Mock targetNode returns empty
       - Assert NotFoundException thrown

    8. `deleteEdge_success_softDeletes()`
       - Verify edge deleted=true
       - Verify activity logged

    9. `getWorkflowGraph_success_returnsNodesAndEdges()`
       - Mock workflow definition with 3 node IDs
       - Mock nodeRepository returns 3 nodes
       - Mock edgeRepository returns 2 edges
       - Assert WorkflowGraph contains 3 nodes and 2 edges

    10. `getWorkflowGraph_notFound_throwsNotFoundException()`
        - Mock workflowDefinition not found
        - Assert NotFoundException thrown

    **Testing patterns:**
    - Use `argumentCaptor<WorkflowEdgeEntity>()` to capture delete calls for edges
    - Verify cascade logic: `verify(edgeRepository, times(2)).save(argThat { deleted == true })`
    - Test graph consistency: After node deletion, verify no orphaned edges remain
  </action>
  <verify>
    ./gradlew test --tests WorkflowGraphServiceTest - all tests pass, cascade deletion verified
  </verify>
  <done>
    WorkflowGraphServiceTest exists with minimum 10 test cases including critical cascade deletion test, all passing
  </done>
</task>

</tasks>

<verification>
**Overall verification:**

1. Build: `./gradlew clean build`
2. Tests: `./gradlew test --tests '*WorkflowGraph*'`
3. OpenAPI: Verify "Workflow Graph Management" section exists with 6 endpoints
4. Cascade deletion test: Verify deleteNode test confirms edges are deleted when node deleted
5. Manual test (optional):
   - Create 2 nodes
   - Create edge connecting them
   - Delete source node
   - Verify edge also deleted (query returns 0 edges)

**Success criteria:**
- WorkflowGraphService implements 6 methods (node CRUD, edge CRUD, graph query)
- Cascade deletion works (deleting node deletes connected edges)
- WorkflowGraphController exposes 6 endpoints
- Integration tests verify graph consistency
</verification>

<success_criteria>
- [ ] WorkflowGraphService created with 6 methods (createNode, updateNode, deleteNode, createEdge, deleteEdge, getWorkflowGraph)
- [ ] Cascade deletion implemented: deleting node deletes all connected edges
- [ ] Request models (CreateWorkflowNodeRequest, UpdateWorkflowNodeRequest, CreateWorkflowEdgeRequest) created
- [ ] WorkflowGraph model created (nodes + edges)
- [ ] WorkflowGraphController created with 6 REST endpoints
- [ ] Integration tests created with minimum 10 test cases including cascade deletion test, all passing
- [ ] ./gradlew build succeeds
- [ ] OpenAPI documentation includes graph management endpoints
</success_criteria>

<output>
After completion, create `.planning/phases/06-backend-api-layer/06-02-SUMMARY.md`
</output>
