# Phase 4.1: Action Execution - Context

**Gathered:** 2026-01-11
**Status:** Ready for planning

<vision>
## How This Should Work

This phase addresses a critical architectural gap in how workflow nodes execute and how data flows between them.

**Current Problem:**
- WorkflowNodeActivitiesImpl uses type switching (executeActionNode, executeTriggerNode, etc.) which isn't extensible
- No clear way for nodes to access data from previous nodes
- Missing architecture for how nodes interlink to create data sequences

**Vision:**
Move to a polymorphic execution model where:

1. **WorkflowNode.execute()** - Each node type implements its own execute() method using a strategy pattern. Instead of external type switching, nodes know how to execute themselves.

2. **Data Registry** - A separate data plane (distinct from Temporal's workflow context) that acts as the single source of truth for all node outputs. Every node execution stores its results in the registry.

3. **Declarative Input Resolution** - Nodes declare their required inputs (e.g., "I need email address and body to send email"). An input resolver fetches the required data from the registry before execution.

4. **Template-Based Data Access** - Nodes reference data using template syntax:
   - `{{ steps.fetch_leads.output }}` - access output from a previous step
   - `{{ loop.enrich_lead.item.email }}` - access data from loop iteration
   - These paths are evaluated during execution to pull data from the registry

5. **Data Flow Foundation** - This enables nodes to execute actions based on prior results, supports data aggregation (using outputs from multiple previous nodes), and creates the foundation for sequential workflows.

**Architecture:**
- **Workflow Execution Context** (Temporal) - Holds workflow metadata and orchestration state
- **Data Registry** (New) - Holds all node execution outputs, acts as the data plane
- **Input Resolver** (New) - Resolves template references and fetches data from registry
- **Polymorphic Nodes** (Refactor) - Nodes implement execute(context, inputs) instead of external type switching

</vision>

<essential>
## What Must Be Nailed

These are interconnected and must be solved together:

- **The execution interface** - Get the WorkflowNode.execute() API right. Define the contract that all node types implement, how they receive context and resolved inputs, how they return outputs.

- **Data access patterns** - Define how nodes reference data in the registry. The template syntax ({{ }} expressions), path resolution rules, what data is accessible at each point in execution.

- **Context structure** - Clearly separate workflow execution context (orchestration metadata) from data registry (node outputs). Define schemas for both and how they evolve during execution.

- **Input declaration & resolution** - How nodes declare what data they need, how the input resolver fetches and prepares that data before execution, error handling when data isn't available.

The goal: Any node should be able to execute actions using data from any previous node in a clear, predictable way.

</essential>

<boundaries>
## What's Out of Scope

- **DAG coordination** - This phase focuses on individual node execution and data flow. Phase 5 (DAG Execution Coordinator) handles orchestrating multiple nodes, managing dependencies, topological sorting, and parallel execution.

- **Multi-node orchestration** - Not building the scheduler or dependency resolver yet. This phase is about getting a single node to execute correctly with access to prior data.

- **Advanced error handling** - Focus on happy-path execution. Comprehensive error handling, retries, and failure recovery are Phase 7.

</boundaries>

<specifics>
## Specific Ideas

- No strong preference on specific implementation patterns - open to whatever makes the most sense architecturally

- Key architectural principle: **Separation of concerns** between control plane (workflow context) and data plane (registry)

- Template syntax should support:
  - Step outputs: `{{ steps.step_name.output }}`
  - Loop iterations: `{{ loop.loop_name.item.field }}`
  - Nested data access for complex objects

- Should enable data aggregation patterns (e.g., collect results from multiple prior steps)

</specifics>

<notes>
## Additional Context

**Current Architecture (Phase 4):**
- WorkflowNodeActivitiesImpl receives node definitions
- Uses type switching to route to executeActionNode, executeTriggerNode, etc.
- Action executors exist (entity CRUD, HTTP requests, conditionals)
- No clear data passing mechanism between nodes

**This Phase Builds:**
- Polymorphic execution model (eliminate type switching)
- Data registry architecture
- Input declaration and resolution system
- Foundation for sequential workflows

**Sets Up Phase 5:**
- Phase 5 can focus purely on DAG coordination (topological sort, parallel execution)
- With node execution and data flow solved here, Phase 5 orchestrates the bigger picture

</notes>

---

*Phase: 4.1-action-execution*
*Context gathered: 2026-01-11*
