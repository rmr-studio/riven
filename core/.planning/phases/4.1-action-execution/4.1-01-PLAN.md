---
phase: 4.1-action-execution
plan: 01
type: execute
---

<objective>
Implement data registry architecture to capture and store node execution outputs, separating workflow orchestration metadata from the data plane.

Purpose: Create the foundation for node-to-node data flow by establishing a registry that acts as the single source of truth for all node outputs.
Output: WorkflowExecutionContext model with data registry, output capture integrated into all action/control executors
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/4.1-action-execution/4.1-CONTEXT.md

# Prior phase context
@.planning/phases/04-action-executors/04-01-SUMMARY.md
@.planning/phases/04-action-executors/04-02-SUMMARY.md
@.planning/phases/03-temporal-workflow-engine/03-01-SUMMARY.md

# Current implementation
@src/main/kotlin/riven/core/service/workflow/temporal/activities/WorkflowNodeActivitiesImpl.kt
@src/main/kotlin/riven/core/models/workflow/temporal/NodeExecutionResult.kt
@src/main/kotlin/riven/core/models/workflow/WorkflowNode.kt

# Architecture guidance
@.planning/codebase/ARCHITECTURE.md
@.planning/codebase/CONVENTIONS.md

**Tech stack available:**
- Temporal SDK 1.24.1 (workflow orchestration)
- Spring Boot 3.5.3 + Kotlin 2.1.21
- executeAction() pattern from Phase 4.1
- executeControlAction() pattern from Phase 4.2

**Established patterns:**
- Service layer with constructor injection
- Immutable data classes for domain models
- Sealed interfaces for polymorphism
- KotlinLogging for structured logging

**Constraining decisions:**
- Phase 4.1 focuses on individual node execution and data flow (DAG coordination in Phase 5)
- Control plane (workflow metadata) must be separate from data plane (node outputs)
- Build foundation for sequential workflows where nodes access prior results

**From CONTEXT.md:**
Vision: Data Registry as single source of truth for node outputs, separate from Temporal workflow context. Nodes will reference data using template syntax like `{{ steps.fetch_leads.output }}`.

Architectural principle: Separation of concerns between control plane (workflow orchestration) and data plane (registry).
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create WorkflowExecutionContext with data registry</name>
  <files>src/main/kotlin/riven/core/models/workflow/environment/WorkflowExecutionContext.kt, src/main/kotlin/riven/core/models/workflow/environment/NodeExecutionData.kt</files>
  <action>
Create WorkflowExecutionContext model to hold both orchestration metadata and the data registry:

```kotlin
data class WorkflowExecutionContext(
    val workflowExecutionId: UUID,
    val workspaceId: UUID,
    val metadata: Map<String, Any?>,  // Control plane: workflow-level metadata
    val dataRegistry: MutableMap<String, NodeExecutionData>  // Data plane: node outputs
)

data class NodeExecutionData(
    val nodeId: UUID,
    val nodeName: String,  // For template reference: {{ steps.nodeName.output }}
    val status: String,    // COMPLETED, FAILED, SKIPPED
    val output: Map<String, Any?>?,  // Action/control outputs
    val error: String?,
    val executedAt: Instant
)
```

Design notes:
- dataRegistry keys are node names (not UUIDs) for human-readable templates
- NodeExecutionData is immutable once stored
- Separate metadata (orchestration) from dataRegistry (execution results)
- Add comprehensive KDoc explaining separation of concerns and why dataRegistry is mutable (built up during workflow execution)
  </action>
  <verify>./gradlew compileKotlin succeeds, models compile without errors</verify>
  <done>WorkflowExecutionContext model created with clear separation between metadata and dataRegistry, NodeExecutionData model captures all execution output details</done>
</task>

<task type="auto">
  <name>Task 2: Integrate output capture into execution</name>
  <files>src/main/kotlin/riven/core/service/workflow/temporal/activities/WorkflowNodeActivitiesImpl.kt</files>
  <action>
Modify executeNode() to maintain WorkflowExecutionContext and capture outputs:

1. **Initialize context at workflow start:**
   - Create WorkflowExecutionContext with empty dataRegistry
   - Pass context through execution flow (will be needed for input resolution in Plan 2)

2. **Capture outputs in executeAction():**
   - After successful execution, create NodeExecutionData with output map
   - Store in context.dataRegistry using node name as key
   - Include status, timestamp, error (if any)

3. **Capture outputs in executeControlAction():**
   - Same pattern as executeAction()
   - Store conditionResult in output map
   - Log registry state after each capture (debug level)

4. **Handle failures:**
   - Store FAILED status with error message in registry
   - Don't skip failed nodes - capture them for debugging

Implementation notes:
- For now, context won't persist between activity calls (Phase 5 DAG coordinator will handle context passing)
- This establishes the pattern even though single-node execution doesn't benefit yet
- Add TODO comment: "Phase 5 will pass context between nodes for sequential execution"
- Don't change extractConfigField() - it's implemented in Plan 2 as part of input resolution

Logging:
- Debug log: "Captured output for node {nodeName}: {outputKeys}"
- Info log: "Data registry now contains {count} node outputs"
  </action>
  <verify>./gradlew build succeeds, existing tests pass, WorkflowNodeActivitiesImplTest verifies registry contains captured outputs</verify>
  <done>executeAction() and executeControlAction() capture outputs to registry, context maintained during execution, debug logging confirms registry state</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `./gradlew compileKotlin` succeeds without errors
- [ ] `./gradlew test` passes all existing tests
- [ ] WorkflowExecutionContext model has clear KDoc explaining separation of concerns
- [ ] NodeExecutionData captures all relevant output information
- [ ] Registry captures outputs from both action and control nodes
- [ ] Failed executions still store data in registry
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- WorkflowExecutionContext separates metadata (control) from dataRegistry (data)
- NodeExecutionData model is immutable and comprehensive
- executeAction() and executeControlAction() capture outputs after execution
- Registry maintains all node execution data for later access
- Foundation established for sequential workflows (Plan 2 will add input resolution)
</success_criteria>

<output>
After completion, create `.planning/phases/4.1-action-execution/4.1-01-SUMMARY.md`:

# Phase 4.1 Plan 1: Data Registry & Output Capture Summary

**[One-liner describing what shipped]**

## Accomplishments

- [Key outcomes]

## Files Created/Modified

- [List with descriptions]

## Decisions Made

[Key decisions or "None"]

## Issues Encountered

[Problems and resolutions or "None"]

## Next Step

Ready for 4.1-02-PLAN.md (Template-Based Input Resolution)
</output>
