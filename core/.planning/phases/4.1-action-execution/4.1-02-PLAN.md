---
phase: 4.1-action-execution
plan: 02
type: execute
---

<objective>
Implement template-based input resolution system enabling nodes to declaratively reference data from previous nodes using `{{ steps.name.output }}` syntax.

Purpose: Enable sequential workflows where nodes can access outputs from prior nodes without manual wiring, creating the foundation for data flow between nodes.
Output: TemplateParserService, InputResolverService, and integration with node execution flow
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/4.1-action-execution/4.1-CONTEXT.md

# Prior plans in this phase
@.planning/phases/4.1-action-execution/4.1-01-SUMMARY.md

# Current implementation
@src/main/kotlin/riven/core/service/workflow/temporal/activities/WorkflowNodeActivitiesImpl.kt
@src/main/kotlin/riven/core/models/workflow/environment/WorkflowExecutionContext.kt
@src/main/kotlin/riven/core/service/workflow/ExpressionParserService.kt

# Architecture guidance
@.planning/codebase/ARCHITECTURE.md
@.planning/codebase/CONVENTIONS.md

**Tech stack available:**
- WorkflowExecutionContext with dataRegistry (from Plan 1)
- ExpressionParserService pattern (can reference for parser design)
- Kotlin regex and string processing
- Spring Boot service patterns

**Established patterns:**
- Service classes with constructor injection
- Clear error messages for parsing failures
- Comprehensive test coverage for parsers

**Constraining decisions:**
- Template syntax: `{{ path.to.data }}` for consistency with common template engines
- Support property traversal: `{{ steps.fetch_leads.output.email }}`
- Graceful degradation when data not available (return null, don't fail execution)

**From CONTEXT.md:**
Template syntax requirements:
- `{{ steps.step_name.output }}` - access output from previous step
- `{{ loop.loop_name.item.field }}` - access loop iteration data (Phase 5+)
- Nested data access for complex objects
- Enable data aggregation (collect results from multiple prior steps)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement template parser</name>
  <files>src/main/kotlin/riven/core/service/workflow/TemplateParserService.kt, src/test/kotlin/riven/core/service/workflow/TemplateParserServiceTest.kt</files>
  <action>
Create TemplateParserService to parse template strings and extract data paths:

```kotlin
@Service
class TemplateParserService {
    data class ParsedTemplate(
        val isTemplate: Boolean,  // true if contains {{ }}
        val path: List<String>?,  // ["steps", "fetch_leads", "output", "email"]
        val rawValue: String?     // Original string if not a template
    )

    fun parse(input: String): ParsedTemplate {
        // Regex to match {{ path.to.data }}
        // Extract path and split on dots
        // Validate path syntax
        // Return ParsedTemplate
    }

    fun isTemplate(input: String): Boolean {
        // Quick check for {{ }} presence
    }
}
```

Implementation requirements:
- Regex pattern: `\{\{\s*([a-zA-Z0-9_.]+)\s*\}\}` (allows spaces around path)
- Split path on dots: `steps.fetch_leads.output` → `["steps", "fetch_leads", "output"]`
- Validate path segments (no empty segments, no special chars except underscore)
- Support nested paths of arbitrary depth
- Clear error messages for malformed templates (unclosed braces, invalid chars, etc.)

Edge cases to handle:
- Multiple templates in one string: `"Hello {{ user.name }}, you have {{ count }} messages"` (return error - not supported in v1)
- No template: `"static string"` → `isTemplate=false, rawValue="static string"`
- Empty template: `{{ }}` → error
- Leading/trailing spaces: `{{  steps.name  }}` → valid, trim spaces

Tests should cover:
- Valid templates with various path depths
- Static strings (no templates)
- Malformed templates (errors)
- Edge cases (spaces, invalid chars)

Add comprehensive KDoc explaining template syntax and supported patterns.
  </action>
  <verify>./gradlew test --tests TemplateParserServiceTest succeeds with 10+ test cases covering valid/invalid templates</verify>
  <done>TemplateParserService parses template strings correctly, validates syntax, provides clear errors for malformed templates</done>
</task>

<task type="auto">
  <name>Task 2: Create InputResolver service</name>
  <files>src/main/kotlin/riven/core/service/workflow/InputResolverService.kt, src/test/kotlin/riven/core/service/workflow/InputResolverServiceTest.kt</files>
  <action>
Create InputResolverService to fetch data from registry using parsed templates:

```kotlin
@Service
class InputResolverService(
    private val templateParserService: TemplateParserService
) {
    fun resolve(
        templateOrValue: Any,
        context: WorkflowExecutionContext
    ): Any? {
        // If String, parse as template
        // If template, fetch from registry using path
        // If not template, return raw value
        // Handle nested property access
    }

    fun resolveAll(
        config: Map<String, Any?>,
        context: WorkflowExecutionContext
    ): Map<String, Any?> {
        // Recursively resolve all values in config map
        // Preserve non-template values as-is
    }
}
```

Implementation requirements:
1. **Template detection:**
   - Check if value is String
   - Parse with TemplateParserService
   - If not template, return value as-is

2. **Registry lookup:**
   - First segment is "steps" (validate this, error if not)
   - Second segment is node name (lookup in dataRegistry)
   - Remaining segments are property path into output map
   - Example: `steps.fetch_leads.output.email` → `registry["fetch_leads"].output["email"]`

3. **Property traversal:**
   - Navigate nested maps using path segments
   - Handle missing keys gracefully (return null, log warning)
   - Handle type mismatches (trying to access property on non-map)

4. **Error handling:**
   - Node not found in registry: log warning "Node {name} not found in registry", return null
   - Property not found: log debug "Property {path} not found in node {name} output", return null
   - Invalid path (first segment not "steps"): throw IllegalArgumentException
   - Type error (accessing property on primitive): log warning, return null

5. **Recursive resolution:**
   - resolveAll() walks config map recursively
   - Resolves templates in nested maps and lists
   - Preserves structure (maps stay maps, lists stay lists)

Tests should cover:
- Simple template resolution: `{{ steps.node.output }}` → fetches from registry
- Nested property access: `{{ steps.node.output.field.nested }}` → traverses map
- Missing nodes: returns null, logs warning
- Missing properties: returns null, logs debug
- Static values: returned unchanged
- Recursive resolution: resolves templates in nested configs

Add comprehensive KDoc explaining resolution algorithm and error handling strategy.
  </action>
  <verify>./gradlew test --tests InputResolverServiceTest succeeds with 15+ test cases covering resolution patterns and error scenarios</verify>
  <done>InputResolverService resolves templates against registry, handles property traversal, gracefully handles missing data</done>
</task>

<task type="auto">
  <name>Task 3: Integrate input resolution into execution</name>
  <files>src/main/kotlin/riven/core/service/workflow/temporal/activities/WorkflowNodeActivitiesImpl.kt</files>
  <action>
Integrate InputResolverService into node execution flow:

1. **Add InputResolverService dependency:**
   - Constructor injection in WorkflowNodeActivitiesImpl
   - Available for all execution methods

2. **Implement extractConfigField():**
   - Remove NotImplementedError
   - Resolve config before extraction:
     ```kotlin
     private fun extractConfigField(config: Any, fieldName: String, context: WorkflowExecutionContext): Any {
         // Cast config to Map
         // Resolve templates using inputResolverService.resolveAll()
         // Extract field from resolved config
         // Throw clear error if field missing
     }
     ```
   - Add context parameter to signature (needed for resolution)

3. **Update executeActionNode() and executeControlNode():**
   - Pass context to extractConfigField() calls
   - Config values will be auto-resolved before extraction
   - No changes needed to action/control logic (transparent resolution)

4. **Add logging:**
   - Debug log before resolution: "Resolving inputs for node {nodeId}"
   - Debug log after resolution: "Resolved {count} template references"
   - Trace log (if enabled): "Resolved config: {resolvedConfig}" (sanitize sensitive data)

5. **Update method signatures:**
   - Add context parameter to executeActionNode(), executeControlNode()
   - Pass context through call chain from executeNode()

Implementation notes:
- Resolution is transparent to action executors (they receive resolved values)
- Static configs work unchanged (no templates = no resolution)
- Missing data returns null but doesn't fail execution (nodes handle nulls)
- Add TODO comment in executeNode(): "Phase 5 DAG coordinator will populate registry with prior node outputs"

Error handling:
- If resolution throws (invalid template syntax), catch and convert to FAILED status
- Include template parsing error in node execution error message
  </action>
  <verify>./gradlew build succeeds, existing tests pass, new integration test verifies template resolution works end-to-end</verify>
  <done>extractConfigField() implemented with template resolution, integration complete, templates transparently resolved during execution</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `./gradlew compileKotlin` succeeds without errors
- [ ] `./gradlew test` passes all tests including new parser and resolver tests
- [ ] TemplateParserService correctly parses template syntax
- [ ] InputResolverService resolves templates against registry
- [ ] extractConfigField() is fully implemented (no NotImplementedError)
- [ ] Integration test demonstrates template resolution in node execution
- [ ] Missing data handled gracefully (null, not errors)
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- Template parser handles valid/invalid syntax correctly
- Input resolver fetches data from registry using templates
- Property traversal works for nested data access
- extractConfigField() no longer throws NotImplementedError
- Templates transparently resolved during node execution
- Foundation ready for sequential workflows (nodes can access prior outputs)
</success_criteria>

<output>
After completion, create `.planning/phases/4.1-action-execution/4.1-02-SUMMARY.md`:

# Phase 4.1 Plan 2: Template-Based Input Resolution Summary

**[One-liner describing what shipped]**

## Accomplishments

- [Key outcomes]

## Files Created/Modified

- [List with descriptions]

## Decisions Made

[Key decisions or "None"]

## Issues Encountered

[Problems and resolutions or "None"]

## Next Step

Ready for 4.1-03-PLAN.md (Polymorphic Execution Refactor)
</output>
