---
phase: 4.1-action-execution
plan: 03
type: execute
---

<objective>
Refactor workflow execution to use polymorphic node execution, eliminating type switching by having each node type implement its own execute() method.

Purpose: Move from external type routing (when statements in WorkflowNodeActivitiesImpl) to strategy pattern where nodes know how to execute themselves, improving extensibility and maintainability.
Output: Node types implement execute(), simplified WorkflowNodeActivitiesImpl, foundation for future node types (LOOP, SWITCH, etc.)
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/4.1-action-execution/4.1-CONTEXT.md

# Prior plans in this phase
@.planning/phases/4.1-action-execution/4.1-01-SUMMARY.md
@.planning/phases/4.1-action-execution/4.1-02-SUMMARY.md

# Current implementation
@src/main/kotlin/riven/core/service/workflow/temporal/activities/WorkflowNodeActivitiesImpl.kt
@src/main/kotlin/riven/core/models/workflow/WorkflowNode.kt
@src/main/kotlin/riven/core/models/workflow/WorkflowActionNode.kt
@src/main/kotlin/riven/core/models/workflow/WorkflowControlNode.kt
@src/main/kotlin/riven/core/enums/workflow/WorkflowActionType.kt
@src/main/kotlin/riven/core/enums/workflow/WorkflowControlType.kt

# Services available
@src/main/kotlin/riven/core/service/workflow/InputResolverService.kt
@src/main/kotlin/riven/core/models/workflow/environment/WorkflowExecutionContext.kt

# Architecture guidance
@.planning/codebase/ARCHITECTURE.md
@.planning/codebase/CONVENTIONS.md

**Tech stack available:**
- WorkflowExecutionContext with dataRegistry (Plan 1)
- InputResolverService for template resolution (Plan 2)
- Existing executeAction() pattern for error handling
- Spring service injection

**Established patterns:**
- Sealed interfaces for polymorphism
- Strategy pattern (nodes implement behavior)
- Comprehensive error handling with clear messages

**Constraining decisions:**
- WorkflowNode.execute() already exists in interface (defined but not used)
- Must maintain existing action/control logic (move, don't rewrite)
- Future node types (LOOP, SWITCH, PARALLEL) should follow same pattern

**From CONTEXT.md and user feedback:**
Vision: Each node type implements execute(context, inputs). No external type switching.

User note: "We should then look into how other nodes would implement their execution method to handle other crucial workflow logic, like conditions, loops, switching, etc."

Design consideration: The execute() contract must work for:
- Actions (CREATE_ENTITY, HTTP_REQUEST) - execute and return output
- Conditionals (CONDITION) - evaluate and return boolean
- Loops (future) - iterate and aggregate results
- Switch (future) - evaluate and route to branch
- Parallel (future) - spawn concurrent executions
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement execute() on node types</name>
  <files>src/main/kotlin/riven/core/models/workflow/WorkflowNode.kt, src/main/kotlin/riven/core/models/workflow/actions/, src/main/kotlin/riven/core/models/workflow/controls/</files>
  <action>
Refactor node execution to strategy pattern:

1. **Update WorkflowNode interface:**
   ```kotlin
   sealed interface WorkflowNode {
       val id: UUID
       val type: WorkflowNodeType
       val version: Int

       /**
        * Execute this node with given context and resolved inputs.
        *
        * Implementation contract:
        * - Actions: Return output map with action results
        * - Controls: Return map with control result (e.g., conditionResult: Boolean)
        * - Loops: Return map with aggregated iteration results (Phase 5+)
        * - Switch: Return map with selected branch (Phase 5+)
        *
        * @param context Workflow execution context with data registry
        * @param inputs Resolved inputs (templates already converted to values)
        * @param services Dependencies needed for execution (EntityService, WebClient, etc.)
        * @return Execution output map (structure varies by node type)
        * @throws Exception on execution failure (caught by activity implementation)
        */
       fun execute(
           context: WorkflowExecutionContext,
           inputs: Map<String, Any?>,
           services: NodeExecutionServices
       ): Map<String, Any?>
   }

   data class NodeExecutionServices(
       val entityService: EntityService,
       val webClient: WebClient,
       val expressionEvaluatorService: ExpressionEvaluatorService,
       val expressionParserService: ExpressionParserService,
       val entityContextService: EntityContextService
   )
   ```

2. **Create concrete action node implementations:**
   - Create `src/main/kotlin/riven/core/models/workflow/actions/` package
   - Implement concrete classes for each WorkflowActionType:
     - `CreateEntityActionNode` - implements WorkflowActionNode, executes CREATE_ENTITY
     - `UpdateEntityActionNode` - implements WorkflowActionNode, executes UPDATE_ENTITY
     - `DeleteEntityActionNode` - implements WorkflowActionNode, executes DELETE_ENTITY
     - `QueryEntityActionNode` - implements WorkflowActionNode, executes QUERY_ENTITY
     - `HttpRequestActionNode` - implements WorkflowActionNode, executes HTTP_REQUEST

3. **Create concrete control node implementations:**
   - Create `src/main/kotlin/riven/core/models/workflow/controls/` package
   - Implement `ConditionControlNode` - implements WorkflowControlNode, executes CONDITION

4. **Migrate logic from WorkflowNodeActivitiesImpl:**
   - Move executeAction() bodies into respective node execute() methods
   - Preserve all logic (SSRF validation, error handling, logging)
   - Use services parameter to access EntityService, WebClient, etc.
   - Return output map directly (no NodeExecutionResult wrapping in node)

5. **Design for future node types:**
   - Add KDoc examples showing how LOOP, SWITCH, PARALLEL would implement execute()
   - Example LOOP pseudocode in comments:
     ```kotlin
     // Future LoopControlNode.execute():
     // val items = inputs["items"] as List<*>
     // val results = items.map { item ->
     //     // Store item in context for {{ loop.name.item }}
     //     // Execute loop body nodes (Phase 5 DAG coordinator)
     //     // Collect results
     // }
     // return mapOf("iterations" to results.size, "results" to results)
     ```

Implementation notes:
- Keep config parsing in nodes (they know their own structure)
- Error handling stays in activity wrapper (executeAction pattern)
- Nodes are pure logic, no infrastructure concerns
- Services injected via parameter (no direct Spring dependency in nodes)

Add comprehensive KDoc to execute() explaining:
- Contract for different node types
- How inputs are resolved before execute() is called
- How services are injected
- How errors are handled (thrown, caught by activity)
- Examples for action, control, and future node types
  </action>
  <verify>./gradlew compileKotlin succeeds, all concrete node classes implement execute() correctly</verify>
  <done>WorkflowNode.execute() contract defined, concrete action/control nodes implement execute(), logic migrated from WorkflowNodeActivitiesImpl, design supports future node types</done>
</task>

<task type="auto">
  <name>Task 2: Simplify WorkflowNodeActivitiesImpl to use polymorphic execution</name>
  <files>src/main/kotlin/riven/core/service/workflow/temporal/activities/WorkflowNodeActivitiesImpl.kt</files>
  <action>
Refactor WorkflowNodeActivitiesImpl to eliminate type switching:

1. **Remove routing methods:**
   - Delete executeActionNode() method
   - Delete executeControlNode() method
   - Keep executeAction() wrapper for error handling (used by all nodes now)

2. **Simplify executeNode():**
   ```kotlin
   override fun executeNode(nodeId: UUID, workspaceId: UUID): NodeExecutionResult {
       // ... existing setup code ...

       // Fetch node configuration
       val node = workflowNodeRepository.findById(nodeId).orElseThrow { ... }

       // Initialize context
       val context = WorkflowExecutionContext(...)

       // Resolve inputs
       val resolvedInputs = inputResolverService.resolveAll(
           node.config as Map<String, Any?>,
           context
       )

       // Prepare services
       val services = NodeExecutionServices(
           entityService = entityService,
           webClient = webClient,
           expressionEvaluatorService = expressionEvaluatorService,
           expressionParserService = expressionParserService,
           entityContextService = entityContextService
       )

       // Polymorphic execution - no type switching!
       val result = executeAction(nodeId, node.name) {
           node.execute(context, resolvedInputs, services)
       }

       // Capture output in registry
       captureOutput(context, node, result)

       // ... existing completion code ...
   }
   ```

3. **Add helper for output capture:**
   ```kotlin
   private fun captureOutput(
       context: WorkflowExecutionContext,
       node: WorkflowNode,
       result: NodeExecutionResult
   ) {
       val executionData = NodeExecutionData(
           nodeId = node.id,
           nodeName = extractNodeName(node),  // Get name from node config
           status = result.status,
           output = result.output,
           error = result.error,
           executedAt = Instant.now()
       )
       context.dataRegistry[extractNodeName(node)] = executionData
   }
   ```

4. **Update error handling:**
   - executeAction() wrapper already catches exceptions
   - Add logging for polymorphic dispatch: "Executing node via polymorphic execute()"
   - Keep existing error persistence logic

5. **Verify removal:**
   - No when(node.type) statements remain
   - No when(actionNode.subType) statements remain
   - No type-based routing anywhere
   - All execution goes through node.execute()

6. **Update tests:**
   - Update WorkflowNodeActivitiesImplTest to use concrete node instances
   - Verify polymorphic execution works for all node types
   - Add test demonstrating execute() is called (mock verification)

Add comments explaining design:
- "Nodes implement their own execution logic via execute() method"
- "No type switching - polymorphism handles routing"
- "This enables easy addition of new node types (LOOP, SWITCH, PARALLEL, etc.)"

Logging improvements:
- Before execute(): "Executing {nodeType} node: {nodeName} (polymorphic dispatch)"
- After execute(): "Node {nodeName} completed via execute() in {duration}ms"
  </action>
  <verify>./gradlew build succeeds, all tests pass, no type switching remains in WorkflowNodeActivitiesImpl, verify with grep for "when.*type" patterns</verify>
  <done>WorkflowNodeActivitiesImpl simplified to use polymorphic execution, type switching eliminated, tests verify execute() is called correctly</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `./gradlew compileKotlin` succeeds without errors
- [ ] `./gradlew test` passes all tests
- [ ] All action types have concrete node implementations
- [ ] CONDITION control type has concrete node implementation
- [ ] execute() contract supports future node types (documented in KDoc)
- [ ] No type switching remains in WorkflowNodeActivitiesImpl
- [ ] `grep -r "when.*node\.type\|when.*subType" src/` returns no matches in WorkflowNodeActivitiesImpl
- [ ] Tests verify polymorphic execution works
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- WorkflowNode.execute() contract defined and documented
- Concrete nodes implement execute() with migrated logic
- WorkflowNodeActivitiesImpl uses polymorphic dispatch (no type switching)
- Design supports future node types (LOOP, SWITCH, PARALLEL, etc.)
- Code is cleaner and more maintainable
- Foundation ready for Phase 5 DAG coordination
</success_criteria>

<output>
After completion, create `.planning/phases/4.1-action-execution/4.1-03-SUMMARY.md`:

# Phase 4.1 Plan 3: Polymorphic Execution Refactor Summary

**[One-liner describing what shipped]**

## Accomplishments

- [Key outcomes]

## Files Created/Modified

- [List with descriptions]

## Decisions Made

[Key decisions or "None"]

## Issues Encountered

[Problems and resolutions or "None"]

## Next Step

Phase 4.1 complete. Ready for Phase 5: DAG Execution Coordinator.
</output>
