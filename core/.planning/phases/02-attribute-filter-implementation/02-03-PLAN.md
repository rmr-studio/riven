---
phase: 02-attribute-filter-implementation
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/main/kotlin/riven/core/service/entity/query/AttributeFilterVisitor.kt
autonomous: true

must_haves:
  truths:
    - "AND filter combines conditions where all must match"
    - "OR filter combines conditions where any must match"
    - "Empty AND list returns ALWAYS_TRUE (vacuous truth)"
    - "Empty OR list returns ALWAYS_FALSE (no match possible)"
    - "Nested AND/OR at arbitrary depth produces correctly parenthesized SQL"
    - "Nesting depth is enforced with clear error message"
  artifacts:
    - path: "src/main/kotlin/riven/core/service/entity/query/AttributeFilterVisitor.kt"
      provides: "Filter tree traversal producing SqlFragment"
      exports: ["AttributeFilterVisitor"]
  key_links:
    - from: "AttributeFilterVisitor"
      to: "AttributeSqlGenerator"
      via: "Delegates ATTRIBUTE filters to generator"
      pattern: "attributeSqlGenerator\\.generate"
    - from: "AttributeFilterVisitor"
      to: "SqlFragment"
      via: "Uses and()/or() for composition"
      pattern: "\\.and\\(|\\.or\\("
    - from: "AttributeFilterVisitor"
      to: "FilterNestingDepthExceededException"
      via: "Throws when depth limit exceeded"
      pattern: "FilterNestingDepthExceededException"
---

<objective>
Implement the visitor that traverses QueryFilter trees and produces SqlFragment. Handles AND/OR logical combinations with arbitrary nesting while enforcing depth limits. Delegates ATTRIBUTE filters to AttributeSqlGenerator.

Purpose: This visitor ties together the filter model and SQL generation, enabling complex filter expressions to be converted to executable SQL.

Output: AttributeFilterVisitor.kt with recursive filter processing.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-attribute-filter-implementation/02-CONTEXT.md
@.planning/phases/02-attribute-filter-implementation/02-RESEARCH.md

# Prior plan artifacts
@src/main/kotlin/riven/core/service/entity/query/SqlFragment.kt
@src/main/kotlin/riven/core/service/entity/query/ParameterNameGenerator.kt
@src/main/kotlin/riven/core/service/entity/query/AttributeSqlGenerator.kt
@src/main/kotlin/riven/core/exceptions/query/QueryFilterException.kt

# Query models
@src/main/kotlin/riven/core/models/entity/query/QueryFilter.kt
@src/main/kotlin/riven/core/models/entity/query/EntityQuery.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AttributeFilterVisitor with AND/OR handling</name>
  <files>src/main/kotlin/riven/core/service/entity/query/AttributeFilterVisitor.kt</files>
  <action>
Create class `AttributeFilterVisitor` in package `riven.core.service.entity.query`:

**Constructor:**
- `private val attributeSqlGenerator: AttributeSqlGenerator` - For ATTRIBUTE filter handling
- `private val maxNestingDepth: Int = 10` - Configurable depth limit (default 10 per CONTEXT.md)

**Main method:**
```kotlin
fun visit(filter: QueryFilter, paramGen: ParameterNameGenerator): SqlFragment {
    return visitInternal(filter, depth = 0, paramGen)
}
```

**Internal visitor with depth tracking:**
```kotlin
private fun visitInternal(
    filter: QueryFilter,
    depth: Int,
    paramGen: ParameterNameGenerator
): SqlFragment {
    if (depth > maxNestingDepth) {
        throw FilterNestingDepthExceededException(depth, maxNestingDepth)
    }

    return when (filter) {
        is QueryFilter.Attribute -> visitAttribute(filter, paramGen)
        is QueryFilter.Relationship -> visitRelationship(filter, paramGen)
        is QueryFilter.And -> visitAnd(filter.conditions, depth, paramGen)
        is QueryFilter.Or -> visitOr(filter.conditions, depth, paramGen)
    }
}
```

**AND visitor:**
```kotlin
private fun visitAnd(
    conditions: List<QueryFilter>,
    depth: Int,
    paramGen: ParameterNameGenerator
): SqlFragment {
    if (conditions.isEmpty()) {
        return SqlFragment.ALWAYS_TRUE  // Empty AND = vacuous truth
    }

    return conditions
        .map { visitInternal(it, depth + 1, paramGen) }
        .reduce { acc, fragment -> acc.and(fragment) }
}
```

**OR visitor:**
```kotlin
private fun visitOr(
    conditions: List<QueryFilter>,
    depth: Int,
    paramGen: ParameterNameGenerator
): SqlFragment {
    if (conditions.isEmpty()) {
        return SqlFragment.ALWAYS_FALSE  // Empty OR = no match possible
    }

    return conditions
        .map { visitInternal(it, depth + 1, paramGen) }
        .reduce { acc, fragment -> acc.or(fragment) }
}
```

Add KDoc explaining the visitor pattern and depth limit enforcement.
  </action>
  <verify>
`./gradlew compileKotlin` succeeds. AND/OR methods use SqlFragment composition.
  </verify>
  <done>AttributeFilterVisitor exists with visit(), visitAnd(), visitOr() and depth tracking.</done>
</task>

<task type="auto">
  <name>Task 2: Add ATTRIBUTE filter handling with value extraction</name>
  <files>src/main/kotlin/riven/core/service/entity/query/AttributeFilterVisitor.kt</files>
  <action>
Add ATTRIBUTE filter handling to AttributeFilterVisitor:

**Attribute visitor:**
```kotlin
private fun visitAttribute(
    filter: QueryFilter.Attribute,
    paramGen: ParameterNameGenerator
): SqlFragment {
    val value = extractValue(filter.value)
    return attributeSqlGenerator.generate(
        attributeId = filter.attributeId,
        operator = filter.operator,
        value = value,
        paramGen = paramGen
    )
}
```

**Value extraction from FilterValue:**
```kotlin
private fun extractValue(filterValue: FilterValue): Any? {
    return when (filterValue) {
        is FilterValue.Literal -> filterValue.value
        is FilterValue.Template -> {
            // Templates should be resolved by caller before reaching visitor
            // Per CONTEXT.md: "Template expressions are resolved by caller before EntityQueryService invocation"
            throw IllegalStateException(
                "Template expression '${filterValue.expression}' was not resolved before query execution. " +
                "Resolve templates before calling the query service."
            )
        }
    }
}
```

This ensures templates are resolved upstream (workflow layer) before SQL generation.
  </action>
  <verify>
`./gradlew compileKotlin` succeeds. ATTRIBUTE handling extracts literal values, rejects unresolved templates.
  </verify>
  <done>ATTRIBUTE filter handling with literal extraction and template rejection.</done>
</task>

<task type="auto">
  <name>Task 3: Add RELATIONSHIP placeholder and validation</name>
  <files>src/main/kotlin/riven/core/service/entity/query/AttributeFilterVisitor.kt</files>
  <action>
Add RELATIONSHIP placeholder to AttributeFilterVisitor:

**Relationship visitor (placeholder for Phase 3):**
```kotlin
private fun visitRelationship(
    filter: QueryFilter.Relationship,
    paramGen: ParameterNameGenerator
): SqlFragment {
    // Relationship filtering implemented in Phase 3
    // For now, throw clear error so Phase 2 testing can proceed
    throw UnsupportedOperationException(
        "Relationship filters not yet implemented. " +
        "Relationship '${filter.relationshipId}' condition '${filter.condition::class.simpleName}' " +
        "will be supported in Phase 3."
    )
}
```

This allows:
1. Code to compile with exhaustive when expression
2. Clear error message if relationship filter used before Phase 3
3. Easy replacement when Phase 3 implements relationship filtering

Add companion object with DEFAULT_MAX_NESTING_DEPTH constant:
```kotlin
companion object {
    const val DEFAULT_MAX_NESTING_DEPTH = 10
}
```
  </action>
  <verify>
`./gradlew compileKotlin` succeeds. Relationship placeholder throws UnsupportedOperationException with clear message.
  </verify>
  <done>RELATIONSHIP placeholder with clear error message, DEFAULT_MAX_NESTING_DEPTH constant.</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Run `./gradlew compileKotlin` - must pass
2. Verify exhaustive when expression handles all QueryFilter subtypes
3. Verify AND combines with `.and()`, OR combines with `.or()`
4. Verify empty AND returns ALWAYS_TRUE, empty OR returns ALWAYS_FALSE
5. Verify depth limit throws FilterNestingDepthExceededException
6. Verify templates throw IllegalStateException with clear message
</verification>

<success_criteria>
- LOGIC-01: AND filter combines conditions (all must match)
- LOGIC-02: OR filter combines conditions (any must match)
- LOGIC-03: Arbitrary nesting produces correct parenthesization via SqlFragment composition
- Depth limit enforced with clear FilterNestingDepthExceededException
- Template values rejected with clear error (caller responsibility to resolve)
- Relationship filter placeholder ready for Phase 3 implementation
</success_criteria>

<output>
After completion, create `.planning/phases/02-attribute-filter-implementation/02-03-SUMMARY.md`
</output>
