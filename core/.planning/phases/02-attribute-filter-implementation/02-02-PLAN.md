---
phase: 02-attribute-filter-implementation
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/main/kotlin/riven/core/service/entity/query/AttributeSqlGenerator.kt
autonomous: true

must_haves:
  truths:
    - "EQUALS generates GIN-optimized containment SQL for scalar values"
    - "NOT_EQUALS checks key existence before comparing value"
    - "Numeric comparisons use regex-guarded cast to prevent type errors"
    - "Text operators (CONTAINS, STARTS_WITH, ENDS_WITH) use case-insensitive ILIKE"
    - "IS_NULL matches both missing keys and explicit JSON null values"
    - "IN/NOT_IN operators handle empty lists correctly"
    - "All operators return SqlFragment with parameterized values"
  artifacts:
    - path: "src/main/kotlin/riven/core/service/entity/query/AttributeSqlGenerator.kt"
      provides: "SQL generation for all 12 FilterOperator variants"
      exports: ["AttributeSqlGenerator"]
  key_links:
    - from: "AttributeSqlGenerator"
      to: "SqlFragment"
      via: "Every operator returns SqlFragment"
      pattern: "SqlFragment\\("
    - from: "AttributeSqlGenerator"
      to: "ParameterNameGenerator"
      via: "Uses generator for unique parameter names"
      pattern: "paramGen\\.next"
---

<objective>
Implement SQL generation for all 12 FilterOperator variants. Each operator maps to the appropriate PostgreSQL JSONB SQL pattern with GIN-index awareness, correct NULL handling, and type coercion.

Purpose: This is the core attribute filtering logic that converts QueryFilter.Attribute conditions into executable parameterized SQL.

Output: AttributeSqlGenerator.kt with exhaustive operator handling.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-attribute-filter-implementation/02-CONTEXT.md
@.planning/phases/02-attribute-filter-implementation/02-RESEARCH.md

# Prior plan artifacts
@src/main/kotlin/riven/core/service/entity/query/SqlFragment.kt
@src/main/kotlin/riven/core/service/entity/query/ParameterNameGenerator.kt
@src/main/kotlin/riven/core/exceptions/query/QueryFilterException.kt

# Query models
@src/main/kotlin/riven/core/models/entity/query/QueryFilter.kt

# Schema types
@src/main/kotlin/riven/core/models/common/validation/Schema.kt
@src/main/kotlin/riven/core/enums/core/DataType.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AttributeSqlGenerator with equality operators</name>
  <files>src/main/kotlin/riven/core/service/entity/query/AttributeSqlGenerator.kt</files>
  <action>
Create class `AttributeSqlGenerator` in package `riven.core.service.entity.query` with:

**Constructor:**
- `private val objectMapper: ObjectMapper` - For JSON serialization in containment queries

**Main method:**
```kotlin
fun generate(
    attributeId: UUID,
    operator: FilterOperator,
    value: Any?,
    paramGen: ParameterNameGenerator
): SqlFragment
```
Uses exhaustive `when` on FilterOperator, calling specific helper methods.

**EQUALS operator (GIN-optimized):**
- If value is null, delegate to IS_NULL logic
- For scalar values, use containment operator: `e.payload @> :paramName::jsonb`
- Parameter value is JSON object: `{"$attributeId": {"value": $value}}` serialized via objectMapper
- This pattern uses GIN index with `jsonb_path_ops`

**NOT_EQUALS operator (key existence check):**
- Must check key exists first, then compare: `(e.payload ? :keyParam AND (e.payload->:keyParam->>'value') != :valParam)`
- Without key existence check, missing attributes would incorrectly match NOT_EQUALS
- Two parameters: key (attributeId string), value (comparison value string)

Add KDoc explaining GIN index optimization for EQUALS and key existence requirement for NOT_EQUALS.
  </action>
  <verify>
`./gradlew compileKotlin` succeeds. EQUALS uses `@>` containment. NOT_EQUALS uses `?` existence check.
  </verify>
  <done>AttributeSqlGenerator exists with generate() method, EQUALS with containment, NOT_EQUALS with existence check.</done>
</task>

<task type="auto">
  <name>Task 2: Add numeric and text comparison operators</name>
  <files>src/main/kotlin/riven/core/service/entity/query/AttributeSqlGenerator.kt</files>
  <action>
Add methods for numeric comparisons and text operators to AttributeSqlGenerator:

**Numeric comparisons (GREATER_THAN, GREATER_THAN_OR_EQUALS, LESS_THAN, LESS_THAN_OR_EQUALS):**
Use regex-guarded cast to prevent cast errors on non-numeric values:
```sql
CASE
    WHEN (e.payload->:keyParam->>'value') ~ '^-?[0-9]+(\\.[0-9]+)?$'
    THEN (e.payload->:keyParam->>'value')::numeric {operator} :valParam
    ELSE false
END
```
- Per CONTEXT.md: coercion failures result in silent non-match (row excluded, no error)
- `{operator}` is one of: `>`, `>=`, `<`, `<=`
- Parameter: keyParam = attributeId string, valParam = numeric value

**CONTAINS operator (case-insensitive substring):**
```sql
(e.payload->:keyParam->>'value') ILIKE :valParam
```
- valParam wrapped with wildcards: `"%$value%"`
- Per CONTEXT.md: use ILIKE for case-insensitivity

**NOT_CONTAINS operator:**
```sql
NOT ((e.payload->:keyParam->>'value') ILIKE :valParam)
```
- Same wildcard wrapping as CONTAINS

**STARTS_WITH operator:**
```sql
(e.payload->:keyParam->>'value') ILIKE :valParam
```
- valParam: `"$value%"` (wildcard at end only)

**ENDS_WITH operator:**
```sql
(e.payload->:keyParam->>'value') ILIKE :valParam
```
- valParam: `"%$value"` (wildcard at start only)

Add private helper `generateNumericComparison(operator: String, ...)` to reduce duplication.
  </action>
  <verify>
`./gradlew compileKotlin` succeeds. Numeric operators use CASE/regex guard. Text operators use ILIKE.
  </verify>
  <done>Numeric comparisons with regex guard and text operators with ILIKE added to AttributeSqlGenerator.</done>
</task>

<task type="auto">
  <name>Task 3: Add list operators and null handling</name>
  <files>src/main/kotlin/riven/core/service/entity/query/AttributeSqlGenerator.kt</files>
  <action>
Add remaining operators to AttributeSqlGenerator:

**IN operator:**
```sql
(e.payload->:keyParam->>'value') IN (:valsParam)
```
- If values list is empty, return `SqlFragment.ALWAYS_FALSE` (IN with empty list never matches)
- valsParam is the list of values (Spring JDBC handles list expansion)
- Values converted to strings via `map { it?.toString() ?: "" }`

**NOT_IN operator:**
```sql
(e.payload ? :keyParam AND (e.payload->:keyParam->>'value') NOT IN (:valsParam))
```
- If values list is empty, return `SqlFragment.ALWAYS_TRUE` (NOT IN empty list always matches)
- Must check key existence (same pattern as NOT_EQUALS)

**IS_NULL operator:**
```sql
(e.payload->:keyParam->>'value') IS NULL
```
- Per CONTEXT.md: matches both missing keys AND explicit JSON null values
- PostgreSQL's `->>` returns SQL NULL for both cases
- Single parameter: keyParam = attributeId string

**IS_NOT_NULL operator:**
```sql
(e.payload->:keyParam->>'value') IS NOT NULL
```
- Matches entities that have the attribute with a non-null value
- Single parameter: keyParam = attributeId string

Ensure the main `when` expression is exhaustive (all 12 FilterOperator variants covered).
  </action>
  <verify>
`./gradlew compileKotlin` succeeds. Verify exhaustive when expression compiles (Kotlin will error if any operator missing).
  </verify>
  <done>All 12 FilterOperator variants implemented in AttributeSqlGenerator with correct SQL patterns.</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Run `./gradlew compileKotlin` - must pass
2. Verify all 12 operators are handled in the `when` expression
3. Check EQUALS uses `@>` containment for GIN optimization
4. Check numeric operators have regex guard for safe casting
5. Check text operators use ILIKE for case-insensitivity
6. Check NULL handling matches CONTEXT.md semantics
</verification>

<success_criteria>
- ATTR-01 through ATTR-12 requirements addressed (all 12 operators)
- GIN index optimization for EQUALS via containment operator
- Safe numeric comparison with regex-guarded cast
- Case-insensitive text matching with ILIKE
- Correct NULL handling per CONTEXT.md decisions
- All parameterized - no string concatenation of user values
</success_criteria>

<output>
After completion, create `.planning/phases/02-attribute-filter-implementation/02-02-SUMMARY.md`
</output>
