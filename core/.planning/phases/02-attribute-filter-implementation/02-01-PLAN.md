---
phase: 02-attribute-filter-implementation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/main/kotlin/riven/core/service/entity/query/SqlFragment.kt
  - src/main/kotlin/riven/core/service/entity/query/ParameterNameGenerator.kt
  - src/main/kotlin/riven/core/exceptions/query/QueryFilterException.kt
autonomous: true

must_haves:
  truths:
    - "SqlFragment can encapsulate SQL with named parameters"
    - "SqlFragments can be combined with AND/OR logic"
    - "Parameter names are unique across the entire query tree"
    - "Filter errors have descriptive messages including attribute context"
  artifacts:
    - path: "src/main/kotlin/riven/core/service/entity/query/SqlFragment.kt"
      provides: "Immutable SQL fragment container with composition methods"
      exports: ["SqlFragment", "ALWAYS_TRUE", "ALWAYS_FALSE"]
    - path: "src/main/kotlin/riven/core/service/entity/query/ParameterNameGenerator.kt"
      provides: "Unique parameter name generation"
      exports: ["ParameterNameGenerator"]
    - path: "src/main/kotlin/riven/core/exceptions/query/QueryFilterException.kt"
      provides: "Query filter exception hierarchy"
      exports: ["InvalidAttributeReferenceException", "UnsupportedOperatorException", "FilterNestingDepthExceededException"]
  key_links:
    - from: "SqlFragment"
      to: "ParameterNameGenerator"
      via: "Generator provides unique names for fragment parameters"
      pattern: "paramGen\\.next"
---

<objective>
Create the foundational infrastructure for SQL fragment composition: the SqlFragment data class for holding parameterized SQL, ParameterNameGenerator for unique parameter naming, and query-specific exception classes.

Purpose: These primitives enable safe SQL generation by preventing parameter collisions and providing clear error handling. All subsequent operator implementations depend on this foundation.

Output: Three Kotlin files establishing the query SQL generation infrastructure.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-attribute-filter-implementation/02-CONTEXT.md
@.planning/phases/02-attribute-filter-implementation/02-RESEARCH.md

# Existing patterns
@src/main/kotlin/riven/core/service/entity/EntityValidationService.kt
@src/main/kotlin/riven/core/exceptions/NotFoundException.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SqlFragment data class</name>
  <files>src/main/kotlin/riven/core/service/entity/query/SqlFragment.kt</files>
  <action>
Create an immutable data class `SqlFragment` in package `riven.core.service.entity.query` with:

**Properties:**
- `sql: String` - The SQL fragment with named parameter placeholders (e.g., `:param_0`)
- `parameters: Map<String, Any?>` - Named parameters to bind when executing

**Methods:**
- `and(other: SqlFragment): SqlFragment` - Returns new fragment with `(this.sql) AND (other.sql)` and merged parameters
- `or(other: SqlFragment): SqlFragment` - Returns new fragment with `(this.sql) OR (other.sql)` and merged parameters
- `wrap(prefix: String, suffix: String): SqlFragment` - Returns new fragment with `prefix + sql + suffix`, same parameters

**Companion object constants:**
- `ALWAYS_TRUE = SqlFragment("1=1", emptyMap())` - For empty AND conditions
- `ALWAYS_FALSE = SqlFragment("1=0", emptyMap())` - For empty OR conditions

Add KDoc explaining the immutability and composition pattern. Follow existing service class conventions (no @Component annotation - this is a data class).
  </action>
  <verify>
`./gradlew compileKotlin` succeeds with no errors. Check file exists at expected path.
  </verify>
  <done>SqlFragment.kt exists with data class, and/or/wrap methods, and companion constants.</done>
</task>

<task type="auto">
  <name>Task 2: Create ParameterNameGenerator class</name>
  <files>src/main/kotlin/riven/core/service/entity/query/ParameterNameGenerator.kt</files>
  <action>
Create a class `ParameterNameGenerator` in package `riven.core.service.entity.query` with:

**State:**
- `private var counter: Int = 0` - Incrementing counter for uniqueness

**Methods:**
- `fun next(prefix: String): String` - Returns `"${prefix}_${counter++}"` and increments counter
  - Example: first call with "eq" returns "eq_0", second returns "eq_1"

**Usage pattern:**
One generator instance per query tree ensures unique parameter names across all fragments.

Add KDoc explaining usage pattern. This is a plain class, not a Spring bean (new instance per query).
  </action>
  <verify>
`./gradlew compileKotlin` succeeds. Verify file exists and class structure is correct.
  </verify>
  <done>ParameterNameGenerator.kt exists with counter-based unique name generation.</done>
</task>

<task type="auto">
  <name>Task 3: Create query filter exception classes</name>
  <files>src/main/kotlin/riven/core/exceptions/query/QueryFilterException.kt</files>
  <action>
Create exception classes in package `riven.core.exceptions.query`:

**Base class:**
```kotlin
sealed class QueryFilterException(message: String) : RuntimeException(message)
```

**Subclasses:**

1. `InvalidAttributeReferenceException(attributeId: UUID, reason: String)` - Thrown when attribute UUID not found in schema
   - Message format: `"Attribute $attributeId: $reason"`

2. `UnsupportedOperatorException(operator: FilterOperator, attributeLabel: String?, attributeId: UUID, attributeType: DataType)` - Thrown when operator incompatible with attribute type
   - Message format: `"Operator $operator not supported for $attributeType attribute '${attributeLabel ?: attributeId}' (id: $attributeId)"`

3. `FilterNestingDepthExceededException(depth: Int, maxDepth: Int)` - Thrown when AND/OR nesting exceeds limit
   - Message format: `"Filter nesting depth $depth exceeds maximum $maxDepth"`

Import FilterOperator from `riven.core.models.entity.query` and DataType from `riven.core.enums.core`.

Follow existing exception patterns in the codebase (see NotFoundException as example).
  </action>
  <verify>
`./gradlew compileKotlin` succeeds with all imports resolved. Check exception messages are descriptive.
  </verify>
  <done>QueryFilterException.kt exists with sealed base class and three specific exception types.</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Run `./gradlew compileKotlin` - must pass with no errors
2. Verify three files exist in expected locations
3. Check imports resolve correctly (FilterOperator, DataType, UUID)
</verification>

<success_criteria>
- SqlFragment data class compiles with and(), or(), wrap() methods and ALWAYS_TRUE/ALWAYS_FALSE constants
- ParameterNameGenerator produces unique names with incrementing counter
- Three exception types exist with descriptive error messages
- All code follows existing codebase conventions (Kotlin style, KDoc)
</success_criteria>

<output>
After completion, create `.planning/phases/02-attribute-filter-implementation/02-01-SUMMARY.md`
</output>
