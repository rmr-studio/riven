---
phase: 05-query-execution-service
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/main/kotlin/riven/core/exceptions/query/QueryExecutionException.kt
  - src/main/kotlin/riven/core/service/entity/query/EntityQueryAssembler.kt
  - src/main/resources/application.yml
autonomous: true

must_haves:
  truths:
    - "QueryExecutionException wraps DataAccessException with query context"
    - "Data query selects only entity IDs for lean native execution"
    - "Query timeout is configurable via application.yml"
  artifacts:
    - path: "src/main/kotlin/riven/core/exceptions/query/QueryExecutionException.kt"
      provides: "Domain exception for SQL execution failures"
      contains: "class QueryExecutionException"
    - path: "src/main/kotlin/riven/core/service/entity/query/EntityQueryAssembler.kt"
      provides: "Assembler producing SELECT e.id data queries"
      contains: "SELECT e.id"
    - path: "src/main/resources/application.yml"
      provides: "Query timeout configuration"
      contains: "query-timeout"
  key_links:
    - from: "QueryExecutionException"
      to: "QueryFilterException sealed hierarchy"
      via: "same exceptions/query package"
      pattern: "package riven.core.exceptions.query"
---

<objective>
Prepare infrastructure for EntityQueryService: add QueryExecutionException for SQL error wrapping,
modify EntityQueryAssembler to select entity IDs only (not full rows), and add query timeout
configuration to application.yml.

Purpose: Plan 02 (EntityQueryService) depends on these three pieces. The assembler change
implements the locked decision for two-step ID-then-load pattern. The exception and config
are prerequisites for the execution layer.

Output: QueryExecutionException class, modified assembler data query, application.yml with timeout.
</objective>

<execution_context>
@/home/jared/.claude/get-shit-done/workflows/execute-plan.md
@/home/jared/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-query-execution-service/05-CONTEXT.md
@src/main/kotlin/riven/core/exceptions/query/QueryFilterException.kt
@src/main/kotlin/riven/core/service/entity/query/EntityQueryAssembler.kt
@src/main/resources/application.yml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create QueryExecutionException and modify assembler data query</name>
  <files>
    src/main/kotlin/riven/core/exceptions/query/QueryExecutionException.kt
    src/main/kotlin/riven/core/service/entity/query/EntityQueryAssembler.kt
  </files>
  <action>
    1. Create `QueryExecutionException` in `riven.core.exceptions.query` package:
       - Extends `RuntimeException(message, cause)`
       - Constructor takes: `message: String`, `cause: Throwable? = null`
       - This is NOT part of the QueryFilterException sealed hierarchy (it's a SQL execution error, not a filter validation error)
       - Keep it simple -- context details (query info, timeout) are included in the message string by the caller

    2. Modify `EntityQueryAssembler.buildDataQuery()`:
       - Change `append("SELECT e.*\n")` to `append("SELECT e.id\n")`
       - This implements the locked decision: "Two-step approach: native query returns IDs only"
       - No other changes to the assembler -- the method signature, parameters, and count query remain identical
  </action>
  <verify>
    Run `./gradlew compileKotlin` from the project root. Must compile without errors.
    Verify QueryExecutionException exists at the expected path.
    Verify EntityQueryAssembler contains "SELECT e.id" (not "SELECT e.*").
  </verify>
  <done>
    QueryExecutionException class exists in exceptions/query/ package.
    EntityQueryAssembler data query selects e.id only.
    Project compiles successfully.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add query timeout configuration to application.yml</name>
  <files>
    src/main/resources/application.yml
  </files>
  <action>
    Add query timeout configuration under the `riven` namespace in application.yml:

    ```yaml
    riven:
      query:
        timeout-seconds: 10
    ```

    Place this under the existing `riven:` block (after the `workflow:` section).
    This value will be read by EntityQueryService (Plan 02) via `@Value("${riven.query.timeout-seconds}")`.
    The default of 10 seconds matches the CONTEXT decision for "configurable query timeout (e.g., 10s default)".

    Do NOT add a Spring JDBC-level timeout (spring.jdbc.template.query-timeout) because we want
    per-query control via SET statement_timeout, not a global JDBC template setting.
  </action>
  <verify>
    Verify application.yml contains `timeout-seconds: 10` under `riven.query`.
    Run `./gradlew compileKotlin` to ensure no YAML syntax errors break the build.
  </verify>
  <done>
    application.yml has riven.query.timeout-seconds set to 10.
    Project compiles successfully.
  </done>
</task>

</tasks>

<verification>
1. `./gradlew compileKotlin` passes
2. QueryExecutionException exists at `src/main/kotlin/riven/core/exceptions/query/QueryExecutionException.kt`
3. EntityQueryAssembler.buildDataQuery produces `SELECT e.id` not `SELECT e.*`
4. application.yml contains `riven.query.timeout-seconds: 10`
</verification>

<success_criteria>
- QueryExecutionException is available for Plan 02 to wrap DataAccessException
- Assembler data query returns IDs only, enabling two-step ID-then-load pattern
- Query timeout is configurable and defaults to 10 seconds
</success_criteria>

<output>
After completion, create `.planning/phases/05-query-execution-service/05-01-SUMMARY.md`
</output>
