---
phase: 05-query-execution-service
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/main/kotlin/riven/core/service/entity/query/EntityQueryService.kt
autonomous: true

must_haves:
  truths:
    - "EntityQueryService exists as single entry point for entity queries"
    - "Invalid attributeId throws descriptive exception listing valid attributes"
    - "Invalid relationshipId throws descriptive exception listing valid relationships"
    - "Entity type not found throws NotFoundException"
    - "All queries are parameterized with no string concatenation of user input"
    - "Workspace isolation is enforced via workspace_id parameter in assembled SQL"
    - "Data and count queries execute in parallel via coroutines"
    - "Returned entities preserve original SQL ordering (created_at DESC)"
    - "Zero results return EntityQueryResult with empty list and totalCount=0"
    - "SQL execution failures are wrapped in QueryExecutionException"
  artifacts:
    - path: "src/main/kotlin/riven/core/service/entity/query/EntityQueryService.kt"
      provides: "Single entry point for entity query execution"
      exports: ["EntityQueryService"]
      contains: "class EntityQueryService"
  key_links:
    - from: "EntityQueryService"
      to: "EntityTypeRepository"
      via: "constructor injection"
      pattern: "entityTypeRepository"
    - from: "EntityQueryService"
      to: "EntityQueryAssembler"
      via: "constructor injection"
      pattern: "assembler"
    - from: "EntityQueryService"
      to: "NamedParameterJdbcTemplate"
      via: "constructor injection"
      pattern: "jdbcTemplate"
    - from: "EntityQueryService"
      to: "EntityRepository"
      via: "constructor injection for ID-based entity loading"
      pattern: "entityRepository"
    - from: "EntityQueryService.execute()"
      to: "QueryFilterValidator"
      via: "pre-validation before SQL generation"
      pattern: "validator.validate"
    - from: "EntityQueryService.execute()"
      to: "EntityQueryAssembler.assemble()"
      via: "SQL assembly after validation"
      pattern: "assembler.assemble"
---

<objective>
Create EntityQueryService as the single entry point that takes an EntityQuery + workspaceId,
validates all filter references against real entity type schemas, executes assembled SQL via
NamedParameterJdbcTemplate with parallel data/count queries, and returns EntityQueryResult
with typed Entity domain models preserving pagination order.

Purpose: This is the core deliverable of Phase 5 -- the service that ties together all
prior phases (models, attribute SQL gen, relationship SQL gen, query assembly) into an
executable query pipeline with security, validation, and result mapping.

Output: EntityQueryService @Service class in service/entity/query/ package.
</objective>

<execution_context>
@/home/jared/.claude/get-shit-done/workflows/execute-plan.md
@/home/jared/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-query-execution-service/05-CONTEXT.md
@.planning/phases/05-query-execution-service/05-RESEARCH.md
@.planning/phases/04-query-assembly/04-01-SUMMARY.md

@src/main/kotlin/riven/core/models/entity/query/EntityQuery.kt
@src/main/kotlin/riven/core/models/entity/query/EntityQueryResult.kt
@src/main/kotlin/riven/core/models/entity/query/QueryFilter.kt
@src/main/kotlin/riven/core/models/entity/query/QueryPagination.kt
@src/main/kotlin/riven/core/models/entity/query/QueryProjection.kt
@src/main/kotlin/riven/core/models/entity/query/RelationshipCondition.kt
@src/main/kotlin/riven/core/service/entity/query/EntityQueryAssembler.kt
@src/main/kotlin/riven/core/service/entity/query/AssembledQuery.kt
@src/main/kotlin/riven/core/service/entity/query/SqlFragment.kt
@src/main/kotlin/riven/core/service/entity/query/ParameterNameGenerator.kt
@src/main/kotlin/riven/core/service/entity/query/QueryFilterValidator.kt
@src/main/kotlin/riven/core/service/entity/query/AttributeFilterVisitor.kt
@src/main/kotlin/riven/core/exceptions/query/QueryFilterException.kt
@src/main/kotlin/riven/core/exceptions/query/QueryExecutionException.kt
@src/main/kotlin/riven/core/exceptions/ArgumentExceptions.kt
@src/main/kotlin/riven/core/repository/entity/EntityRepository.kt
@src/main/kotlin/riven/core/repository/entity/EntityTypeRepository.kt
@src/main/kotlin/riven/core/entity/entity/EntityEntity.kt
@src/main/kotlin/riven/core/entity/entity/EntityTypeEntity.kt
@src/main/kotlin/riven/core/models/entity/Entity.kt
@src/main/kotlin/riven/core/models/entity/EntityType.kt
@src/main/kotlin/riven/core/models/entity/configuration/EntityRelationshipDefinition.kt
@src/main/resources/application.yml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create EntityQueryService with validation, execution, and result mapping</name>
  <files>
    src/main/kotlin/riven/core/service/entity/query/EntityQueryService.kt
  </files>
  <action>
    Create `EntityQueryService` in `riven.core.service.entity.query` as a Spring `@Service`.

    ## Constructor Dependencies (all via constructor injection)

    - `entityTypeRepository: EntityTypeRepository` -- load entity types for schema validation
    - `entityRepository: EntityRepository` -- load full Entity objects by IDs (second step)
    - `assembler: EntityQueryAssembler` -- assemble SQL from filter tree
    - `validator: QueryFilterValidator` -- pre-validate filter references
    - `jdbcTemplate: NamedParameterJdbcTemplate` -- execute native SQL (auto-configured by Spring Boot from DataSource)
    - `@Value("${riven.query.timeout-seconds}") queryTimeoutSeconds: Long` -- configurable timeout

    ## Public API: Single `execute` method

    ```kotlin
    suspend fun execute(
        query: EntityQuery,
        workspaceId: UUID,
        pagination: QueryPagination = QueryPagination(),
        projection: QueryProjection? = null,
    ): EntityQueryResult
    ```

    Make it a `suspend` function since it uses coroutines internally for parallel execution.

    ## Implementation Flow (inside `execute`)

    ### Step 1: Load Entity Type
    - Load entity type via `entityTypeRepository.findById(query.entityTypeId)`
    - If not found (Optional.empty), throw `NotFoundException("Entity type ${query.entityTypeId} not found")`
    - Extract `entityTypeId = requireNotNull(entityTypeEntity.id)`

    ### Step 2: Validate Filter References (if filter present)
    - Build relationship definitions map: `entityTypeEntity.relationships?.associateBy { it.id } ?: emptyMap()`
    - Build attribute IDs set from schema: `entityTypeEntity.schema.properties?.keys ?: emptySet()`
    - Call `validateFilterReferences(query.filter, attributeIds, relationshipDefinitions, query.maxDepth)`
    - This is a NEW private method (see below) that walks the tree checking attribute/relationship IDs

    ### Step 3: Assemble SQL
    - Create `val paramGen = ParameterNameGenerator()`
    - Call `assembler.assemble(entityTypeId, workspaceId, query.filter, pagination, paramGen)`
    - Returns `AssembledQuery` with dataQuery and countQuery SqlFragments

    ### Step 4: Execute Queries in Parallel
    - Use `coroutineScope { }` block with two `async(Dispatchers.IO) { }` calls
    - Each async block calls a private `executeWithTimeout` method
    - Data query: `executeDataQuery(assembled.dataQuery)` returns `List<UUID>` (entity IDs)
    - Count query: `executeCountQuery(assembled.countQuery)` returns `Long`
    - Await both results

    ### Step 5: Load Entities by IDs
    - If IDs list is empty, return `EntityQueryResult(entities = emptyList(), totalCount = totalCount, hasNextPage = false, projection = projection)`
    - Otherwise, load entities: `entityRepository.findByIdIn(entityIds)` (this returns `List<EntityEntity>`)
    - Convert to domain models: `.map { it.toModel(audit = true, relationships = emptyMap()) }`
    - Re-sort to match original SQL order: create an `idToIndex` map from the ID list, then `sortedBy { idToIndex[it.id] ?: Int.MAX_VALUE }`

    ### Step 6: Build Result
    - `hasNextPage = (pagination.offset + pagination.limit) < totalCount`
    - Return `EntityQueryResult(entities = sortedEntities, totalCount = totalCount, hasNextPage = hasNextPage, projection = projection)`

    ## Private Methods

    ### `validateFilterReferences` (recursive filter tree walker)

    ```kotlin
    private fun validateFilterReferences(
        filter: QueryFilter?,
        attributeIds: Set<UUID>,
        relationshipDefinitions: Map<UUID, EntityRelationshipDefinition>,
        maxDepth: Int,
    )
    ```

    If filter is null, return immediately (no validation needed).

    Two-part validation:

    **Part A: Attribute ID validation** -- walk the filter tree collecting invalid attribute references:
    - For `QueryFilter.Attribute`: check `filter.attributeId in attributeIds`. If not found, create `InvalidAttributeReferenceException(filter.attributeId, "not found on entity type. Valid attributes: [${attributeIds.joinToString()}]")`
    - For `QueryFilter.And` / `QueryFilter.Or`: recurse into each condition
    - For `QueryFilter.Relationship`: recurse into nested filters within conditions (TargetMatches.filter, TargetTypeMatches branch filters)
    - Collect all errors into a mutable list

    **Part B: Relationship validation** -- delegate to existing `QueryFilterValidator.validate()`:
    - Call `validator.validate(filter, relationshipDefinitions, maxDepth)`
    - Append returned errors to the same errors list

    **After both passes:** If errors is non-empty, throw `QueryValidationException(errors)`.

    IMPORTANT: The attribute validation walks the tree itself (not delegated to QueryFilterValidator, which only does relationship validation). This keeps concerns separated -- QueryFilterValidator remains focused on relationship/depth validation, while EntityQueryService adds attribute ID validation on top.

    NOTE on nested relationship filters: For this phase, attribute validation within nested relationship filters (TargetMatches, TargetTypeMatches branches) validates against the SAME entity type's attribute set. Full cross-type validation (loading target entity types and validating their schemas) would require additional entity type lookups based on relationship definitions' entityTypeKeys. This is a known simplification -- the structural validator catches most issues, and invalid attribute IDs in nested contexts will produce SQL that returns zero results rather than errors. Cross-type attribute validation can be enhanced in a future iteration.

    ### `executeDataQuery` (returns List<UUID>)

    ```kotlin
    private fun executeDataQuery(dataQuery: SqlFragment): List<UUID>
    ```

    - Create `MapSqlParameterSource(dataQuery.parameters)`
    - Execute: `jdbcTemplate.queryForList(dataQuery.sql, paramSource, UUID::class.java)`
    - Wrap in try/catch: catch `DataAccessException`, wrap in `QueryExecutionException("Entity query execution failed: ${e.message}", e)`

    ### `executeCountQuery` (returns Long)

    ```kotlin
    private fun executeCountQuery(countQuery: SqlFragment): Long
    ```

    - Create `MapSqlParameterSource(countQuery.parameters)`
    - Execute: `jdbcTemplate.queryForObject(countQuery.sql, paramSource, Long::class.java) ?: 0L`
    - Wrap in try/catch: catch `DataAccessException`, wrap in `QueryExecutionException("Entity count query execution failed: ${e.message}", e)`

    ### `executeWithTimeout` (sets statement_timeout per query)

    Both `executeDataQuery` and `executeCountQuery` should set PostgreSQL statement timeout before execution:

    ```kotlin
    private fun <T> executeWithTimeout(block: () -> T): T {
        jdbcTemplate.jdbcOperations.execute("SET LOCAL statement_timeout = '${queryTimeoutSeconds}s'")
        return block()
    }
    ```

    Actually, `SET LOCAL` only works inside a transaction. Since these are read-only queries not wrapped in @Transactional, use `SET statement_timeout` instead. But better approach: wrap the timeout in the SQL parameter source level. Simplest approach given Spring's NamedParameterJdbcTemplate: just set a JDBC query timeout on the underlying JdbcTemplate.

    REVISED: Instead of SET statement_timeout, configure the timeout on the JdbcTemplate instance in an `@PostConstruct` init method:

    ```kotlin
    @PostConstruct
    fun init() {
        jdbcTemplate.jdbcOperations.let { ops ->
            if (ops is org.springframework.jdbc.core.JdbcTemplate) {
                ops.queryTimeout = queryTimeoutSeconds.toInt()
            }
        }
    }
    ```

    This sets the JDBC Statement.setQueryTimeout which PostgreSQL honors. It applies to all queries executed through this service's template. Since NamedParameterJdbcTemplate is request-scoped via Spring auto-config, this is safe.

    WAIT -- NamedParameterJdbcTemplate is a singleton in Spring. Setting queryTimeout globally would affect ALL queries in the app. To avoid that, create a DEDICATED NamedParameterJdbcTemplate bean for the query service.

    FINAL APPROACH: Don't inject the auto-configured NamedParameterJdbcTemplate. Instead, inject `DataSource` and create a dedicated template in the constructor or init:

    ```kotlin
    @Service
    class EntityQueryService(
        private val entityTypeRepository: EntityTypeRepository,
        private val entityRepository: EntityRepository,
        private val assembler: EntityQueryAssembler,
        private val validator: QueryFilterValidator,
        dataSource: DataSource,
        @Value("\${riven.query.timeout-seconds}") queryTimeoutSeconds: Long,
    ) {
        private val jdbcTemplate: NamedParameterJdbcTemplate

        init {
            val innerTemplate = JdbcTemplate(dataSource)
            innerTemplate.queryTimeout = queryTimeoutSeconds.toInt()
            jdbcTemplate = NamedParameterJdbcTemplate(innerTemplate)
        }
    ```

    This creates a dedicated JdbcTemplate with the query timeout, isolated from the rest of the application.

    ## Import Requirements

    - `org.springframework.jdbc.core.JdbcTemplate`
    - `org.springframework.jdbc.core.namedparam.MapSqlParameterSource`
    - `org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate`
    - `org.springframework.beans.factory.annotation.Value`
    - `org.springframework.dao.DataAccessException`
    - `org.springframework.stereotype.Service`
    - `kotlinx.coroutines.*`
    - `javax.sql.DataSource`
    - `riven.core.exceptions.NotFoundException`
    - `riven.core.exceptions.query.*`
    - `riven.core.models.entity.query.*`
    - `riven.core.repository.entity.EntityRepository`
    - `riven.core.repository.entity.EntityTypeRepository`
    - `riven.core.service.entity.query.*` (assembler, validator, paramgen)

    ## Style Notes

    - Follow existing codebase patterns: constructor injection, no @Autowired
    - Use KDoc on the class and public method
    - Keep private methods focused and short
    - Use io.github.oshai.kotlin-logging for logger: `private val logger = KotlinLogging.logger {}`
    - Log query execution at DEBUG level (SQL preview, parameter count, timing)
    - Log errors at ERROR level with context
  </action>
  <verify>
    Run `./gradlew compileKotlin` from the project root. Must compile without errors.
    Verify EntityQueryService exists at expected path with:
    - @Service annotation
    - Single public `suspend fun execute(...)` method
    - Constructor injection of EntityTypeRepository, EntityRepository, DataSource, EntityQueryAssembler, QueryFilterValidator
    - validateFilterReferences private method
    - executeDataQuery and executeCountQuery private methods
    - Parallel coroutine execution via async(Dispatchers.IO)
    - Re-sort of entities by original ID order
    - QueryExecutionException wrapping of DataAccessException
  </verify>
  <done>
    EntityQueryService exists as single @Service entry point in service/entity/query/.
    Invalid attributeId throws InvalidAttributeReferenceException with valid options listed.
    Invalid relationshipId throws InvalidRelationshipReferenceException (via QueryFilterValidator).
    Entity type not found throws NotFoundException.
    Data and count queries execute in parallel via coroutines on Dispatchers.IO.
    SQL execution failures wrapped in QueryExecutionException.
    Returned entities preserve original SQL ordering via ID-based re-sort.
    Zero results return EntityQueryResult(entities=[], totalCount=0, hasNextPage=false).
    Query timeout configured via dedicated JdbcTemplate instance.
    Project compiles successfully.
  </done>
</task>

</tasks>

<verification>
1. `./gradlew compileKotlin` passes
2. EntityQueryService exists at `src/main/kotlin/riven/core/service/entity/query/EntityQueryService.kt`
3. Service has @Service annotation and is injectable
4. Public execute method accepts EntityQuery, workspaceId, pagination, projection
5. Filter validation checks both attribute IDs and relationship IDs
6. SQL execution uses NamedParameterJdbcTemplate with parameterized queries
7. Parallel coroutine execution for data + count queries
8. Results mapped through EntityRepository.findByIdIn() then re-sorted
9. All 9 EXEC requirements covered:
   - EXEC-01: EntityQueryService in service/entity/query/ (single entry point)
   - EXEC-02: Native PostgreSQL SQL via NamedParameterJdbcTemplate
   - EXEC-03: Parameterized queries via SqlFragment.parameters
   - EXEC-04: workspace_id filtering in assembler base WHERE clause
   - EXEC-05: workspace_id filtering inherited by relationship subqueries via FK + RLS
   - EXEC-06: List<Entity> domain models returned
   - EXEC-07: totalCount returned with every result
   - EXEC-08: Invalid attributeId throws InvalidAttributeReferenceException
   - EXEC-09: Invalid relationshipId throws InvalidRelationshipReferenceException
</verification>

<success_criteria>
- EntityQueryService is the single entry point for executing entity queries
- All filter references are validated up-front before SQL generation
- Queries execute in parallel with configurable timeout
- Results are properly typed Entity domain models with correct pagination metadata
- Phase 5 success criteria are fully satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/05-query-execution-service/05-02-SUMMARY.md`
</output>
