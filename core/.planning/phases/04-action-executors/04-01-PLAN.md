---
phase: 04-action-executors
plan: 01
type: execute
---

<objective>
Implement entity CRUD action executors with extensible pattern for future integrations.

Purpose: Enable workflows to create, update, delete, and query entities while establishing the pattern for adding new action types (Slack, email, AI agents). CRUD actions are the proof-of-concept for an extensible action system.
Output: Working CREATE_ENTITY, UPDATE_ENTITY, DELETE_ENTITY, QUERY_ENTITY executors with clear, reusable patterns that make adding new actions obvious.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-action-executors/04-CONTEXT.md

# Prior phase summaries (dependency chain)
@.planning/phases/01-expression-system-foundation/01-01-SUMMARY.md
@.planning/phases/02-entity-context-integration/02-01-SUMMARY.md
@.planning/phases/03-temporal-workflow-engine/03-01-SUMMARY.md

# Key implementation files
@src/main/kotlin/riven/core/service/workflow/temporal/activities/WorkflowNodeActivitiesImpl.kt
@src/main/kotlin/riven/core/service/entity/EntityService.kt
@src/main/kotlin/riven/core/models/workflow/WorkflowActionNode.kt
@src/main/kotlin/riven/core/enums/workflow/WorkflowActionType.kt

# Codebase patterns
@.planning/codebase/ARCHITECTURE.md
@.planning/codebase/CONVENTIONS.md

**Tech stack available:**
- EntityService with createEntity, updateEntity, deleteEntity methods
- EntityValidationService for schema validation
- ExpressionEvaluatorService and EntityContextService (from Phases 1-2)
- Temporal activity framework (from Phase 3)

**Established patterns:**
- Activity implementation as Spring bean with constructor injection
- Node type routing in WorkflowNodeActivitiesImpl.executeNode()
- Stub implementations currently return mock success

**Constraining decisions:**
- Phase 3: "V1: Sequential node execution, parallel execution deferred to Phase 5"
- Phase 3: "Activity timeout set to 5 minutes with 3 retry attempts max"
- Phase 3: "Node type routing: ACTION (entity CRUD), CONTROL_FLOW (expressions), TRIGGER (skip)"

**Phase 4 vision (from CONTEXT.md):**
- Actions are building blocks with clear inputs and outputs
- Extensibility pattern proven - adding new action types should be obvious
- CRUD + HTTP prove the pattern for future integrations (Slack, email, AI)

**Issues being addressed:** None from prior phases
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extract reusable action execution pattern and implement CREATE/UPDATE entity executors</name>
  <files>src/main/kotlin/riven/core/service/workflow/temporal/activities/WorkflowNodeActivitiesImpl.kt</files>
  <action>
Establish the extensible action execution pattern by creating reusable helper methods, then implement CREATE_ENTITY and UPDATE_ENTITY as the first proof-of-concept.

**1. Extract reusable pattern (make extension obvious):**

Create helper methods that future action types will use:

```kotlin
/**
 * Executes an action with standardized error handling and result building.
 *
 * This is the core pattern for all action executors. To add a new action type:
 * 1. Add enum value to WorkflowActionType
 * 2. Add case to executeActionNode() switch
 * 3. Call executeAction { ... } with your logic
 *
 * Example for future SEND_SLACK_MESSAGE:
 *   WorkflowActionType.SEND_SLACK_MESSAGE -> executeAction(nodeId, "SEND_SLACK_MESSAGE") {
 *     val config = parseActionConfig<SlackMessageConfig>(node.config)
 *     slackClient.sendMessage(config.channel, config.message)
 *     mapOf("messageId" to messageId, "timestamp" to timestamp)
 *   }
 */
private fun executeAction(
    nodeId: UUID,
    actionName: String,
    execution: () -> Map<String, Any?>
): NodeExecutionResult {
    return try {
        val output = execution()
        NodeExecutionResult(
            nodeId = nodeId,
            status = "COMPLETED",
            output = output
        )
    } catch (e: Exception) {
        log.error(e) { "Action $actionName failed: ${e.message}" }
        NodeExecutionResult(
            nodeId = nodeId,
            status = "FAILED",
            error = e.message ?: "Unknown error in $actionName"
        )
    }
}

/**
 * Safely casts and parses action config.
 * Type parameter T should be a data class representing the config structure.
 */
private inline fun <reified T> parseActionConfig(config: Any): T {
    // TODO: Implement based on actual config structure
    // For now, this demonstrates the intended pattern
    throw NotImplementedError("Config parsing to be implemented")
}
```

**2. Implement CREATE_ENTITY using the pattern:**

```kotlin
WorkflowActionType.CREATE_ENTITY -> executeAction(nodeId, "CREATE_ENTITY") {
    // Config parsing - inputs clearly defined
    val config = node.config as WorkflowActionNode
    val entityTypeKey = extractConfigField(config, "entityTypeKey") as String
    val payload = extractConfigField(config, "payload") as Map<String, Any?>

    // Business logic execution
    val entity = entityService.createEntity(workspaceId, entityTypeKey, payload)

    // Output - results clearly defined
    mapOf(
        "entityId" to entity.id,
        "entityTypeKey" to entity.typeKey,
        "payload" to entity.payload
    )
}
```

**3. Implement UPDATE_ENTITY following the same pattern:**

```kotlin
WorkflowActionType.UPDATE_ENTITY -> executeAction(nodeId, "UPDATE_ENTITY") {
    val config = node.config as WorkflowActionNode
    val entityId = UUID.fromString(extractConfigField(config, "entityId") as String)
    val updates = extractConfigField(config, "payload") as Map<String, Any?>

    val entity = entityService.updateEntity(workspaceId, entityId, updates)

    mapOf(
        "entityId" to entity.id,
        "updated" to true,
        "payload" to entity.payload
    )
}
```

**4. Add KDoc comments showing extensibility:**

Add block comment above executeActionNode() explaining:
- How to add a new action type
- Input/output contract expectations
- Error handling patterns
- Example of adding SEND_SLACK_MESSAGE

**What to avoid:**
- DON'T inline error handling in each action - use executeAction() wrapper
- DON'T use type assertions without safe casting
- DON'T bury the extensibility pattern - make it obvious with comments
- DON'T make config parsing action-specific - extract common helpers

**Why:**
- executeAction() wrapper ensures consistent error handling for all actions
- Clear pattern makes adding SEND_SLACK_MESSAGE, SEND_EMAIL obvious
- Comments serve as documentation for future developers
- Reusable helpers reduce boilerplate in future action implementations
  </action>
  <verify>./gradlew compileKotlin passes without errors. Code compiles with clear extensibility pattern visible.</verify>
  <done>
- executeAction() helper method establishes reusable pattern
- CREATE_ENTITY and UPDATE_ENTITY use the pattern
- KDoc comments document how to add new action types
- Input/output contracts clearly defined
- Config parsing extracted to reusable helpers
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement DELETE_ENTITY and QUERY_ENTITY following established pattern</name>
  <files>src/main/kotlin/riven/core/service/workflow/temporal/activities/WorkflowNodeActivitiesImpl.kt</files>
  <action>
Implement remaining CRUD actions using the executeAction() pattern from Task 1, demonstrating consistency.

**1. DELETE_ENTITY following the pattern:**

```kotlin
WorkflowActionType.DELETE_ENTITY -> executeAction(nodeId, "DELETE_ENTITY") {
    val config = node.config as WorkflowActionNode
    val entityId = UUID.fromString(extractConfigField(config, "entityId") as String)

    entityService.deleteEntity(workspaceId, entityId)

    mapOf(
        "entityId" to entityId,
        "deleted" to true
    )
}
```

**2. QUERY_ENTITY following the pattern:**

```kotlin
WorkflowActionType.QUERY_ENTITY -> executeAction(nodeId, "QUERY_ENTITY") {
    val config = node.config as WorkflowActionNode
    val entityId = UUID.fromString(extractConfigField(config, "entityId") as String)

    val entity = entityService.getEntityById(workspaceId, entityId)

    mapOf(
        "entityId" to entity.id,
        "entityTypeKey" to entity.typeKey,
        "payload" to entity.payload,
        "version" to entity.typeVersion
    )
}
```

**3. Add comprehensive logging:**

Each action should log:
- Inputs (entity type, IDs, but NOT sensitive data)
- Outputs (success/failure, entity IDs)
- Execution time for performance monitoring

**4. Verify pattern consistency:**

All four CRUD actions should have identical structure:
- Config parsing
- Service call
- Result building
- Error handling (via executeAction wrapper)

**What to avoid:**
- DON'T implement complex query filtering in v1 - single entity fetch is sufficient
- DON'T return sensitive data in logs or execution records
- DON'T deviate from the executeAction() pattern established in Task 1

**Why:**
- Consistency proves the pattern works for multiple action types
- Future developers see repeated pattern and know what to follow
- Logging provides debugging without exposing sensitive data
  </action>
  <verify>./gradlew compileKotlin passes. All four action types use identical pattern structure.</verify>
  <done>
- DELETE_ENTITY and QUERY_ENTITY follow executeAction() pattern
- All four CRUD actions have identical structure
- Comprehensive logging without sensitive data exposure
- Pattern consistency demonstrates extensibility
  </done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests demonstrating clear input/output contracts</name>
  <files>src/test/kotlin/riven/core/service/workflow/temporal/activities/WorkflowNodeActivitiesImplTest.kt</files>
  <action>
Create tests that document the input/output contract for each action type, serving as both verification and documentation.

**Test structure (demonstrating contracts):**

```kotlin
@Test
fun `CREATE_ENTITY - input contract and output contract`() {
    // GIVEN: Clear input contract
    val config = WorkflowActionNode(
        entityTypeKey = "project",
        payload = mapOf(
            "name" to "New Project",
            "status" to "active"
        )
    )

    // WHEN: Action executes
    val result = activities.executeNode(nodeId, workspaceId)

    // THEN: Clear output contract
    assertThat(result.status).isEqualTo("COMPLETED")
    assertThat(result.output).containsKeys("entityId", "entityTypeKey", "payload")
    assertThat(result.output["entityId"]).isInstanceOf(UUID::class.java)
}
```

**Test all four action types:**

1. CREATE_ENTITY:
   - Success: Valid config → entity created with ID returned
   - Failure: Invalid schema → SchemaValidationException → error in result
   - Failure: Missing entityTypeKey → error with clear message

2. UPDATE_ENTITY:
   - Success: Valid entity ID + payload → entity updated
   - Failure: Entity not found → NotFoundException → error in result
   - Failure: Schema validation fails → error with field details

3. DELETE_ENTITY:
   - Success: Valid entity ID → deleted confirmation
   - Failure: Entity not found → NotFoundException → error in result

4. QUERY_ENTITY:
   - Success: Valid entity ID → full entity data returned
   - Failure: Entity not found → NotFoundException → error in result

**Add test documenting extensibility pattern:**

```kotlin
@Test
fun `Adding new action type follows established pattern - documentation test`() {
    // This test documents how to add SEND_SLACK_MESSAGE
    // 1. Add enum: WorkflowActionType.SEND_SLACK_MESSAGE
    // 2. Add case: WorkflowActionType.SEND_SLACK_MESSAGE -> executeAction(...)
    // 3. Define config: SlackMessageConfig(channel, message)
    // 4. Implement logic: slackClient.sendMessage(...)
    // 5. Return output: mapOf("messageId" to id, "timestamp" to ts)

    // Pattern consistency verified by all CRUD tests using same structure
    assertTrue(true, "Pattern documented for future extensions")
}
```

Use Mockito to mock EntityService, WorkflowNodeRepository, WorkflowExecutionNodeRepository.

**What to avoid:**
- DON'T test EntityService logic (already tested elsewhere)
- DON'T create actual Temporal workflows in unit tests
- DON'T test without clear input/output assertion documentation

**Why:**
- Tests document the contract for future action implementers
- Input/output assertions serve as living documentation
- Mock-based tests run fast and isolate activity layer
  </action>
  <verify>./gradlew test --tests WorkflowNodeActivitiesImplTest passes all tests. Tests clearly document input/output contracts.</verify>
  <done>
- All 4 action types have comprehensive test coverage
- Tests document clear input/output contracts
- Pattern extensibility documented in test comments
- Tests serve as examples for future action types
- Tests run in <5 seconds
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] ./gradlew clean build succeeds without errors
- [ ] ./gradlew test passes all tests including WorkflowNodeActivitiesImplTest
- [ ] All four CRUD action types implemented using consistent executeAction() pattern
- [ ] KDoc comments document how to add new action types
- [ ] Input/output contracts clearly defined and tested
- [ ] No type safety warnings or unsafe casts
- [ ] **Extensibility check:** Can a developer add SEND_SLACK_MESSAGE by reading the code and following the pattern?
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No compilation errors or warnings
- CREATE_ENTITY, UPDATE_ENTITY, DELETE_ENTITY, QUERY_ENTITY fully operational
- **Extensibility pattern established** - executeAction() wrapper, clear config parsing, reusable helpers
- **Pattern documented** - KDoc comments and test examples show how to add new actions
- **Input/output contracts clear** - Tests document what goes in and what comes out
- Entity service integration working end-to-end
  </success_criteria>

<output>
After completion, create `.planning/phases/04-action-executors/04-01-SUMMARY.md`:

# Phase 4 Plan 1: Entity CRUD Action Executors Summary

**[Substantive one-liner - what shipped]**

## Accomplishments

- [Key outcome 1]
- [Key outcome 2]
- **Pattern established:** executeAction() wrapper makes adding new action types obvious

## Files Created/Modified

- `path/to/file.kt` - Description

## Decisions Made

**Extensibility Pattern:**
- executeAction() wrapper for consistent error handling
- Clear config parsing with helper methods
- Input/output contracts documented in code and tests
- KDoc comments show how to add SEND_SLACK_MESSAGE, SEND_EMAIL, etc.

[Other decisions]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Ready for 04-02-PLAN.md (HTTP actions and conditional control flow - further proving extensibility pattern)
</output>
