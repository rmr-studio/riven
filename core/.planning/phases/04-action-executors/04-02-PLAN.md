---
phase: 04-action-executors
plan: 02
type: execute
---

<objective>
Prove extensibility pattern with HTTP actions representing external integrations.

Purpose: Implement HTTP_REQUEST as the exemplar for future third-party integrations (Slack, email, AI agents), demonstrating that the action executor pattern works for external services. Also implement CONDITION control flow to complete branching capabilities.
Output: HTTP_REQUEST proving external integration pattern, CONDITION enabling expression-based branching, both following the established extensibility pattern.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-action-executors/04-CONTEXT.md

# Prior phase summaries
@.planning/phases/01-expression-system-foundation/01-01-SUMMARY.md
@.planning/phases/02-entity-context-integration/02-01-SUMMARY.md
@.planning/phases/03-temporal-workflow-engine/03-01-SUMMARY.md
@.planning/phases/04-action-executors/04-01-SUMMARY.md

# Key implementation files
@src/main/kotlin/riven/core/service/workflow/temporal/activities/WorkflowNodeActivitiesImpl.kt
@src/main/kotlin/riven/core/service/workflow/ExpressionParserService.kt
@src/main/kotlin/riven/core/service/workflow/ExpressionEvaluatorService.kt
@src/main/kotlin/riven/core/service/workflow/EntityContextService.kt
@src/main/kotlin/riven/core/models/workflow/WorkflowControlNode.kt
@src/main/kotlin/riven/core/enums/workflow/WorkflowControlType.kt

# Codebase patterns
@.planning/codebase/ARCHITECTURE.md
@.planning/codebase/CONVENTIONS.md

**Tech stack available:**
- ExpressionParserService and ExpressionEvaluatorService (Phase 1)
- EntityContextService for entity data resolution (Phase 2)
- Spring WebClient (reactive HTTP client) - already in dependencies
- Temporal activity framework (Phase 3)
- **executeAction() pattern from Plan 04-01** - reusable error handling and result building

**Established patterns:**
- Activity implementation as Spring bean with constructor injection
- Expression parsing from SQL-like strings
- Entity context resolution with relationship traversal
- **executeAction() wrapper from 04-01** - consistent error handling for all actions

**Constraining decisions:**
- Phase 1: "SQL-like expression syntax with =, !=, >, <, >=, <=, AND, OR operators"
- Phase 2: "maxDepth default of 3 prevents infinite recursion in relationship traversal"
- Phase 3: "Activity timeout set to 5 minutes with 3 retry attempts max"
- Plan 04-01: "executeAction() wrapper establishes extensibility pattern"

**Phase 4 vision (from CONTEXT.md):**
- HTTP_REQUEST is the bridge to external integrations
- Pattern should make adding Slack, email, AI agent calls obvious
- Actions are building blocks with clear inputs and outputs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement HTTP_REQUEST using executeAction() pattern - proving external integration model</name>
  <files>src/main/kotlin/riven/core/service/workflow/temporal/activities/WorkflowNodeActivitiesImpl.kt, build.gradle.kts</files>
  <action>
Implement HTTP_REQUEST following the executeAction() pattern from Plan 04-01, demonstrating that the pattern works for external service calls (proving future Slack/email integrations will work).

**1. Add WebClient dependency injection:**

```kotlin
@Component
class WorkflowNodeActivitiesImpl(
    // ... existing dependencies
    private val webClientBuilder: WebClient.Builder  // Add this
) : WorkflowNodeActivities {

    private val webClient: WebClient = webClientBuilder.build()
```

**2. Implement HTTP_REQUEST using executeAction() pattern:**

```kotlin
WorkflowActionType.HTTP_REQUEST -> executeAction(nodeId, "HTTP_REQUEST") {
    // Config parsing - clear input contract
    val config = node.config as WorkflowActionNode
    val url = extractConfigField(config, "url") as String
    val method = extractConfigField(config, "method") as String // GET, POST, PUT, DELETE
    val headers = extractConfigField(config, "headers") as? Map<String, String> ?: emptyMap()
    val body = extractConfigField(config, "body") as? Map<String, Any?>

    // Validate URL (prevent SSRF)
    validateUrl(url)

    // Execute HTTP request (external service call)
    val response = webClient
        .method(HttpMethod.valueOf(method))
        .uri(url)
        .headers { h ->
            headers.forEach { (key, value) ->
                if (!isSensitiveHeader(key)) {
                    h.set(key, value)
                }
            }
        }
        .bodyValue(body ?: emptyMap())
        .retrieve()
        .toEntity(String::class.java)
        .block() ?: throw RuntimeException("HTTP request returned null")

    // Log without sensitive data
    log.info { "HTTP_REQUEST: $method $url -> ${response.statusCode}" }

    // Clear output contract
    mapOf(
        "statusCode" to response.statusCode.value(),
        "headers" to response.headers.toSingleValueMap(),
        "body" to response.body,
        "url" to url,
        "method" to method
    )
}
```

**3. Add helper methods for HTTP safety:**

```kotlin
/**
 * Validates URL to prevent SSRF attacks.
 * Blocks localhost, private IPs, metadata endpoints.
 */
private fun validateUrl(url: String) {
    val uri = URI(url)
    val host = uri.host?.lowercase() ?: throw IllegalArgumentException("Invalid URL: no host")

    // Block localhost
    if (host in listOf("localhost", "127.0.0.1", "::1")) {
        throw SecurityException("HTTP_REQUEST cannot target localhost")
    }

    // Block private IP ranges (basic check)
    if (host.startsWith("10.") || host.startsWith("192.168.") || host.startsWith("172.")) {
        throw SecurityException("HTTP_REQUEST cannot target private IP ranges")
    }

    // Block cloud metadata endpoints
    if (host == "169.254.169.254") {
        throw SecurityException("HTTP_REQUEST cannot target cloud metadata endpoints")
    }
}

/**
 * Identifies sensitive headers that should not be logged.
 */
private fun isSensitiveHeader(headerName: String): Boolean {
    return headerName.lowercase() in listOf(
        "authorization",
        "x-api-key",
        "api-key",
        "cookie",
        "set-cookie"
    )
}
```

**4. Add KDoc showing Slack example:**

```kotlin
/**
 * HTTP_REQUEST demonstrates the pattern for external integrations.
 *
 * Future SEND_SLACK_MESSAGE implementation:
 *   WorkflowActionType.SEND_SLACK_MESSAGE -> executeAction(nodeId, "SEND_SLACK_MESSAGE") {
 *     val config = parseActionConfig<SlackMessageConfig>(node.config)
 *
 *     // Call Slack SDK (wraps HTTP)
 *     val response = slackClient.chat.postMessage {
 *       channel(config.channel)
 *       text(config.message)
 *     }
 *
 *     // Return clear output
 *     mapOf(
 *       "messageId" to response.ts,
 *       "channel" to response.channel,
 *       "permalink" to response.permalink
 *     )
 *   }
 *
 * Same pattern applies to:
 * - SEND_EMAIL (email provider SDK)
 * - AI_PROMPT (OpenAI/Anthropic SDK)
 * - SEND_SMS (Twilio SDK)
 */
```

**What to avoid:**
- DON'T skip SSRF validation - external URLs are security risk
- DON'T log Authorization headers or API keys
- DON'T use async WebClient methods - use .block() for synchronous execution
- DON'T deviate from executeAction() pattern established in 04-01

**Why:**
- HTTP_REQUEST is the template for all external integrations (Slack wraps HTTP)
- SSRF prevention is critical for production workflows
- Sensitive header masking prevents credential leakage in logs
- executeAction() pattern proves it works for external calls, not just entity CRUD
  </action>
  <verify>./gradlew compileKotlin passes. HTTP_REQUEST uses executeAction() pattern. SSRF validation present. Sensitive headers masked.</verify>
  <done>
- HTTP_REQUEST implemented using executeAction() pattern
- Config parsing extracts url, method, headers, body with clear input contract
- SSRF validation prevents security issues
- Sensitive headers masked in logs
- Response captured with status code and body
- KDoc comments show how to add SEND_SLACK_MESSAGE
- **Extensibility proven:** Pattern works for external integrations, not just entity operations
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement CONDITION control flow with executeControlAction() pattern variant</name>
  <files>src/main/kotlin/riven/core/service/workflow/temporal/activities/WorkflowNodeActivitiesImpl.kt</files>
  <action>
Implement CONDITION control flow, adapting the executeAction() pattern for control flow nodes (demonstrating pattern flexibility).

**1. Create executeControlAction() variant for control flow:**

```kotlin
/**
 * Executes a control flow node with standardized error handling.
 *
 * Similar to executeAction() but for CONTROL_FLOW nodes.
 * Returns boolean result for branching logic.
 */
private fun executeControlAction(
    nodeId: UUID,
    controlName: String,
    execution: () -> Boolean
): NodeExecutionResult {
    return try {
        val result = execution()
        NodeExecutionResult(
            nodeId = nodeId,
            status = "COMPLETED",
            output = mapOf("conditionResult" to result)
        )
    } catch (e: Exception) {
        log.error(e) { "Control flow $controlName failed: ${e.message}" }
        NodeExecutionResult(
            nodeId = nodeId,
            status = "FAILED",
            error = e.message ?: "Unknown error in $controlName"
        )
    }
}
```

**2. Implement CONDITION using the pattern:**

```kotlin
WorkflowControlType.CONDITION -> executeControlAction(nodeId, "CONDITION") {
    // Config parsing - clear input contract
    val config = node.config as WorkflowControlNode
    val expression = extractConfigField(config, "expression") as String
    val contextEntityId = extractConfigField(config, "contextEntityId") as? String

    // Resolve entity context if provided
    val context: Map<String, Any?> = if (contextEntityId != null) {
        val entityId = UUID.fromString(contextEntityId)
        entityContextService.buildContext(entityId, workspaceId)
    } else {
        emptyMap()
    }

    // Parse and evaluate expression
    val ast = expressionParserService.parse(expression)
    val result = expressionEvaluatorService.evaluate(ast, context)

    // Validate boolean result
    if (result !is Boolean) {
        throw IllegalStateException("CONDITION expression must evaluate to boolean, got: ${result::class.simpleName}")
    }

    log.debug { "CONDITION evaluated: $expression -> $result (context: ${context.keys})" }

    // Return boolean for DAG branching
    result
}
```

**3. Replace stubbed executeControlNode():**

Update executeControlNode() to use the new pattern:

```kotlin
private fun executeControlNode(config: Any, workspaceId: UUID): NodeExecutionResult {
    val controlNode = config as WorkflowControlNode

    return when (controlNode.subType) {
        WorkflowControlType.CONDITION -> {
            // Implemented in Task 2
            executeControlAction(...)
        }
        WorkflowControlType.SWITCH,
        WorkflowControlType.LOOP,
        WorkflowControlType.PARALLEL,
        WorkflowControlType.DELAY,
        WorkflowControlType.MERGE -> {
            log.info { "Skipping ${controlNode.subType} node (not implemented in Phase 4)" }
            NodeExecutionResult(
                nodeId = UUID.randomUUID(),
                status = "SKIPPED",
                output = mapOf("reason" to "${controlNode.subType} not implemented in Phase 4")
            )
        }
    }
}
```

**What to avoid:**
- DON'T return non-boolean results from CONDITION (breaks DAG execution)
- DON'T cache expression parsing (Temporal replay breaks caching)
- DON'T ignore expression parse/evaluation errors - surface them clearly
- DON'T implement SWITCH/LOOP in this task - CONDITION only for Phase 4

**Why:**
- Boolean result is required for DAG branching in Phase 5
- Expression errors indicate workflow configuration bugs (need debugging)
- executeControlAction() variant shows pattern adapts to different node types
- CONDITION is sufficient for Phase 4; other control types deferred
  </action>
  <verify>./gradlew compileKotlin passes. CONDITION uses executeControlAction() pattern. Expression evaluation integrated.</verify>
  <done>
- CONDITION implemented using executeControlAction() pattern variant
- Expression parsing and evaluation integrated
- Boolean result returned for branching
- Error handling for parse errors, evaluation errors, non-boolean results
- Debug logging for expression evaluation
- **Pattern flexibility proven:** executeAction() pattern adapts to control flow nodes
  </done>
</task>

<task type="auto">
  <name>Task 3: Add tests proving pattern works for external integrations and control flow</name>
  <files>src/test/kotlin/riven/core/service/workflow/temporal/activities/WorkflowNodeActivitiesImplTest.kt</files>
  <action>
Create tests that prove the executeAction() pattern works for HTTP (external services) and CONDITION (control flow), documenting the contracts.

**HTTP_REQUEST tests (proving external integration pattern):**

```kotlin
@Test
fun `HTTP_REQUEST - proves external integration pattern works`() {
    // GIVEN: HTTP config (clear input contract)
    val config = WorkflowActionNode(
        url = "https://api.example.com/webhook",
        method = "POST",
        headers = mapOf("Content-Type" to "application/json"),
        body = mapOf("event" to "workflow_complete")
    )

    // Mock WebClient response
    val mockResponse = mockHttpResponse(200, """{"success": true}""")

    // WHEN: HTTP_REQUEST executes
    val result = activities.executeNode(nodeId, workspaceId)

    // THEN: Clear output contract (same as entity actions)
    assertThat(result.status).isEqualTo("COMPLETED")
    assertThat(result.output).containsKeys("statusCode", "headers", "body", "url", "method")
    assertThat(result.output["statusCode"]).isEqualTo(200)

    // EXTENSIBILITY: This proves SEND_SLACK_MESSAGE will work the same way:
    // - Parse config (channel, message)
    // - Call external service (Slack SDK)
    // - Return output (messageId, timestamp)
    // - executeAction() handles errors consistently
}

@Test
fun `HTTP_REQUEST - SSRF protection prevents security issues`() {
    // Validates that external integration pattern includes security
    val localhostConfig = WorkflowActionNode(url = "http://localhost:8080/admin")

    val result = activities.executeNode(nodeId, workspaceId)

    assertThat(result.status).isEqualTo("FAILED")
    assertThat(result.error).contains("cannot target localhost")
}

@Test
fun `HTTP_REQUEST - sensitive headers masked in output`() {
    // Proves external integrations don't leak credentials
    val config = WorkflowActionNode(
        url = "https://api.example.com/endpoint",
        headers = mapOf(
            "Authorization" to "Bearer secret-token",
            "X-Custom-Header" to "visible-value"
        )
    )

    // Verify Authorization not logged but request succeeds
    // (Check logs don't contain "Bearer secret-token")
}
```

**CONDITION tests (proving pattern flexibility):**

```kotlin
@Test
fun `CONDITION - proves pattern works for control flow nodes`() {
    // GIVEN: Condition config (clear input contract)
    val config = WorkflowControlNode(
        expression = "status = 'active' AND count > 10",
        contextEntityId = entityId.toString()
    )

    // Mock entity context
    whenever(entityContextService.buildContext(entityId, workspaceId))
        .thenReturn(mapOf("status" to "active", "count" to 15))

    // WHEN: CONDITION executes
    val result = activities.executeNode(nodeId, workspaceId)

    // THEN: Boolean result for branching
    assertThat(result.status).isEqualTo("COMPLETED")
    assertThat(result.output["conditionResult"]).isEqualTo(true)

    // EXTENSIBILITY: executeControlAction() variant shows pattern adapts
}

@Test
fun `CONDITION - requires boolean result for branching`() {
    // Proves control flow contract enforcement
    val config = WorkflowControlNode(
        expression = "count + 10",  // Returns number, not boolean
        contextEntityId = null
    )

    val result = activities.executeNode(nodeId, workspaceId)

    assertThat(result.status).isEqualTo("FAILED")
    assertThat(result.error).contains("must evaluate to boolean")
}
```

**Add extensibility documentation test:**

```kotlin
@Test
fun `Phase 4 extensibility pattern proven with CRUD, HTTP, and CONDITION`() {
    /**
     * This test documents that the executeAction() pattern works for:
     *
     * 1. Internal operations (CRUD) - Plan 04-01
     * 2. External integrations (HTTP) - Proves Slack/email will work
     * 3. Control flow (CONDITION) - Pattern adapts with executeControlAction()
     *
     * To add SEND_SLACK_MESSAGE:
     * 1. Add enum: WorkflowActionType.SEND_SLACK_MESSAGE
     * 2. Inject SlackClient in constructor (like WebClient)
     * 3. Add case: SEND_SLACK_MESSAGE -> executeAction(nodeId, "SEND_SLACK_MESSAGE") {
     *      val config = parseConfig<SlackConfig>(node.config)
     *      slackClient.postMessage(config.channel, config.message)
     *      mapOf("messageId" to ts, "channel" to channel)
     *    }
     * 4. Test with mocked SlackClient (like HTTP tests)
     *
     * Pattern is proven and documented. Future integrations are straightforward.
     */
    assertTrue(true, "Extensibility pattern validated across internal, external, and control flow")
}
```

Mock dependencies: WebClient (use exchangeFunction), EntityContextService, Expression services.

**What to avoid:**
- DON'T make real HTTP calls (use WireMock or mocked WebClient)
- DON'T test expression parser/evaluator logic (already tested in Phase 1)
- DON'T skip extensibility documentation test - it's the proof

**Why:**
- HTTP tests prove the pattern works for external services (Slack will work)
- CONDITION tests prove pattern flexibility (adapts to control flow)
- Documentation test captures the "this is how you add new actions" guide
  </action>
  <verify>./gradlew test --tests WorkflowNodeActivitiesImplTest passes all tests. Extensibility documented in test comments.</verify>
  <done>
- HTTP_REQUEST tests prove external integration pattern
- SSRF and sensitive header tests prove security
- CONDITION tests prove control flow pattern
- Extensibility documentation test captures "how to add SEND_SLACK_MESSAGE"
- All tests pass with mocked dependencies
- Tests run in <10 seconds
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] ./gradlew clean build succeeds without errors
- [ ] ./gradlew test passes all tests including HTTP and CONDITION tests
- [ ] HTTP_REQUEST uses executeAction() pattern (consistency with CRUD)
- [ ] CONDITION uses executeControlAction() pattern (flexibility demonstrated)
- [ ] SSRF validation prevents security issues
- [ ] Sensitive headers masked in logs
- [ ] **Extensibility proven:** Pattern works for internal (CRUD), external (HTTP), and control flow (CONDITION)
- [ ] KDoc comments show how to add SEND_SLACK_MESSAGE
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No compilation errors or warnings
- HTTP_REQUEST proves pattern works for external integrations
- CONDITION proves pattern adapts to control flow
- **Extensibility pattern proven across three domains:**
  1. Internal operations (CRUD from 04-01)
  2. External integrations (HTTP as Slack/email template)
  3. Control flow (CONDITION with executeControlAction variant)
- Security hardened (SSRF prevention, sensitive data masking)
- Test coverage documents "how to add new action types"
- **Phase 4 complete** - pattern established, future integrations straightforward
  </success_criteria>

<output>
After completion, create `.planning/phases/04-action-executors/04-02-SUMMARY.md`:

# Phase 4 Plan 2: HTTP and Control Flow Action Executors Summary

**[Substantive one-liner - what shipped]**

## Accomplishments

- [Key outcome 1]
- [Key outcome 2]
- **Extensibility proven:** Pattern works for internal (CRUD), external (HTTP), control flow (CONDITION)

## Files Created/Modified

- `path/to/file.kt` - Description

## Decisions Made

**Pattern Validation:**
- HTTP_REQUEST proves external integration pattern (Slack, email, AI will use same approach)
- executeControlAction() variant shows pattern flexibility
- Security hardened with SSRF prevention and sensitive header masking

**Future integrations straightforward:**
- SEND_SLACK_MESSAGE: Add enum, inject SlackClient, use executeAction() wrapper
- SEND_EMAIL: Same pattern with email provider SDK
- AI_PROMPT: Same pattern with OpenAI/Anthropic SDK

[Other decisions]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

**Phase 4 complete.** Extensibility pattern established with clear documentation.

Ready for Phase 5 (DAG Execution Coordinator) - parallel execution and topological sort
</output>
