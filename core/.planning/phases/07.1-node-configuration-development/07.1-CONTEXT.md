# Phase 7.1: Node Configuration Development - Context

**Gathered:** 2026-01-28
**Status:** Ready for planning

<domain>
## Phase Boundary

Define strongly-typed configuration structures for all workflow node types (triggers, actions, controls) that enable frontend configuration and backend validation. This includes typed properties, validation rules, template resolution patterns, and OpenAPI schema generation.

</domain>

<decisions>
## Implementation Decisions

### Config Structure

- **Strongly typed configs**: Each config has explicit Kotlin properties (entityTypeId: UUID, payload: Map). Compile-time safety preferred.
- **Immutable data classes**: Configs use `val` properties. Changes create new instances. Matches existing BlockType pattern.
- **Nullable with defaults**: Optional fields are nullable with sensible defaults: `val timeout: Duration? = Duration.ofSeconds(30)`
- **UUID references**: Entity type references stored as `entityTypeId: UUID` directly. Frontend handles lookup.
- **Flat maps for headers/params**: HTTP configs use `Map<String, String>` for headers and query params. Simple key-value pairs.
- **No display hints in config**: Configs are pure execution data. Display hints (label, icon, color) come from separate registry/schema.
- **Optional retry override**: Each config can optionally include `retryConfig: RetryConfiguration?`. Falls back to workflow default if not specified.
- **Explicit input/output schemas**: Each action config declares `inputSchema` and `outputSchema` properties for validation and documentation.
- **Template map for payloads**: Entity CREATE/UPDATE actions use `payload: Map<String, String>` where values are templates like `{{ steps.x.output.name }}`
- **Flat field structure**: All fields always present (nullable). Validation handles field dependencies, not sealed subtypes.
- **Structured filters for queries**: Query configs use `filters: List<Filter>` with field, operator, value. Sortable and composable.
- **Enabled state separate from config**: Trigger enabled/disabled is workflow-level metadata, not part of trigger config.
- **Per-node optional timeout**: `timeout: Duration?` on each config. Falls back to workflow default, then system default.

### Validation Approach

- **Validate on save**: Validate when node is created/updated via API. Invalid configs rejected immediately.
- **Field-level errors**: Return errors mapped to specific fields: `{ errors: { "payload.name": "Required" } }`
- **Verify entity refs on save**: Validate that `entityTypeId` references exist in workspace. Fail if not found.
- **Validate template syntax on save**: Parse templates to check syntax validity. Don't validate that referenced steps exist (that's cross-node validation).

### Template Syntax

- **Double-brace syntax**: Use `{{ steps.x.output.field }}` matching existing TemplateParserService pattern
- **Align with InputResolverService**: Template resolution should match how InputResolverService and TemplateParserService interact with nodes
- **No transforms in templates**: Keep templates simple - just data access. Transforms happen in dedicated transform nodes.
- **All String fields template-enabled**: Any String property in config can contain templates. Simple, consistent rule.
- **Context namespace for trigger data**: Reference trigger data via `{{ context.trigger.field }}`. Clear separation from step outputs.

### OpenAPI Integration

- **oneOf with discriminator**: Current approach maintained - oneOf list with type/subType discriminator. Standard OpenAPI pattern.
- **Full examples per config**: Each config type includes `@Schema(example = ...)` with realistic values for documentation.
- **OpenAPI only for node types**: Frontend reads available node types from OpenAPI spec. No runtime metadata endpoint.
- **Separate input/output schemas**: Dedicated schemas like `CreateEntityActionInput`, `CreateEntityActionOutput`. Referenced by config schema.

### Claude's Discretion

- Expression storage format for condition configs (string vs AST) - Claude determines based on existing expression system
- Exact validation error message format details
- Schema naming conventions for input/output types
- Order of validation checks

</decisions>

<specifics>
## Specific Ideas

- Templates should align with existing `InputResolverService` and `TemplateParserService` implementation
- Follow existing TODO comments in code that reference "Phase 4.2" for payload handling
- Current configs have `config: JsonObject` placeholders that need proper typing

</specifics>

<deferred>
## Deferred Ideas

None - discussion stayed within phase scope

</deferred>

---

*Phase: 07.1-node-configuration-development*
*Context gathered: 2026-01-28*
