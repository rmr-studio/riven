---
phase: 07.1-node-configuration-development
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/main/kotlin/riven/core/models/workflow/node/config/validation/ConfigValidationError.kt
  - src/main/kotlin/riven/core/models/workflow/node/config/validation/ConfigValidationResult.kt
  - src/main/kotlin/riven/core/service/workflow/ConfigValidationService.kt
autonomous: true

must_haves:
  truths:
    - "Config validation errors are field-level with path and message"
    - "Validation service can validate template syntax"
    - "Validation service validates static values as UUIDs when required"
    - "Validation returns all errors at once (not fail-fast)"
  artifacts:
    - path: "src/main/kotlin/riven/core/models/workflow/node/config/validation/ConfigValidationError.kt"
      provides: "Field-level validation error model"
      exports: ["ConfigValidationError"]
    - path: "src/main/kotlin/riven/core/models/workflow/node/config/validation/ConfigValidationResult.kt"
      provides: "Aggregated validation result"
      exports: ["ConfigValidationResult"]
    - path: "src/main/kotlin/riven/core/service/workflow/ConfigValidationService.kt"
      provides: "Service for validating config fields"
      exports: ["ConfigValidationService"]
  key_links:
    - from: "ConfigValidationService"
      to: "TemplateParserService"
      via: "isTemplate() for template detection"
      pattern: "templateParserService\\.isTemplate"
---

<objective>
Create validation infrastructure for node configuration fields.

Purpose: Enable field-level validation of config properties before save, providing immediate feedback when templates have invalid syntax or required fields are missing.

Output: ConfigValidationError, ConfigValidationResult models and ConfigValidationService with methods to validate templates and UUID fields.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07.1-node-configuration-development/07.1-CONTEXT.md
@.planning/phases/07.1-node-configuration-development/07.1-RESEARCH.md
@src/main/kotlin/riven/core/service/workflow/TemplateParserService.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create validation error and result models</name>
  <files>
    src/main/kotlin/riven/core/models/workflow/node/config/validation/ConfigValidationError.kt
    src/main/kotlin/riven/core/models/workflow/node/config/validation/ConfigValidationResult.kt
  </files>
  <action>
Create the validation package at `models/workflow/node/config/validation/`.

**ConfigValidationError.kt:**
```kotlin
package riven.core.models.workflow.node.config.validation

/**
 * Field-level validation error for workflow node configurations.
 *
 * @property field Dot-notation path to the field (e.g., "payload.name", "entityTypeId")
 * @property message Human-readable error message
 */
data class ConfigValidationError(
    val field: String,
    val message: String
)
```

**ConfigValidationResult.kt:**
```kotlin
package riven.core.models.workflow.node.config.validation

/**
 * Aggregated result of config validation.
 *
 * Contains all validation errors found. Use [isValid] to check if config passes validation.
 */
data class ConfigValidationResult(
    val errors: List<ConfigValidationError> = emptyList()
) {
    val isValid: Boolean get() = errors.isEmpty()

    companion object {
        fun valid(): ConfigValidationResult = ConfigValidationResult(emptyList())

        fun invalid(vararg errors: ConfigValidationError): ConfigValidationResult =
            ConfigValidationResult(errors.toList())
    }
}
```
  </action>
  <verify>
Files exist and compile:
```bash
./gradlew compileKotlin --quiet 2>&1 | head -20
```
  </verify>
  <done>ConfigValidationError and ConfigValidationResult data classes exist in validation package</done>
</task>

<task type="auto">
  <name>Task 2: Create ConfigValidationService</name>
  <files>src/main/kotlin/riven/core/service/workflow/ConfigValidationService.kt</files>
  <action>
Create ConfigValidationService that provides reusable validation methods for config fields.

```kotlin
package riven.core.service.workflow

import org.springframework.stereotype.Service
import riven.core.models.workflow.node.config.validation.ConfigValidationError
import riven.core.models.workflow.node.config.validation.ConfigValidationResult
import java.util.UUID

/**
 * Service for validating workflow node configuration fields.
 *
 * Provides reusable validation methods for common config field patterns:
 * - Template syntax validation (uses TemplateParserService)
 * - UUID validation (for entity type/entity ID references)
 * - Required field validation
 *
 * ## Validation Philosophy
 *
 * Per CONTEXT.md decisions:
 * - Validate on save, not during execution
 * - Return all errors at once (not fail-fast)
 * - Validate template SYNTAX only (not that referenced steps exist)
 * - Verify entity refs exist in workspace is service-layer concern (separate)
 *
 * @see TemplateParserService for template parsing
 */
@Service
class ConfigValidationService(
    private val templateParserService: TemplateParserService
) {

    /**
     * Validates that a string is either a valid template or a valid UUID.
     *
     * Many config fields accept either:
     * - A template like "{{ steps.x.output.id }}"
     * - A static UUID string like "550e8400-e29b-41d4-a716-446655440000"
     *
     * @param value The string value to validate
     * @param fieldPath The field path for error reporting (e.g., "entityTypeId")
     * @return List of validation errors (empty if valid)
     */
    fun validateTemplateOrUuid(value: String?, fieldPath: String): List<ConfigValidationError> {
        if (value == null) {
            return listOf(ConfigValidationError(fieldPath, "Required field cannot be null"))
        }

        if (value.isBlank()) {
            return listOf(ConfigValidationError(fieldPath, "Required field cannot be blank"))
        }

        // Check if it's a template
        if (templateParserService.isTemplate(value)) {
            return validateTemplateSyntax(value, fieldPath)
        }

        // Otherwise validate as UUID
        return try {
            UUID.fromString(value)
            emptyList()
        } catch (e: IllegalArgumentException) {
            listOf(ConfigValidationError(fieldPath, "Must be a valid UUID or template"))
        }
    }

    /**
     * Validates template syntax without checking that referenced steps exist.
     *
     * Per CONTEXT.md: "Validate template syntax on save. Don't validate that
     * referenced steps exist (that's cross-node validation)."
     *
     * @param value The template string to validate
     * @param fieldPath The field path for error reporting
     * @return List of validation errors (empty if valid syntax)
     */
    fun validateTemplateSyntax(value: String, fieldPath: String): List<ConfigValidationError> {
        return try {
            templateParserService.parse(value)
            emptyList()
        } catch (e: IllegalArgumentException) {
            listOf(ConfigValidationError(fieldPath, e.message ?: "Invalid template syntax"))
        }
    }

    /**
     * Validates that a string field is not null or blank when required.
     *
     * @param value The value to check
     * @param fieldPath The field path for error reporting
     * @param required Whether the field is required
     * @return List of validation errors (empty if valid)
     */
    fun validateRequiredString(value: String?, fieldPath: String, required: Boolean = true): List<ConfigValidationError> {
        if (!required) return emptyList()

        return when {
            value == null -> listOf(ConfigValidationError(fieldPath, "Required field cannot be null"))
            value.isBlank() -> listOf(ConfigValidationError(fieldPath, "Required field cannot be blank"))
            else -> emptyList()
        }
    }

    /**
     * Validates a map of template-enabled values (e.g., payload fields).
     *
     * Per CONTEXT.md: "All String fields template-enabled"
     *
     * @param values Map of field name to value
     * @param parentPath Parent path for error reporting (e.g., "payload")
     * @return List of validation errors from all fields
     */
    fun validateTemplateMap(values: Map<String, String>?, parentPath: String): List<ConfigValidationError> {
        if (values == null) return emptyList()

        return values.flatMap { (fieldName, value) ->
            val fieldPath = "$parentPath.$fieldName"

            // All string values in payload can be templates
            if (templateParserService.isTemplate(value)) {
                validateTemplateSyntax(value, fieldPath)
            } else {
                emptyList() // Static values are always valid
            }
        }
    }

    /**
     * Validates an optional Duration field represented as ISO-8601 string or seconds.
     *
     * @param value The duration value (can be seconds as Long, or ISO-8601 string)
     * @param fieldPath The field path for error reporting
     * @return List of validation errors (empty if valid or null)
     */
    fun validateOptionalDuration(value: Any?, fieldPath: String): List<ConfigValidationError> {
        if (value == null) return emptyList()

        return when (value) {
            is Number -> {
                if (value.toLong() < 0) {
                    listOf(ConfigValidationError(fieldPath, "Duration cannot be negative"))
                } else {
                    emptyList()
                }
            }
            is String -> {
                try {
                    java.time.Duration.parse(value)
                    emptyList()
                } catch (e: Exception) {
                    listOf(ConfigValidationError(fieldPath, "Invalid duration format. Use ISO-8601 (e.g., PT30S) or seconds"))
                }
            }
            else -> listOf(ConfigValidationError(fieldPath, "Duration must be a number (seconds) or ISO-8601 string"))
        }
    }

    /**
     * Combines multiple validation results into a single result.
     *
     * @param results Vararg of validation error lists
     * @return Combined ConfigValidationResult
     */
    fun combine(vararg results: List<ConfigValidationError>): ConfigValidationResult {
        val allErrors = results.flatMap { it }
        return ConfigValidationResult(allErrors)
    }
}
```

Key patterns:
- Uses existing TemplateParserService for template detection and parsing
- Does NOT validate that referenced steps exist (single-node validation only)
- Returns all errors at once (not fail-fast)
- Provides reusable validation methods configs can call
  </action>
  <verify>
```bash
./gradlew compileKotlin --quiet 2>&1 | head -20
```
Service compiles and properly injects TemplateParserService.
  </verify>
  <done>ConfigValidationService exists with validateTemplateOrUuid, validateTemplateSyntax, validateTemplateMap, and combine methods</done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests for ConfigValidationService</name>
  <files>src/test/kotlin/riven/core/service/workflow/ConfigValidationServiceTest.kt</files>
  <action>
Create comprehensive unit tests for ConfigValidationService.

```kotlin
package riven.core.service.workflow

import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Nested
import org.junit.jupiter.api.Test

class ConfigValidationServiceTest {

    private lateinit var templateParserService: TemplateParserService
    private lateinit var configValidationService: ConfigValidationService

    @BeforeEach
    fun setUp() {
        templateParserService = TemplateParserService()
        configValidationService = ConfigValidationService(templateParserService)
    }

    @Nested
    inner class ValidateTemplateOrUuid {

        @Test
        fun `returns empty for valid UUID`() {
            val errors = configValidationService.validateTemplateOrUuid(
                "550e8400-e29b-41d4-a716-446655440000",
                "entityTypeId"
            )
            assertTrue(errors.isEmpty())
        }

        @Test
        fun `returns empty for valid template`() {
            val errors = configValidationService.validateTemplateOrUuid(
                "{{ steps.fetch.output.id }}",
                "entityTypeId"
            )
            assertTrue(errors.isEmpty())
        }

        @Test
        fun `returns error for null value`() {
            val errors = configValidationService.validateTemplateOrUuid(null, "entityTypeId")
            assertEquals(1, errors.size)
            assertEquals("entityTypeId", errors[0].field)
            assertTrue(errors[0].message.contains("null"))
        }

        @Test
        fun `returns error for blank value`() {
            val errors = configValidationService.validateTemplateOrUuid("  ", "entityTypeId")
            assertEquals(1, errors.size)
            assertEquals("entityTypeId", errors[0].field)
            assertTrue(errors[0].message.contains("blank"))
        }

        @Test
        fun `returns error for invalid UUID and non-template`() {
            val errors = configValidationService.validateTemplateOrUuid(
                "not-a-uuid",
                "entityTypeId"
            )
            assertEquals(1, errors.size)
            assertEquals("entityTypeId", errors[0].field)
            assertTrue(errors[0].message.contains("UUID"))
        }

        @Test
        fun `returns error for malformed template`() {
            val errors = configValidationService.validateTemplateOrUuid(
                "{{ }}",
                "entityTypeId"
            )
            assertEquals(1, errors.size)
            assertEquals("entityTypeId", errors[0].field)
            assertTrue(errors[0].message.contains("Empty template"))
        }
    }

    @Nested
    inner class ValidateTemplateSyntax {

        @Test
        fun `returns empty for valid simple template`() {
            val errors = configValidationService.validateTemplateSyntax(
                "{{ steps.node.output }}",
                "field"
            )
            assertTrue(errors.isEmpty())
        }

        @Test
        fun `returns empty for valid nested template`() {
            val errors = configValidationService.validateTemplateSyntax(
                "{{ steps.node.output.nested.value }}",
                "field"
            )
            assertTrue(errors.isEmpty())
        }

        @Test
        fun `returns empty for embedded template`() {
            val errors = configValidationService.validateTemplateSyntax(
                "Hello {{ steps.user.output.name }}!",
                "field"
            )
            assertTrue(errors.isEmpty())
        }

        @Test
        fun `returns empty for static value (not a template)`() {
            val errors = configValidationService.validateTemplateSyntax(
                "static value",
                "field"
            )
            assertTrue(errors.isEmpty())
        }

        @Test
        fun `returns error for empty template`() {
            val errors = configValidationService.validateTemplateSyntax("{{ }}", "field")
            assertEquals(1, errors.size)
            assertEquals("field", errors[0].field)
        }

        @Test
        fun `returns error for empty path segment`() {
            val errors = configValidationService.validateTemplateSyntax(
                "{{ steps..output }}",
                "field"
            )
            assertEquals(1, errors.size)
            assertEquals("field", errors[0].field)
        }
    }

    @Nested
    inner class ValidateRequiredString {

        @Test
        fun `returns empty for non-null non-blank value`() {
            val errors = configValidationService.validateRequiredString("value", "field")
            assertTrue(errors.isEmpty())
        }

        @Test
        fun `returns error for null when required`() {
            val errors = configValidationService.validateRequiredString(null, "field", required = true)
            assertEquals(1, errors.size)
            assertEquals("field", errors[0].field)
        }

        @Test
        fun `returns error for blank when required`() {
            val errors = configValidationService.validateRequiredString("  ", "field", required = true)
            assertEquals(1, errors.size)
        }

        @Test
        fun `returns empty for null when not required`() {
            val errors = configValidationService.validateRequiredString(null, "field", required = false)
            assertTrue(errors.isEmpty())
        }
    }

    @Nested
    inner class ValidateTemplateMap {

        @Test
        fun `returns empty for null map`() {
            val errors = configValidationService.validateTemplateMap(null, "payload")
            assertTrue(errors.isEmpty())
        }

        @Test
        fun `returns empty for empty map`() {
            val errors = configValidationService.validateTemplateMap(emptyMap(), "payload")
            assertTrue(errors.isEmpty())
        }

        @Test
        fun `returns empty for valid static values`() {
            val errors = configValidationService.validateTemplateMap(
                mapOf("name" to "John", "email" to "john@example.com"),
                "payload"
            )
            assertTrue(errors.isEmpty())
        }

        @Test
        fun `returns empty for valid templates`() {
            val errors = configValidationService.validateTemplateMap(
                mapOf(
                    "name" to "{{ steps.fetch.output.name }}",
                    "email" to "{{ steps.fetch.output.email }}"
                ),
                "payload"
            )
            assertTrue(errors.isEmpty())
        }

        @Test
        fun `returns error for invalid template in map`() {
            val errors = configValidationService.validateTemplateMap(
                mapOf(
                    "name" to "{{ steps.fetch.output.name }}",
                    "email" to "{{ }}"  // Invalid
                ),
                "payload"
            )
            assertEquals(1, errors.size)
            assertEquals("payload.email", errors[0].field)
        }

        @Test
        fun `returns multiple errors for multiple invalid templates`() {
            val errors = configValidationService.validateTemplateMap(
                mapOf(
                    "name" to "{{ }}",
                    "email" to "{{ steps..output }}"
                ),
                "payload"
            )
            assertEquals(2, errors.size)
            assertTrue(errors.any { it.field == "payload.name" })
            assertTrue(errors.any { it.field == "payload.email" })
        }
    }

    @Nested
    inner class ValidateOptionalDuration {

        @Test
        fun `returns empty for null`() {
            val errors = configValidationService.validateOptionalDuration(null, "timeout")
            assertTrue(errors.isEmpty())
        }

        @Test
        fun `returns empty for positive seconds`() {
            val errors = configValidationService.validateOptionalDuration(30L, "timeout")
            assertTrue(errors.isEmpty())
        }

        @Test
        fun `returns empty for zero seconds`() {
            val errors = configValidationService.validateOptionalDuration(0L, "timeout")
            assertTrue(errors.isEmpty())
        }

        @Test
        fun `returns error for negative seconds`() {
            val errors = configValidationService.validateOptionalDuration(-5L, "timeout")
            assertEquals(1, errors.size)
            assertTrue(errors[0].message.contains("negative"))
        }

        @Test
        fun `returns empty for valid ISO-8601 duration`() {
            val errors = configValidationService.validateOptionalDuration("PT30S", "timeout")
            assertTrue(errors.isEmpty())
        }

        @Test
        fun `returns error for invalid ISO-8601 duration`() {
            val errors = configValidationService.validateOptionalDuration("invalid", "timeout")
            assertEquals(1, errors.size)
            assertTrue(errors[0].message.contains("duration"))
        }
    }

    @Nested
    inner class Combine {

        @Test
        fun `returns valid for empty lists`() {
            val result = configValidationService.combine(emptyList(), emptyList())
            assertTrue(result.isValid)
        }

        @Test
        fun `combines errors from multiple lists`() {
            val errors1 = listOf(
                riven.core.models.workflow.node.config.validation.ConfigValidationError("field1", "error1")
            )
            val errors2 = listOf(
                riven.core.models.workflow.node.config.validation.ConfigValidationError("field2", "error2")
            )

            val result = configValidationService.combine(errors1, errors2)
            assertFalse(result.isValid)
            assertEquals(2, result.errors.size)
        }
    }
}
```

Key test coverage:
- Template vs UUID validation
- Template syntax validation (valid and invalid cases)
- Required string validation
- Template map validation (payload fields)
- Duration validation
- Result combination
  </action>
  <verify>
```bash
./gradlew test --tests "riven.core.service.workflow.ConfigValidationServiceTest" --quiet 2>&1 | tail -10
```
All tests pass.
  </verify>
  <done>Unit tests exist with coverage for all ConfigValidationService methods including edge cases</done>
</task>

</tasks>

<verification>
1. Validation models exist in `models/workflow/node/config/validation/`
2. ConfigValidationService compiles and injects TemplateParserService
3. All unit tests pass
4. `./gradlew compileKotlin` succeeds
</verification>

<success_criteria>
- ConfigValidationError data class with field + message
- ConfigValidationResult data class with errors list and isValid
- ConfigValidationService with template, UUID, and map validation methods
- 15+ unit tests covering all validation methods
- No compilation errors
</success_criteria>

<output>
After completion, create `.planning/phases/07.1-node-configuration-development/07.1-01-SUMMARY.md`
</output>
