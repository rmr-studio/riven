---
phase: 07.1-node-configuration-development
plan: 02
type: execute
wave: 2
depends_on: ["07.1-01"]
files_modified:
  - src/main/kotlin/riven/core/models/workflow/node/config/actions/WorkflowCreateEntityActionConfig.kt
  - src/main/kotlin/riven/core/models/workflow/node/config/actions/WorkflowUpdateEntityActionConfig.kt
  - src/main/kotlin/riven/core/models/workflow/node/config/actions/WorkflowDeleteEntityActionConfig.kt
  - src/main/kotlin/riven/core/models/workflow/node/config/actions/WorkflowQueryEntityActionConfig.kt
autonomous: true

must_haves:
  truths:
    - "CREATE_ENTITY config has typed entityTypeId and payload fields"
    - "UPDATE_ENTITY config has typed entityId and payload fields"
    - "DELETE_ENTITY config has typed entityId field"
    - "QUERY_ENTITY config has typed entityId field"
    - "All entity action configs implement validate() method"
    - "execute() methods properly map payload to entity service"
  artifacts:
    - path: "src/main/kotlin/riven/core/models/workflow/node/config/actions/WorkflowCreateEntityActionConfig.kt"
      provides: "Typed CREATE_ENTITY config with validation"
      contains: "fun validate"
    - path: "src/main/kotlin/riven/core/models/workflow/node/config/actions/WorkflowUpdateEntityActionConfig.kt"
      provides: "Typed UPDATE_ENTITY config with validation"
      contains: "fun validate"
    - path: "src/main/kotlin/riven/core/models/workflow/node/config/actions/WorkflowDeleteEntityActionConfig.kt"
      provides: "Typed DELETE_ENTITY config with validation"
      contains: "fun validate"
    - path: "src/main/kotlin/riven/core/models/workflow/node/config/actions/WorkflowQueryEntityActionConfig.kt"
      provides: "Typed QUERY_ENTITY config with validation"
      contains: "fun validate"
  key_links:
    - from: "WorkflowCreateEntityActionConfig.execute"
      to: "EntityService.saveEntity"
      via: "payload mapping"
      pattern: "SaveEntityRequest.*payload"
---

<objective>
Replace untyped config fields in entity action configs with strongly-typed properties and add validation methods.

Purpose: Enable compile-time safety, IDE support, and save-time validation for entity CRUD action configurations. Fix the TODO comments referencing "Phase 4.2" for payload handling.

Output: Typed entity action configs (CREATE, UPDATE, DELETE, QUERY) with validate() methods and proper payload mapping in execute().
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07.1-node-configuration-development/07.1-CONTEXT.md
@.planning/phases/07.1-node-configuration-development/07.1-RESEARCH.md
@.planning/phases/07.1-node-configuration-development/07.1-01-SUMMARY.md
@src/main/kotlin/riven/core/models/workflow/node/config/actions/WorkflowCreateEntityActionConfig.kt
@src/main/kotlin/riven/core/models/workflow/node/config/actions/WorkflowUpdateEntityActionConfig.kt
@src/main/kotlin/riven/core/models/workflow/node/config/actions/WorkflowDeleteEntityActionConfig.kt
@src/main/kotlin/riven/core/models/workflow/node/config/actions/WorkflowQueryEntityActionConfig.kt
@src/main/kotlin/riven/core/service/workflow/ConfigValidationService.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor WorkflowCreateEntityActionConfig with typed fields</name>
  <files>src/main/kotlin/riven/core/models/workflow/node/config/actions/WorkflowCreateEntityActionConfig.kt</files>
  <action>
Refactor WorkflowCreateEntityActionConfig to replace `config: JsonObject` with typed fields.

Per CONTEXT.md decisions:
- `entityTypeId: String` - Template-enabled UUID field
- `payload: Map<String, String>` - Template map for entity attributes
- Optional `timeout: Long?` (seconds) and `retryConfig` for overrides

Replace the entire file with:

```kotlin
package riven.core.models.workflow.node.config.actions

import com.fasterxml.jackson.annotation.JsonTypeName
import com.fasterxml.jackson.databind.JsonDeserializer
import com.fasterxml.jackson.databind.annotation.JsonDeserialize
import io.swagger.v3.oas.annotations.media.Schema
import riven.core.enums.workflow.WorkflowActionType
import riven.core.enums.workflow.WorkflowNodeType
import riven.core.models.common.json.JsonObject
import riven.core.models.request.entity.SaveEntityRequest
import riven.core.models.workflow.engine.environment.WorkflowExecutionContext
import riven.core.models.workflow.node.NodeServiceProvider
import riven.core.models.workflow.node.config.WorkflowActionConfig
import riven.core.models.workflow.node.config.validation.ConfigValidationResult
import riven.core.models.workflow.node.service
import riven.core.service.entity.EntityService
import riven.core.service.workflow.ConfigValidationService
import java.util.*

/**
 * Configuration for CREATE_ENTITY action nodes.
 *
 * ## Configuration Properties
 *
 * @property entityTypeId UUID of the entity type to create (template-enabled)
 * @property payload Map of attribute values to set (template-enabled values)
 * @property timeoutSeconds Optional timeout override in seconds
 *
 * ## Example Configuration
 *
 * ```json
 * {
 *   "version": 1,
 *   "type": "ACTION",
 *   "subType": "CREATE_ENTITY",
 *   "entityTypeId": "{{ steps.get_type.output.typeId }}",
 *   "payload": {
 *     "name": "{{ steps.fetch_data.output.clientName }}",
 *     "email": "client@example.com"
 *   }
 * }
 * ```
 *
 * ## Output
 *
 * Returns map with:
 * - `entityId`: UUID of created entity
 * - `entityTypeId`: UUID of entity type
 * - `payload`: Map of entity data
 *
 * Templates are resolved before execute() is called.
 */
@Schema(
    name = "WorkflowCreateEntityActionConfig",
    description = "Configuration for CREATE_ENTITY action nodes."
)
@JsonTypeName("workflow_create_entity_action")
@JsonDeserialize(using = JsonDeserializer.None::class)
data class WorkflowCreateEntityActionConfig(
    override val version: Int = 1,

    @Schema(
        description = "UUID of the entity type to create. Can be a static UUID or template like {{ steps.x.output.typeId }}",
        example = "550e8400-e29b-41d4-a716-446655440000"
    )
    val entityTypeId: String,

    @Schema(
        description = "Map of attribute key to value. Values can be templates like {{ steps.x.output.field }}",
        example = """{"name": "{{ steps.fetch.output.name }}", "email": "user@example.com"}"""
    )
    val payload: Map<String, String> = emptyMap(),

    @Schema(
        description = "Optional timeout override in seconds",
        example = "30",
        nullable = true
    )
    val timeoutSeconds: Long? = null

) : WorkflowActionConfig {

    override val type: WorkflowNodeType
        get() = WorkflowNodeType.ACTION

    override val subType: WorkflowActionType
        get() = WorkflowActionType.CREATE_ENTITY

    /**
     * Validates this configuration.
     *
     * Checks:
     * - entityTypeId is valid UUID or template
     * - payload values have valid template syntax
     * - timeout is non-negative if provided
     *
     * @param validationService Service for validation utilities
     * @return Validation result with any errors
     */
    fun validate(validationService: ConfigValidationService): ConfigValidationResult {
        return validationService.combine(
            validationService.validateTemplateOrUuid(entityTypeId, "entityTypeId"),
            validationService.validateTemplateMap(payload, "payload"),
            validationService.validateOptionalDuration(timeoutSeconds, "timeoutSeconds")
        )
    }

    override fun execute(
        context: WorkflowExecutionContext,
        inputs: JsonObject,
        services: NodeServiceProvider
    ): JsonObject {
        // Extract resolved inputs
        val resolvedEntityTypeId = UUID.fromString(inputs["entityTypeId"] as String)
        val resolvedPayload = inputs["payload"] as? Map<*, *> ?: emptyMap<String, Any?>()

        // Get EntityService on-demand
        val entityService = services.service<EntityService>()

        // Map resolved payload to proper format
        // InputResolverService resolves templates, so values should already be resolved
        @Suppress("UNCHECKED_CAST")
        val entityPayload = resolvedPayload.mapKeys { (key, _) ->
            // Keys are UUID strings representing attribute IDs
            UUID.fromString(key as String)
        }.mapValues { (_, value) ->
            // Values are the resolved data
            value
        }

        // Create entity via EntityService
        val saveRequest = SaveEntityRequest(
            id = null, // New entity
            payload = entityPayload,
            icon = null
        )

        val result = entityService.saveEntity(
            context.workspaceId,
            resolvedEntityTypeId,
            saveRequest
        )

        // Return output
        return mapOf(
            "entityId" to result.entity?.id,
            "entityTypeId" to result.entity?.typeId,
            "payload" to result.entity?.payload
        )
    }
}
```

Key changes:
- Replaced `name: String, config: JsonObject` with typed `entityTypeId`, `payload`, `timeoutSeconds`
- Added `validate()` method using ConfigValidationService
- Fixed execute() to properly map payload (resolves TODO)
- Added comprehensive @Schema annotations for OpenAPI
  </action>
  <verify>
```bash
./gradlew compileKotlin --quiet 2>&1 | head -20
```
  </verify>
  <done>WorkflowCreateEntityActionConfig has typed fields (entityTypeId, payload, timeoutSeconds) and validate() method</done>
</task>

<task type="auto">
  <name>Task 2: Refactor WorkflowUpdateEntityActionConfig with typed fields</name>
  <files>src/main/kotlin/riven/core/models/workflow/node/config/actions/WorkflowUpdateEntityActionConfig.kt</files>
  <action>
Refactor WorkflowUpdateEntityActionConfig to replace `config: Map<String, Any?>` with typed fields.

Replace the entire file with:

```kotlin
package riven.core.models.workflow.node.config.actions

import com.fasterxml.jackson.annotation.JsonTypeName
import com.fasterxml.jackson.databind.JsonDeserializer
import com.fasterxml.jackson.databind.annotation.JsonDeserialize
import io.swagger.v3.oas.annotations.media.Schema
import riven.core.enums.workflow.WorkflowActionType
import riven.core.enums.workflow.WorkflowNodeType
import riven.core.models.request.entity.SaveEntityRequest
import riven.core.models.workflow.engine.environment.WorkflowExecutionContext
import riven.core.models.workflow.node.NodeServiceProvider
import riven.core.models.workflow.node.config.WorkflowActionConfig
import riven.core.models.workflow.node.config.validation.ConfigValidationResult
import riven.core.models.workflow.node.service
import riven.core.service.entity.EntityService
import riven.core.service.workflow.ConfigValidationService
import java.util.*

/**
 * Configuration for UPDATE_ENTITY action nodes.
 *
 * ## Configuration Properties
 *
 * @property entityId UUID of the entity to update (template-enabled)
 * @property payload Map of attribute values to update (template-enabled values)
 * @property timeoutSeconds Optional timeout override in seconds
 *
 * ## Example Configuration
 *
 * ```json
 * {
 *   "version": 1,
 *   "type": "ACTION",
 *   "subType": "UPDATE_ENTITY",
 *   "entityId": "{{ steps.find_client.output.entityId }}",
 *   "payload": {
 *     "status": "active",
 *     "lastContacted": "{{ steps.get_timestamp.output.now }}"
 *   }
 * }
 * ```
 *
 * ## Output
 *
 * Returns map with:
 * - `entityId`: UUID of updated entity
 * - `updated`: Boolean true
 * - `payload`: Map of entity data after update
 */
@Schema(
    name = "WorkflowUpdateEntityActionConfig",
    description = "Configuration for UPDATE_ENTITY action nodes."
)
@JsonTypeName("workflow_update_entity_action")
@JsonDeserialize(using = JsonDeserializer.None::class)
data class WorkflowUpdateEntityActionConfig(
    override val version: Int = 1,

    @Schema(
        description = "UUID of the entity to update. Can be a static UUID or template like {{ steps.x.output.entityId }}",
        example = "550e8400-e29b-41d4-a716-446655440000"
    )
    val entityId: String,

    @Schema(
        description = "Map of attribute key to value to update. Values can be templates.",
        example = """{"status": "active", "name": "{{ steps.fetch.output.name }}"}"""
    )
    val payload: Map<String, String> = emptyMap(),

    @Schema(
        description = "Optional timeout override in seconds",
        nullable = true
    )
    val timeoutSeconds: Long? = null

) : WorkflowActionConfig {

    override val type: WorkflowNodeType
        get() = WorkflowNodeType.ACTION

    override val subType: WorkflowActionType
        get() = WorkflowActionType.UPDATE_ENTITY

    /**
     * Validates this configuration.
     *
     * Checks:
     * - entityId is valid UUID or template
     * - payload values have valid template syntax
     * - timeout is non-negative if provided
     */
    fun validate(validationService: ConfigValidationService): ConfigValidationResult {
        return validationService.combine(
            validationService.validateTemplateOrUuid(entityId, "entityId"),
            validationService.validateTemplateMap(payload, "payload"),
            validationService.validateOptionalDuration(timeoutSeconds, "timeoutSeconds")
        )
    }

    override fun execute(
        context: WorkflowExecutionContext,
        inputs: Map<String, Any?>,
        services: NodeServiceProvider
    ): Map<String, Any?> {
        // Extract resolved inputs
        val resolvedEntityId = UUID.fromString(inputs["entityId"] as String)
        val resolvedPayload = inputs["payload"] as? Map<*, *> ?: emptyMap<String, Any?>()

        // Get EntityService on-demand
        val entityService = services.service<EntityService>()

        // Get existing entity to determine type
        val existingEntity = entityService.getEntity(resolvedEntityId)

        // Map resolved payload to proper format
        @Suppress("UNCHECKED_CAST")
        val entityPayload = resolvedPayload.mapKeys { (key, _) ->
            UUID.fromString(key as String)
        }.mapValues { (_, value) ->
            value
        }

        // Update entity via EntityService
        val saveRequest = SaveEntityRequest(
            id = resolvedEntityId,
            payload = entityPayload,
            icon = null
        )

        val result = entityService.saveEntity(
            context.workspaceId,
            existingEntity.typeId,
            saveRequest
        )

        // Return output
        return mapOf(
            "entityId" to result.entity?.id,
            "updated" to true,
            "payload" to result.entity?.payload
        )
    }
}
```

Key changes:
- Replaced `name: String, config: Map<String, Any?>` with typed `entityId`, `payload`, `timeoutSeconds`
- Added `validate()` method
- Fixed payload mapping (resolves TODO)
  </action>
  <verify>
```bash
./gradlew compileKotlin --quiet 2>&1 | head -20
```
  </verify>
  <done>WorkflowUpdateEntityActionConfig has typed fields (entityId, payload, timeoutSeconds) and validate() method</done>
</task>

<task type="auto">
  <name>Task 3: Refactor WorkflowDeleteEntityActionConfig and WorkflowQueryEntityActionConfig</name>
  <files>
    src/main/kotlin/riven/core/models/workflow/node/config/actions/WorkflowDeleteEntityActionConfig.kt
    src/main/kotlin/riven/core/models/workflow/node/config/actions/WorkflowQueryEntityActionConfig.kt
  </files>
  <action>
Refactor both DELETE and QUERY configs to use typed fields.

**WorkflowDeleteEntityActionConfig.kt:**

```kotlin
package riven.core.models.workflow.node.config.actions

import com.fasterxml.jackson.annotation.JsonTypeName
import com.fasterxml.jackson.databind.JsonDeserializer
import com.fasterxml.jackson.databind.annotation.JsonDeserialize
import io.github.oshai.kotlinlogging.KotlinLogging
import io.swagger.v3.oas.annotations.media.Schema
import riven.core.enums.workflow.WorkflowActionType
import riven.core.enums.workflow.WorkflowNodeType
import riven.core.models.workflow.engine.environment.WorkflowExecutionContext
import riven.core.models.workflow.node.NodeServiceProvider
import riven.core.models.workflow.node.config.WorkflowActionConfig
import riven.core.models.workflow.node.config.validation.ConfigValidationResult
import riven.core.models.workflow.node.service
import riven.core.service.entity.EntityService
import riven.core.service.workflow.ConfigValidationService
import java.util.*

private val log = KotlinLogging.logger {}

/**
 * Configuration for DELETE_ENTITY action nodes.
 *
 * ## Configuration Properties
 *
 * @property entityId UUID of the entity to delete (template-enabled)
 * @property timeoutSeconds Optional timeout override in seconds
 *
 * ## Example Configuration
 *
 * ```json
 * {
 *   "version": 1,
 *   "type": "ACTION",
 *   "subType": "DELETE_ENTITY",
 *   "entityId": "{{ steps.find_expired_record.output.entityId }}"
 * }
 * ```
 *
 * ## Output
 *
 * Returns map with:
 * - `entityId`: UUID of deleted entity
 * - `deleted`: Boolean true
 * - `impactedEntities`: Int count of entities affected by cascade
 */
@Schema(
    name = "WorkflowDeleteEntityActionConfig",
    description = "Configuration for DELETE_ENTITY action nodes."
)
@JsonTypeName("workflow_delete_entity_action")
@JsonDeserialize(using = JsonDeserializer.None::class)
data class WorkflowDeleteEntityActionConfig(
    override val version: Int = 1,

    @Schema(
        description = "UUID of the entity to delete. Can be a static UUID or template.",
        example = "550e8400-e29b-41d4-a716-446655440000"
    )
    val entityId: String,

    @Schema(
        description = "Optional timeout override in seconds",
        nullable = true
    )
    val timeoutSeconds: Long? = null

) : WorkflowActionConfig {

    override val type: WorkflowNodeType
        get() = WorkflowNodeType.ACTION

    override val subType: WorkflowActionType
        get() = WorkflowActionType.DELETE_ENTITY

    /**
     * Validates this configuration.
     *
     * Checks:
     * - entityId is valid UUID or template
     * - timeout is non-negative if provided
     */
    fun validate(validationService: ConfigValidationService): ConfigValidationResult {
        return validationService.combine(
            validationService.validateTemplateOrUuid(entityId, "entityId"),
            validationService.validateOptionalDuration(timeoutSeconds, "timeoutSeconds")
        )
    }

    override fun execute(
        context: WorkflowExecutionContext,
        inputs: Map<String, Any?>,
        services: NodeServiceProvider
    ): Map<String, Any?> {
        // Extract resolved inputs
        val resolvedEntityId = UUID.fromString(inputs["entityId"] as String)

        log.info { "Deleting entity: $resolvedEntityId in workspace: ${context.workspaceId}" }

        // Get EntityService on-demand
        val entityService = services.service<EntityService>()

        // Execute deletion via EntityService
        val result = entityService.deleteEntities(
            context.workspaceId,
            listOf(resolvedEntityId)
        )

        // Check for errors
        if (result.error != null) {
            throw IllegalStateException("Failed to delete entity: ${result.error}")
        }

        // Return output
        return mapOf(
            "entityId" to resolvedEntityId,
            "deleted" to true,
            "impactedEntities" to (result.updatedEntities?.size ?: 0)
        )
    }
}
```

**WorkflowQueryEntityActionConfig.kt:**

```kotlin
package riven.core.models.workflow.node.config.actions

import com.fasterxml.jackson.annotation.JsonTypeName
import com.fasterxml.jackson.databind.JsonDeserializer
import com.fasterxml.jackson.databind.annotation.JsonDeserialize
import io.github.oshai.kotlinlogging.KotlinLogging
import io.swagger.v3.oas.annotations.media.Schema
import riven.core.enums.workflow.WorkflowActionType
import riven.core.enums.workflow.WorkflowNodeType
import riven.core.models.workflow.engine.environment.WorkflowExecutionContext
import riven.core.models.workflow.node.NodeServiceProvider
import riven.core.models.workflow.node.config.WorkflowActionConfig
import riven.core.models.workflow.node.config.validation.ConfigValidationResult
import riven.core.models.workflow.node.service
import riven.core.service.entity.EntityService
import riven.core.service.workflow.ConfigValidationService
import java.util.*

private val log = KotlinLogging.logger {}

/**
 * Configuration for QUERY_ENTITY action nodes.
 *
 * ## Configuration Properties
 *
 * @property entityId UUID of the entity to query (template-enabled)
 * @property timeoutSeconds Optional timeout override in seconds
 *
 * ## Example Configuration
 *
 * ```json
 * {
 *   "version": 1,
 *   "type": "ACTION",
 *   "subType": "QUERY_ENTITY",
 *   "entityId": "{{ steps.previous_step.output.clientId }}"
 * }
 * ```
 *
 * ## Output
 *
 * Returns map with complete entity data:
 * - `entityId`: UUID of entity
 * - `entityTypeId`: UUID of entity type
 * - `payload`: Map of entity attribute values
 * - `icon`: String icon identifier
 * - `identifier`: String unique identifier
 * - `createdAt`: Timestamp
 * - `updatedAt`: Timestamp
 */
@Schema(
    name = "WorkflowQueryEntityActionConfig",
    description = "Configuration for QUERY_ENTITY action nodes."
)
@JsonTypeName("workflow_query_entity_action")
@JsonDeserialize(using = JsonDeserializer.None::class)
data class WorkflowQueryEntityActionConfig(
    override val version: Int = 1,

    @Schema(
        description = "UUID of the entity to query. Can be a static UUID or template.",
        example = "550e8400-e29b-41d4-a716-446655440000"
    )
    val entityId: String,

    @Schema(
        description = "Optional timeout override in seconds",
        nullable = true
    )
    val timeoutSeconds: Long? = null

) : WorkflowActionConfig {

    override val type: WorkflowNodeType
        get() = WorkflowNodeType.ACTION

    override val subType: WorkflowActionType
        get() = WorkflowActionType.QUERY_ENTITY

    /**
     * Validates this configuration.
     *
     * Checks:
     * - entityId is valid UUID or template
     * - timeout is non-negative if provided
     */
    fun validate(validationService: ConfigValidationService): ConfigValidationResult {
        return validationService.combine(
            validationService.validateTemplateOrUuid(entityId, "entityId"),
            validationService.validateOptionalDuration(timeoutSeconds, "timeoutSeconds")
        )
    }

    override fun execute(
        context: WorkflowExecutionContext,
        inputs: Map<String, Any?>,
        services: NodeServiceProvider
    ): Map<String, Any?> {
        // Extract resolved inputs
        val resolvedEntityId = UUID.fromString(inputs["entityId"] as String)

        log.info { "Querying entity: $resolvedEntityId" }

        // Get EntityService on-demand
        val entityService: EntityService = services.service<EntityService>()

        // Fetch entity via EntityService
        val entity = entityService.getEntity(resolvedEntityId)

        // Verify workspace access
        if (entity.workspaceId != context.workspaceId) {
            throw SecurityException("Entity $resolvedEntityId does not belong to workspace ${context.workspaceId}")
        }

        // Return output with full entity data
        return mapOf(
            "entityId" to entity.id,
            "entityTypeId" to entity.typeId,
            "payload" to entity.payload,
            "icon" to entity.icon,
            "identifier" to entity.identifier,
            "createdAt" to entity.createdAt,
            "updatedAt" to entity.updatedAt
        )
    }
}
```

Key changes for both:
- Replaced `name: String, config: Map<String, Any?>` with typed `entityId` (and `timeoutSeconds`)
- Added `validate()` method using ConfigValidationService
- Simplified since DELETE/QUERY don't need payload
  </action>
  <verify>
```bash
./gradlew compileKotlin --quiet 2>&1 | head -20
```
  </verify>
  <done>WorkflowDeleteEntityActionConfig and WorkflowQueryEntityActionConfig have typed entityId field and validate() method</done>
</task>

</tasks>

<verification>
1. All entity action configs compile without errors
2. Each config has typed fields instead of `config: Map/JsonObject`
3. Each config has `validate()` method
4. execute() methods properly handle resolved inputs
5. `./gradlew compileKotlin` succeeds
</verification>

<success_criteria>
- WorkflowCreateEntityActionConfig: entityTypeId, payload, timeoutSeconds fields
- WorkflowUpdateEntityActionConfig: entityId, payload, timeoutSeconds fields
- WorkflowDeleteEntityActionConfig: entityId, timeoutSeconds fields
- WorkflowQueryEntityActionConfig: entityId, timeoutSeconds fields
- All configs have validate() method returning ConfigValidationResult
- Payload mapping works correctly in execute() methods
- No compilation errors
</success_criteria>

<output>
After completion, create `.planning/phases/07.1-node-configuration-development/07.1-02-SUMMARY.md`
</output>
