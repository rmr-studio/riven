# Phase 7.1: Node Configuration Development - Research

**Researched:** 2026-01-28
**Domain:** Kotlin data class configuration, validation, OpenAPI schema generation
**Confidence:** HIGH

## Summary

This research investigates how to implement strongly-typed configuration structures for workflow node types within the existing Riven codebase. The codebase already has a working foundation with partial implementations that need completion.

**Key findings:**
1. Existing pattern uses sealed interfaces with concrete data classes (proven with 10+ configs)
2. Current configs have `config: JsonObject` / `config: Map<String, Any?>` placeholders needing replacement with typed properties
3. Template parsing is mature via `TemplateParserService` with `{{ steps.x.output.field }}` syntax
4. Expression parsing uses AST via `ExpressionParserService` with SQL-like syntax
5. OpenAPI generation already handles polymorphism via `WorkflowNodeConfigSchemaCustomizer`
6. Validation can leverage existing `SchemaService` patterns

**Primary recommendation:** Extend existing config classes by replacing untyped `config` fields with strongly-typed properties, add validation methods to each config, and update deserializer to handle new fields.

## Standard Stack

The established libraries/tools for this domain (all already in use):

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| Jackson Databind | (via Spring Boot) | JSON serialization/deserialization | Standard Spring Boot JSON handling |
| SpringDoc OpenAPI | 2.8.6 | OpenAPI schema generation | Already integrated, handles polymorphism |
| networknt JSON Schema | Draft 2019-09 | Payload validation | Already used by SchemaService |
| Kotlin Data Classes | 2.1.21 | Immutable config structures | Idiomatic Kotlin, matches codebase pattern |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| swagger-annotations | (via SpringDoc) | Schema documentation | Adding @Schema annotations to configs |
| jakarta.validation | (via Spring Boot) | Bean validation | Optional: could use for simple validations |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Manual validation | jakarta.validation | Bean validation is simpler but less flexible for cross-field logic |
| Jackson polymorphism | kotlinx.serialization | Jackson already deeply integrated, no benefit to switching |

**No installation required** - all libraries already present in `build.gradle.kts`.

## Architecture Patterns

### Existing Config Class Structure
```
models/workflow/node/config/
├── WorkflowNodeConfig.kt          # Sealed interface, entry point
├── WorkflowActionConfig.kt        # Action category interface
├── WorkflowTriggerConfig.kt       # Trigger category interface
├── WorkflowControlConfig.kt       # Control flow category interface
├── WorkflowUtilityConfig.kt       # Utility category interface
├── WorkflowParseConfig.kt         # Parse category interface
├── WorkflowFunctionConfig.kt      # Standalone function config
├── actions/                       # Concrete action configs
│   ├── WorkflowCreateEntityActionConfig.kt
│   ├── WorkflowUpdateEntityActionConfig.kt
│   ├── WorkflowDeleteEntityActionConfig.kt
│   ├── WorkflowQueryEntityActionConfig.kt
│   └── WorkflowHttpRequestActionConfig.kt
├── controls/
│   └── WorkflowConditionControlConfig.kt
└── trigger/
    ├── WorkflowScheduleTriggerConfig.kt
    ├── WorkflowEntityEventTriggerConfig.kt
    ├── WorkflowWebhookTriggerConfig.kt
    └── WorkflowFunctionTriggerConfig.kt
```

### Pattern 1: Current Config Pattern (To Be Replaced)
**What:** Configs use untyped `config: Map<String, Any?>` or `config: JsonObject`
**Issue:** No compile-time safety, validation at runtime only
**Example (Current):**
```kotlin
// Source: WorkflowQueryEntityActionConfig.kt line 54-58
data class WorkflowQueryEntityActionConfig(
    override val version: Int,
    val name: String,
    val config: Map<String, Any?>  // PROBLEM: Untyped
) : WorkflowActionConfig
```

### Pattern 2: Target Config Pattern (Strongly Typed)
**What:** Replace untyped maps with explicit properties
**When to use:** All node configurations
**Example:**
```kotlin
// Target pattern based on CONTEXT.md decisions
data class WorkflowQueryEntityActionConfig(
    override val version: Int,
    // Strongly typed execution properties
    val entityId: String,           // Template-enabled: "{{ steps.x.output.id }}"
    // Optional overrides
    val timeout: Duration? = null,
    val retryConfig: RetryConfiguration? = null
) : WorkflowActionConfig
```

### Pattern 3: Trigger Config Pattern (Already Typed)
**What:** Some triggers already have typed properties
**Example (WorkflowScheduleTriggerConfig):**
```kotlin
// Source: WorkflowScheduleTriggerConfig.kt lines 26-32
data class WorkflowScheduleTriggerConfig(
    override val version: Int = 1,
    val cronExpression: String? = null,
    val interval: Duration? = null,
    val timeZone: TimeZone
) : WorkflowTriggerConfig {
    init {
        require(cronExpression != null || interval != null) {
            "Either cronExpression or interval must be provided"
        }
    }
}
```

### Pattern 4: Template Resolution Integration
**What:** How templates flow from config to execution
**Flow:**
```
1. Config stored with templates: { "entityId": "{{ steps.fetch.output.id }}" }
2. InputResolverService.resolveAll() called before execute()
3. Resolved values passed to execute(context, inputs, services)
4. execute() uses resolved inputs, not raw config templates
```
**Source:** InputResolverService.kt lines 263-270

### Pattern 5: OpenAPI Schema Registration
**What:** Registering new config types for documentation
**How:**
```kotlin
// Source: WorkflowNodeConfigSchemaCustomizer.kt lines 69-128
companion object {
    private val ACTION_CONFIGS: List<KClass<*>> = listOf(
        WorkflowCreateEntityActionConfig::class,
        // Add new configs here
    )
    // ... all config lists combined in ALL_CONFIGS
}
```

### Anti-Patterns to Avoid
- **Untyped config maps:** Current `config: Map<String, Any?>` loses compile-time safety
- **Validation in execute():** Validate on save, not during execution
- **Complex sealed subtypes for variants:** Use flat nullable fields + validation
- **Display hints in config:** Keep configs pure execution data

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Template parsing | Custom regex parsing | `TemplateParserService.parse()` | Handles edge cases, embedded templates, validation |
| Expression evaluation | Custom interpreter | `ExpressionParserService` + `ExpressionEvaluatorService` | Full SQL-like AST with property access |
| JSON Schema validation | Manual type checking | `SchemaService.validate()` | Handles nested structures, formats, constraints |
| OpenAPI polymorphism | Manual oneOf | `WorkflowNodeConfigSchemaCustomizer` | Auto-registers subtypes with discriminator |
| Retry configuration | Per-config retry logic | `WorkflowRetryConfigurationProperties` | Centralized defaults with per-action overrides |

**Key insight:** The codebase has mature solutions for validation, templating, and serialization. Focus is on defining typed config structures that use these existing services.

## Common Pitfalls

### Pitfall 1: Breaking Existing Config Deserialization
**What goes wrong:** Changing field names or structures breaks existing serialized configs
**Why it happens:** Config JSON stored in database JSONB columns
**How to avoid:**
- Keep `version` field for migration support
- Add new required fields with defaults initially
- Test deserialization of existing configs
**Warning signs:** Jackson deserialization errors after deployment

### Pitfall 2: Circular Validation Dependencies
**What goes wrong:** Config validation needs services that need context
**Why it happens:** Validating entity refs requires EntityTypeRepository
**How to avoid:**
- Syntax validation (template parsing) in config layer
- Reference validation in service layer
- Pass validation context explicitly
**Warning signs:** Circular dependency injection errors

### Pitfall 3: Template vs Static Field Confusion
**What goes wrong:** Not all String fields should support templates
**Why it happens:** CONTEXT.md says "All String fields template-enabled"
**How to avoid:**
- Document which fields are template-enabled
- Consider if static-only fields exist (e.g., cron expressions)
- Add `@TemplateEnabled` custom annotation for documentation
**Warning signs:** Users putting templates where static values expected

### Pitfall 4: Validation Timing Mismatch
**What goes wrong:** Cross-node validation at save time fails because other nodes don't exist yet
**Why it happens:** User builds workflow incrementally
**How to avoid:**
- Single-node validation on save (CONTEXT.md decision)
- Cross-node validation separate (whole workflow validation)
- Don't validate step references exist during node save
**Warning signs:** Can't save first node that references second node

### Pitfall 5: Duration Serialization Issues
**What goes wrong:** `java.time.Duration` doesn't serialize cleanly to JSON
**Why it happens:** Default Jackson handling may not match expectations
**How to avoid:**
- Use explicit format (ISO-8601 or seconds)
- Add custom serializer/deserializer if needed
- Document expected format in schema
**Warning signs:** Inconsistent duration formats in API responses

## Code Examples

Verified patterns from existing codebase:

### Strongly Typed Config (Based on Existing Pattern)
```kotlin
// Pattern derived from WorkflowScheduleTriggerConfig.kt
@Schema(
    name = "WorkflowCreateEntityActionConfig",
    description = "Configuration for CREATE_ENTITY action nodes."
)
@JsonTypeName("workflow_create_entity_action")
@JsonDeserialize(using = JsonDeserializer.None::class)
data class WorkflowCreateEntityActionConfig(
    override val version: Int = 1,

    // Required execution properties (template-enabled)
    val entityTypeId: String,           // "{{ steps.x.output.typeId }}" or static UUID string
    val payload: Map<String, String>,   // { "name": "{{ steps.x.output.name }}" }

    // Optional overrides
    val timeout: Duration? = null,
    val retryConfig: RetryConfiguration? = null

) : WorkflowActionConfig {
    override val subType: WorkflowActionType
        get() = WorkflowActionType.CREATE_ENTITY

    // Validation called by service layer on save
    fun validate(): List<ConfigValidationError> {
        val errors = mutableListOf<ConfigValidationError>()

        // Validate entityTypeId is valid UUID or template
        if (!isTemplateOrUuid(entityTypeId)) {
            errors.add(ConfigValidationError("entityTypeId", "Must be UUID or template"))
        }

        // Validate payload templates have valid syntax
        payload.forEach { (field, value) ->
            try {
                templateParser.parse(value)
            } catch (e: IllegalArgumentException) {
                errors.add(ConfigValidationError("payload.$field", e.message ?: "Invalid template"))
            }
        }

        return errors
    }
}
```

### Template Validation (From TemplateParserService)
```kotlin
// Source: TemplateParserService.kt lines 122-155
fun parse(input: String): ParsedTemplate {
    val matches = templatePattern.findAll(input).toList()

    if (matches.isEmpty()) {
        // Check for malformed templates
        val malformedMatches = malformedTemplatePattern.findAll(input).toList()
        if (malformedMatches.isNotEmpty()) {
            val content = malformed.removePrefix("{{").removeSuffix("}}").trim()
            if (content.isEmpty()) {
                throw IllegalArgumentException("Empty template: $input")
            }
            if (content.contains("..")) {
                throw IllegalArgumentException("Empty path segment in template: $input")
            }
            throw IllegalArgumentException("Invalid template syntax: $malformed")
        }
        // Not a template - return as static
        return ParsedTemplate(isTemplate = false, path = null, rawValue = input)
    }
    // ... template parsing continues
}
```

### Expression Storage (From ExpressionParserService)
```kotlin
// Source: models/common/Expression.kt lines 24-46
// Expression AST is stored and evaluated, not raw strings

sealed class Expression {
    data class Literal(val value: Any?) : Expression()
    data class PropertyAccess(val path: List<String>) : Expression()
    data class BinaryOp(
        val left: Expression,
        val operator: Operator,
        val right: Expression
    ) : Expression()
}

// Parsing: ExpressionParserService.kt line 18
fun parse(expression: String): Expression {
    val tokens = tokenize(expression)
    val parser = Parser(tokens)
    return parser.parseExpression()
}
```

### Field-Level Validation Error Pattern
```kotlin
// Recommended pattern based on CONTEXT.md decisions
data class ConfigValidationError(
    val field: String,      // "payload.name" or "entityTypeId"
    val message: String     // "Required" or "Invalid template syntax"
)

data class ConfigValidationResult(
    val errors: Map<String, String> = emptyMap()  // field -> message
) {
    val isValid: Boolean get() = errors.isEmpty()
}
```

### Retry Configuration Pattern (Existing)
```kotlin
// Source: WorkflowRetryConfigurationProperties.kt
data class RetryConfig(
    val maxAttempts: Int = 3,
    val initialIntervalSeconds: Long = 1,
    val backoffCoefficient: Double = 2.0,
    val maxIntervalSeconds: Long = 30
)
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| `config: JsonObject` | Typed properties | This phase | Compile-time safety, better IDE support |
| Validation in execute() | Validation on save | This phase | Earlier error detection, better UX |
| Implicit template fields | Explicit template support | Established | All String fields can be templates |

**Current state:**
- 5 action configs exist with partial typing
- 4 trigger configs with better typing
- 1 control config (Condition) with untyped config
- Deserializer handles all types but needs updates for new fields

**Deprecated/outdated:**
- `config: Map<String, Any?>` pattern should be replaced
- Inline validation in execute() should move to save-time validation

## Open Questions

Things that couldn't be fully resolved:

1. **Expression storage format for Condition configs**
   - What we know: ExpressionParserService parses strings to AST
   - What's unclear: Should config store raw string or serialized AST?
   - Recommendation: Store raw string, parse on validation/execution (matches current WorkflowConditionControlConfig pattern)

2. **Input/Output schema representation**
   - What we know: CONTEXT.md says "explicit inputSchema and outputSchema properties"
   - What's unclear: Exact format - use existing `Schema<String>` or new type?
   - Recommendation: Use existing `Schema<String>` for consistency with BlockType/webhook patterns

3. **Structured query filters**
   - What we know: "Query configs use `filters: List<Filter>` with field, operator, value"
   - What's unclear: No existing Filter model found in codebase
   - Recommendation: Define new Filter data class based on Expression/Operator patterns

## Sources

### Primary (HIGH confidence)
- `/home/jared/dev/riven/core/src/main/kotlin/riven/core/models/workflow/node/config/` - All existing config implementations
- `/home/jared/dev/riven/core/src/main/kotlin/riven/core/service/workflow/TemplateParserService.kt` - Template parsing
- `/home/jared/dev/riven/core/src/main/kotlin/riven/core/service/workflow/InputResolverService.kt` - Template resolution
- `/home/jared/dev/riven/core/src/main/kotlin/riven/core/service/workflow/ExpressionParserService.kt` - Expression parsing
- `/home/jared/dev/riven/core/src/main/kotlin/riven/core/configuration/openapi/WorkflowNodeConfigSchemaCustomizer.kt` - OpenAPI handling
- `/home/jared/dev/riven/core/src/main/kotlin/riven/core/deserializer/WorkflowNodeDeserializer.kt` - Deserialization

### Secondary (MEDIUM confidence)
- CONTEXT.md decisions - User requirements and constraints

### Tertiary (LOW confidence)
- None - all findings verified against codebase

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - All libraries already in use, verified in build.gradle.kts and source
- Architecture: HIGH - Patterns extracted directly from existing codebase
- Pitfalls: MEDIUM - Based on general patterns and codebase analysis

**Research date:** 2026-01-28
**Valid until:** 30 days (stable domain, internal codebase patterns)
