---
phase: 07.1-node-configuration-development
plan: 04
type: execute
wave: 3
depends_on: ["07.1-02", "07.1-03"]
files_modified:
  - src/main/kotlin/riven/core/deserializer/WorkflowNodeDeserializer.kt
  - src/main/kotlin/riven/core/service/workflow/WorkflowGraphService.kt
  - src/test/kotlin/riven/core/models/workflow/node/config/actions/EntityActionConfigValidationTest.kt
autonomous: true

must_haves:
  truths:
    - "Deserializer handles new typed config fields without breaking existing data"
    - "WorkflowGraphService validates configs on node save"
    - "Invalid configs are rejected with field-level errors"
    - "Unit tests cover validation for all entity action configs"
  artifacts:
    - path: "src/main/kotlin/riven/core/deserializer/WorkflowNodeDeserializer.kt"
      provides: "Updated deserializer for typed configs"
      contains: "WorkflowCreateEntityActionConfig"
    - path: "src/main/kotlin/riven/core/service/workflow/WorkflowGraphService.kt"
      provides: "Config validation on save"
      contains: "ConfigValidationService"
    - path: "src/test/kotlin/riven/core/models/workflow/node/config/actions/EntityActionConfigValidationTest.kt"
      provides: "Validation tests for entity configs"
      min_lines: 100
  key_links:
    - from: "WorkflowGraphService.saveNode"
      to: "ConfigValidationService"
      via: "validate before save"
      pattern: "configValidationService"
---

<objective>
Integrate typed configs with the deserializer and graph service, adding validation on save and comprehensive tests.

Purpose: Complete the integration so typed configs work end-to-end: API receives JSON, deserializes to typed config, validates on save, and rejects invalid configurations with clear error messages.

Output: Updated deserializer, validation integration in WorkflowGraphService, and test coverage for config validation.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07.1-node-configuration-development/07.1-CONTEXT.md
@.planning/phases/07.1-node-configuration-development/07.1-RESEARCH.md
@.planning/phases/07.1-node-configuration-development/07.1-01-SUMMARY.md
@.planning/phases/07.1-node-configuration-development/07.1-02-SUMMARY.md
@.planning/phases/07.1-node-configuration-development/07.1-03-SUMMARY.md
@src/main/kotlin/riven/core/deserializer/WorkflowNodeDeserializer.kt
@src/main/kotlin/riven/core/service/workflow/WorkflowGraphService.kt
@src/main/kotlin/riven/core/service/workflow/ConfigValidationService.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update WorkflowNodeConfigDeserializer for typed configs</name>
  <files>src/main/kotlin/riven/core/deserializer/WorkflowNodeDeserializer.kt</files>
  <action>
The deserializer already routes to concrete config classes via `treeToValue()`. Since we changed the field structure (removed `name`, `config` and added typed fields), we need to ensure Jackson properly deserializes the new format.

The current deserializer should work because:
1. It uses `@JsonDeserialize(using = JsonDeserializer.None::class)` on each config
2. Jackson will automatically deserialize the new typed fields
3. The `treeToValue()` call handles the conversion

However, update the deserializer's imports and verify the control flow routes to the correct config class:

Update the CONTROL_FLOW deserializer to route to the concrete class (currently broken):

```kotlin
// In deserializeControlConfig(), change:
WorkflowControlType.CONDITION -> p.codec.treeToValue(node, WorkflowControlConfig::class.java)

// TO:
WorkflowControlType.CONDITION -> p.codec.treeToValue(node, WorkflowConditionControlConfig::class.java)
```

Add the import:
```kotlin
import riven.core.models.workflow.node.config.controls.WorkflowConditionControlConfig
```

The full updated file should maintain existing structure but fix the CONDITION routing.

Verify:
1. ACTION configs route to WorkflowCreateEntityActionConfig, etc.
2. TRIGGER configs route correctly (already working)
3. CONTROL_FLOW.CONDITION routes to WorkflowConditionControlConfig (fix)
  </action>
  <verify>
```bash
./gradlew compileKotlin --quiet 2>&1 | head -20
```
Deserializer compiles with correct imports.
  </verify>
  <done>WorkflowNodeConfigDeserializer correctly routes CONDITION to WorkflowConditionControlConfig</done>
</task>

<task type="auto">
  <name>Task 2: Add config validation to WorkflowGraphService</name>
  <files>src/main/kotlin/riven/core/service/workflow/WorkflowGraphService.kt</files>
  <action>
Integrate ConfigValidationService into WorkflowGraphService to validate configs on save.

Per CONTEXT.md: "Validate on save: Validate when node is created/updated via API. Invalid configs rejected immediately."

**Changes to make:**

1. Add ConfigValidationService to constructor:
```kotlin
@Service
class WorkflowGraphService(
    private val workflowNodeRepository: WorkflowNodeRepository,
    private val workflowEdgeRepository: WorkflowEdgeRepository,
    private val workflowDefinitionRepository: WorkflowDefinitionRepository,
    private val workflowDefinitionVersionRepository: WorkflowDefinitionVersionRepository,
    private val activityService: ActivityService,
    private val authTokenService: AuthTokenService,
    private val configValidationService: ConfigValidationService,  // ADD THIS
    private val expressionParserService: ExpressionParserService   // ADD for CONDITION validation
) {
```

2. Add imports:
```kotlin
import riven.core.models.workflow.node.config.validation.ConfigValidationResult
import riven.core.models.workflow.node.config.actions.*
import riven.core.models.workflow.node.config.controls.WorkflowConditionControlConfig
import riven.core.service.workflow.ConfigValidationService
import riven.core.service.workflow.ExpressionParserService
```

3. Add validation helper method:
```kotlin
/**
 * Validates a workflow node configuration.
 *
 * @param config The config to validate
 * @return Validation result with any errors
 * @throws IllegalArgumentException if config is invalid
 */
private fun validateConfig(config: WorkflowNodeConfig): ConfigValidationResult {
    return when (config) {
        is WorkflowCreateEntityActionConfig -> config.validate(configValidationService)
        is WorkflowUpdateEntityActionConfig -> config.validate(configValidationService)
        is WorkflowDeleteEntityActionConfig -> config.validate(configValidationService)
        is WorkflowQueryEntityActionConfig -> config.validate(configValidationService)
        is WorkflowHttpRequestActionConfig -> config.validate(configValidationService)
        is WorkflowConditionControlConfig -> config.validate(configValidationService, expressionParserService)
        else -> ConfigValidationResult.valid()  // Triggers and other types don't have validation yet
    }
}
```

4. Add validation call to createNode() after line 70 (before creating entity):
```kotlin
// Validate config before saving
val validationResult = validateConfig(request.config)
if (!validationResult.isValid) {
    val errorMessages = validationResult.errors.joinToString("; ") { "${it.field}: ${it.message}" }
    throw IllegalArgumentException("Invalid node configuration: $errorMessages")
}
```

5. Add validation call to updateNode() when config is being updated (inside the `if (request.config != null)` block, before soft-deleting the old node):
```kotlin
// Validate new config before saving
val validationResult = validateConfig(request.config)
if (!validationResult.isValid) {
    val errorMessages = validationResult.errors.joinToString("; ") { "${it.field}: ${it.message}" }
    throw IllegalArgumentException("Invalid node configuration: $errorMessages")
}
```

The validation runs before any database changes, so invalid configs are rejected immediately.
  </action>
  <verify>
```bash
./gradlew compileKotlin --quiet 2>&1 | head -30
```
WorkflowGraphService compiles with validation integration.
  </verify>
  <done>WorkflowGraphService validates configs on createNode and updateNode, rejecting invalid configs with field-level errors</done>
</task>

<task type="auto">
  <name>Task 3: Add validation unit tests for entity action configs</name>
  <files>src/test/kotlin/riven/core/models/workflow/node/config/actions/EntityActionConfigValidationTest.kt</files>
  <action>
Create comprehensive unit tests for config validation across all entity action configs.

```kotlin
package riven.core.models.workflow.node.config.actions

import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Nested
import org.junit.jupiter.api.Test
import riven.core.service.workflow.ConfigValidationService
import riven.core.service.workflow.TemplateParserService

class EntityActionConfigValidationTest {

    private lateinit var templateParserService: TemplateParserService
    private lateinit var configValidationService: ConfigValidationService

    @BeforeEach
    fun setUp() {
        templateParserService = TemplateParserService()
        configValidationService = ConfigValidationService(templateParserService)
    }

    @Nested
    inner class WorkflowCreateEntityActionConfigValidation {

        @Test
        fun `valid config with static UUID passes validation`() {
            val config = WorkflowCreateEntityActionConfig(
                entityTypeId = "550e8400-e29b-41d4-a716-446655440000",
                payload = mapOf("name" to "Test Entity")
            )
            val result = config.validate(configValidationService)
            assertTrue(result.isValid, "Expected valid config: ${result.errors}")
        }

        @Test
        fun `valid config with template entityTypeId passes validation`() {
            val config = WorkflowCreateEntityActionConfig(
                entityTypeId = "{{ steps.fetch.output.typeId }}",
                payload = mapOf("name" to "{{ steps.data.output.name }}")
            )
            val result = config.validate(configValidationService)
            assertTrue(result.isValid, "Expected valid config: ${result.errors}")
        }

        @Test
        fun `invalid entityTypeId fails validation`() {
            val config = WorkflowCreateEntityActionConfig(
                entityTypeId = "not-a-uuid",
                payload = emptyMap()
            )
            val result = config.validate(configValidationService)
            assertFalse(result.isValid)
            assertTrue(result.errors.any { it.field == "entityTypeId" })
        }

        @Test
        fun `invalid template in payload fails validation`() {
            val config = WorkflowCreateEntityActionConfig(
                entityTypeId = "550e8400-e29b-41d4-a716-446655440000",
                payload = mapOf("name" to "{{ }}")  // Invalid empty template
            )
            val result = config.validate(configValidationService)
            assertFalse(result.isValid)
            assertTrue(result.errors.any { it.field == "payload.name" })
        }

        @Test
        fun `negative timeout fails validation`() {
            val config = WorkflowCreateEntityActionConfig(
                entityTypeId = "550e8400-e29b-41d4-a716-446655440000",
                timeoutSeconds = -5
            )
            val result = config.validate(configValidationService)
            assertFalse(result.isValid)
            assertTrue(result.errors.any { it.field == "timeoutSeconds" })
        }
    }

    @Nested
    inner class WorkflowUpdateEntityActionConfigValidation {

        @Test
        fun `valid config with static UUID passes validation`() {
            val config = WorkflowUpdateEntityActionConfig(
                entityId = "550e8400-e29b-41d4-a716-446655440000",
                payload = mapOf("status" to "active")
            )
            val result = config.validate(configValidationService)
            assertTrue(result.isValid, "Expected valid config: ${result.errors}")
        }

        @Test
        fun `valid config with template entityId passes validation`() {
            val config = WorkflowUpdateEntityActionConfig(
                entityId = "{{ steps.find.output.entityId }}",
                payload = mapOf("name" to "{{ steps.data.output.name }}")
            )
            val result = config.validate(configValidationService)
            assertTrue(result.isValid, "Expected valid config: ${result.errors}")
        }

        @Test
        fun `invalid entityId fails validation`() {
            val config = WorkflowUpdateEntityActionConfig(
                entityId = "not-a-uuid-or-template",
                payload = emptyMap()
            )
            val result = config.validate(configValidationService)
            assertFalse(result.isValid)
            assertTrue(result.errors.any { it.field == "entityId" })
        }
    }

    @Nested
    inner class WorkflowDeleteEntityActionConfigValidation {

        @Test
        fun `valid config with static UUID passes validation`() {
            val config = WorkflowDeleteEntityActionConfig(
                entityId = "550e8400-e29b-41d4-a716-446655440000"
            )
            val result = config.validate(configValidationService)
            assertTrue(result.isValid, "Expected valid config: ${result.errors}")
        }

        @Test
        fun `valid config with template passes validation`() {
            val config = WorkflowDeleteEntityActionConfig(
                entityId = "{{ steps.find_expired.output.entityId }}"
            )
            val result = config.validate(configValidationService)
            assertTrue(result.isValid, "Expected valid config: ${result.errors}")
        }

        @Test
        fun `invalid entityId fails validation`() {
            val config = WorkflowDeleteEntityActionConfig(
                entityId = "invalid"
            )
            val result = config.validate(configValidationService)
            assertFalse(result.isValid)
            assertTrue(result.errors.any { it.field == "entityId" })
        }
    }

    @Nested
    inner class WorkflowQueryEntityActionConfigValidation {

        @Test
        fun `valid config with static UUID passes validation`() {
            val config = WorkflowQueryEntityActionConfig(
                entityId = "550e8400-e29b-41d4-a716-446655440000"
            )
            val result = config.validate(configValidationService)
            assertTrue(result.isValid, "Expected valid config: ${result.errors}")
        }

        @Test
        fun `valid config with template passes validation`() {
            val config = WorkflowQueryEntityActionConfig(
                entityId = "{{ steps.trigger.output.entityId }}"
            )
            val result = config.validate(configValidationService)
            assertTrue(result.isValid, "Expected valid config: ${result.errors}")
        }

        @Test
        fun `blank entityId fails validation`() {
            val config = WorkflowQueryEntityActionConfig(
                entityId = "   "
            )
            val result = config.validate(configValidationService)
            assertFalse(result.isValid)
            assertTrue(result.errors.any { it.field == "entityId" })
        }
    }

    @Nested
    inner class WorkflowHttpRequestActionConfigValidation {

        @Test
        fun `valid GET request passes validation`() {
            val config = WorkflowHttpRequestActionConfig(
                url = "https://api.example.com/users",
                method = "GET"
            )
            val result = config.validate(configValidationService)
            assertTrue(result.isValid, "Expected valid config: ${result.errors}")
        }

        @Test
        fun `valid POST request with body passes validation`() {
            val config = WorkflowHttpRequestActionConfig(
                url = "https://api.example.com/users",
                method = "POST",
                headers = mapOf("Content-Type" to "application/json"),
                body = mapOf("name" to "{{ steps.user.output.name }}")
            )
            val result = config.validate(configValidationService)
            assertTrue(result.isValid, "Expected valid config: ${result.errors}")
        }

        @Test
        fun `template URL passes validation`() {
            val config = WorkflowHttpRequestActionConfig(
                url = "{{ steps.config.output.apiUrl }}/users",
                method = "GET"
            )
            val result = config.validate(configValidationService)
            assertTrue(result.isValid, "Expected valid config: ${result.errors}")
        }

        @Test
        fun `invalid HTTP method fails validation`() {
            val config = WorkflowHttpRequestActionConfig(
                url = "https://api.example.com",
                method = "INVALID"
            )
            val result = config.validate(configValidationService)
            assertFalse(result.isValid)
            assertTrue(result.errors.any { it.field == "method" })
        }

        @Test
        fun `blank URL fails validation`() {
            val config = WorkflowHttpRequestActionConfig(
                url = "",
                method = "GET"
            )
            val result = config.validate(configValidationService)
            assertFalse(result.isValid)
            assertTrue(result.errors.any { it.field == "url" })
        }

        @Test
        fun `invalid template in headers fails validation`() {
            val config = WorkflowHttpRequestActionConfig(
                url = "https://api.example.com",
                method = "GET",
                headers = mapOf("Authorization" to "{{ }}")  // Invalid
            )
            val result = config.validate(configValidationService)
            assertFalse(result.isValid)
            assertTrue(result.errors.any { it.field == "headers.Authorization" })
        }
    }
}
```

This test file covers:
- CREATE_ENTITY: valid UUID, valid template, invalid UUID, invalid payload template, negative timeout
- UPDATE_ENTITY: valid UUID, valid template, invalid entityId
- DELETE_ENTITY: valid UUID, valid template, invalid entityId
- QUERY_ENTITY: valid UUID, valid template, blank entityId
- HTTP_REQUEST: valid GET, valid POST with body, template URL, invalid method, blank URL, invalid header template

Total: 20+ test cases covering key validation scenarios.
  </action>
  <verify>
```bash
./gradlew test --tests "riven.core.models.workflow.node.config.actions.EntityActionConfigValidationTest" --quiet 2>&1 | tail -15
```
All tests pass.
  </verify>
  <done>Comprehensive validation tests exist for all entity action configs and HTTP_REQUEST config</done>
</task>

</tasks>

<verification>
1. Deserializer routes CONDITION to correct concrete class
2. WorkflowGraphService injects ConfigValidationService
3. createNode() validates config before save
4. updateNode() validates config before save
5. Invalid configs throw IllegalArgumentException with field-level error messages
6. All validation tests pass
7. `./gradlew test --tests "*EntityActionConfigValidation*"` succeeds
</verification>

<success_criteria>
- WorkflowNodeConfigDeserializer routes CONDITION correctly
- WorkflowGraphService has ConfigValidationService dependency
- Validation runs on createNode and updateNode
- Invalid configs rejected with "Invalid node configuration: {field}: {message}" format
- 20+ test cases pass covering all action config types
- No compilation errors
</success_criteria>

<output>
After completion, create `.planning/phases/07.1-node-configuration-development/07.1-04-SUMMARY.md`
</output>
