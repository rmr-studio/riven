---
phase: 07.1-node-configuration-development
plan: 03
type: execute
wave: 2
depends_on: ["07.1-01"]
files_modified:
  - src/main/kotlin/riven/core/models/workflow/node/config/actions/WorkflowHttpRequestActionConfig.kt
  - src/main/kotlin/riven/core/models/workflow/node/config/controls/WorkflowConditionControlConfig.kt
autonomous: true

must_haves:
  truths:
    - "HTTP_REQUEST config has typed url, method, headers, body, and timeout fields"
    - "CONDITION config has typed expression and contextEntityId fields"
    - "Both configs implement validate() method"
    - "HTTP_REQUEST validates URL format and method values"
  artifacts:
    - path: "src/main/kotlin/riven/core/models/workflow/node/config/actions/WorkflowHttpRequestActionConfig.kt"
      provides: "Typed HTTP_REQUEST config with validation"
      contains: "fun validate"
    - path: "src/main/kotlin/riven/core/models/workflow/node/config/controls/WorkflowConditionControlConfig.kt"
      provides: "Typed CONDITION config with validation"
      contains: "fun validate"
  key_links:
    - from: "WorkflowConditionControlConfig.execute"
      to: "ExpressionParserService"
      via: "expression parsing"
      pattern: "expressionParserService\\.parse"
    - from: "WorkflowHttpRequestActionConfig.execute"
      to: "WebClient"
      via: "HTTP request execution"
      pattern: "webClient\\.method"
---

<objective>
Replace untyped config fields in HTTP_REQUEST and CONDITION configs with strongly-typed properties and add validation methods.

Purpose: Enable compile-time safety and save-time validation for HTTP requests and conditional control flow, completing the typed config migration for all existing node types.

Output: Typed WorkflowHttpRequestActionConfig and WorkflowConditionControlConfig with validate() methods.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07.1-node-configuration-development/07.1-CONTEXT.md
@.planning/phases/07.1-node-configuration-development/07.1-RESEARCH.md
@.planning/phases/07.1-node-configuration-development/07.1-01-SUMMARY.md
@src/main/kotlin/riven/core/models/workflow/node/config/actions/WorkflowHttpRequestActionConfig.kt
@src/main/kotlin/riven/core/models/workflow/node/config/controls/WorkflowConditionControlConfig.kt
@src/main/kotlin/riven/core/service/workflow/ConfigValidationService.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor WorkflowHttpRequestActionConfig with typed fields</name>
  <files>src/main/kotlin/riven/core/models/workflow/node/config/actions/WorkflowHttpRequestActionConfig.kt</files>
  <action>
Refactor WorkflowHttpRequestActionConfig to replace `config: Map<String, Any?>` with typed fields.

Per CONTEXT.md decisions:
- `url: String` - Template-enabled URL
- `method: String` - HTTP method (GET, POST, PUT, DELETE, PATCH)
- `headers: Map<String, String>?` - Flat map of headers (template-enabled values)
- `body: Map<String, String>?` - Request body for POST/PUT (template-enabled values)
- `timeoutSeconds: Long?` - Optional timeout

Replace the entire file with:

```kotlin
package riven.core.models.workflow.node.config.actions

import com.fasterxml.jackson.annotation.JsonTypeName
import com.fasterxml.jackson.databind.JsonDeserializer
import com.fasterxml.jackson.databind.annotation.JsonDeserialize
import io.github.oshai.kotlinlogging.KotlinLogging
import io.swagger.v3.oas.annotations.media.Schema
import org.springframework.http.HttpMethod
import org.springframework.web.reactive.function.client.WebClient
import riven.core.enums.workflow.WorkflowActionType
import riven.core.enums.workflow.WorkflowNodeType
import riven.core.models.workflow.engine.environment.WorkflowExecutionContext
import riven.core.models.workflow.node.NodeServiceProvider
import riven.core.models.workflow.node.config.WorkflowActionConfig
import riven.core.models.workflow.node.config.validation.ConfigValidationError
import riven.core.models.workflow.node.config.validation.ConfigValidationResult
import riven.core.models.workflow.node.service
import riven.core.service.workflow.ConfigValidationService
import java.net.URI

private val logger = KotlinLogging.logger {}

/**
 * Configuration for HTTP_REQUEST action nodes.
 *
 * ## Configuration Properties
 *
 * @property url URL to request (template-enabled)
 * @property method HTTP method: GET, POST, PUT, DELETE, PATCH
 * @property headers Optional map of HTTP headers (template-enabled values)
 * @property body Optional request body for POST/PUT/PATCH (template-enabled values)
 * @property timeoutSeconds Optional timeout override in seconds
 *
 * ## Example Configuration
 *
 * ```json
 * {
 *   "version": 1,
 *   "type": "ACTION",
 *   "subType": "HTTP_REQUEST",
 *   "url": "https://api.example.com/users",
 *   "method": "POST",
 *   "headers": {
 *     "Content-Type": "application/json",
 *     "X-API-Key": "{{ steps.get_api_key.output.key }}"
 *   },
 *   "body": {
 *     "email": "{{ steps.fetch_lead.output.email }}",
 *     "name": "{{ steps.fetch_lead.output.name }}"
 *   }
 * }
 * ```
 *
 * ## Output
 *
 * Returns map with:
 * - `statusCode`: Int HTTP status code
 * - `headers`: Map<String, String> response headers
 * - `body`: String response body
 * - `url`: String requested URL
 * - `method`: String HTTP method used
 *
 * ## Security
 *
 * - SSRF validation prevents requests to localhost, private IPs, and metadata endpoints
 * - Sensitive headers (Authorization, API keys) are not logged
 */
@Schema(
    name = "WorkflowHttpRequestActionConfig",
    description = "Configuration for HTTP_REQUEST action nodes."
)
@JsonTypeName("workflow_http_request_action")
@JsonDeserialize(using = JsonDeserializer.None::class)
data class WorkflowHttpRequestActionConfig(
    override val version: Int = 1,

    @Schema(
        description = "URL to request. Can contain templates like {{ steps.x.output.url }}",
        example = "https://api.example.com/users"
    )
    val url: String,

    @Schema(
        description = "HTTP method: GET, POST, PUT, DELETE, PATCH",
        example = "POST",
        allowableValues = ["GET", "POST", "PUT", "DELETE", "PATCH"]
    )
    val method: String,

    @Schema(
        description = "Optional HTTP headers. Values can be templates.",
        example = """{"Content-Type": "application/json", "Authorization": "Bearer {{ steps.auth.output.token }}"}""",
        nullable = true
    )
    val headers: Map<String, String>? = null,

    @Schema(
        description = "Optional request body for POST/PUT/PATCH. Values can be templates.",
        example = """{"name": "{{ steps.user.output.name }}", "email": "user@example.com"}""",
        nullable = true
    )
    val body: Map<String, String>? = null,

    @Schema(
        description = "Optional timeout override in seconds",
        example = "30",
        nullable = true
    )
    val timeoutSeconds: Long? = null

) : WorkflowActionConfig {

    override val type: WorkflowNodeType
        get() = WorkflowNodeType.ACTION

    override val subType: WorkflowActionType
        get() = WorkflowActionType.HTTP_REQUEST

    companion object {
        private val VALID_METHODS = setOf("GET", "POST", "PUT", "DELETE", "PATCH")
        private val SENSITIVE_HEADERS = setOf(
            "authorization",
            "x-api-key",
            "api-key",
            "cookie",
            "set-cookie"
        )
    }

    /**
     * Validates this configuration.
     *
     * Checks:
     * - url is not blank and has valid template syntax if template
     * - method is one of GET, POST, PUT, DELETE, PATCH
     * - headers values have valid template syntax
     * - body values have valid template syntax
     * - timeout is non-negative if provided
     */
    fun validate(validationService: ConfigValidationService): ConfigValidationResult {
        val errors = mutableListOf<ConfigValidationError>()

        // Validate URL
        errors.addAll(validationService.validateRequiredString(url, "url"))
        if (url.isNotBlank() && validationService.templateParserService.isTemplate(url)) {
            errors.addAll(validationService.validateTemplateSyntax(url, "url"))
        }

        // Validate method
        if (method.isBlank()) {
            errors.add(ConfigValidationError("method", "HTTP method is required"))
        } else if (method.uppercase() !in VALID_METHODS) {
            errors.add(ConfigValidationError("method", "Invalid HTTP method. Must be one of: ${VALID_METHODS.joinToString()}"))
        }

        // Validate headers templates
        if (headers != null) {
            errors.addAll(validationService.validateTemplateMap(headers, "headers"))
        }

        // Validate body templates
        if (body != null) {
            errors.addAll(validationService.validateTemplateMap(body, "body"))
        }

        // Validate timeout
        errors.addAll(validationService.validateOptionalDuration(timeoutSeconds, "timeoutSeconds"))

        return ConfigValidationResult(errors)
    }

    override fun execute(
        context: WorkflowExecutionContext,
        inputs: Map<String, Any?>,
        services: NodeServiceProvider
    ): Map<String, Any?> {
        // Extract resolved inputs
        val resolvedUrl = inputs["url"] as String
        val resolvedMethod = inputs["method"] as String
        val resolvedHeaders = inputs["headers"] as? Map<*, *> ?: emptyMap<Any, Any>()
        val resolvedBody = inputs["body"] as? Map<String, Any?>

        // Validate URL (prevent SSRF)
        validateUrl(resolvedUrl)

        // Get WebClient on-demand
        val webClient = services.service<WebClient>()

        // Execute HTTP request (external service call)
        val response = webClient
            .method(HttpMethod.valueOf(resolvedMethod.uppercase()))
            .uri(resolvedUrl)
            .headers { h ->
                resolvedHeaders.forEach { (key, value) ->
                    if (key is String && value is String) {
                        h.set(key, value)
                    }
                }
            }
            .bodyValue(resolvedBody ?: emptyMap<String, Any?>())
            .retrieve()
            .toEntity(String::class.java)
            .block() ?: throw RuntimeException("HTTP request returned null")

        // Log without sensitive data
        logger.info { "HTTP_REQUEST: $resolvedMethod $resolvedUrl -> ${response.statusCode}" }

        // Clear output contract
        return mapOf(
            "statusCode" to response.statusCode.value(),
            "headers" to response.headers.toSingleValueMap(),
            "body" to response.body,
            "url" to resolvedUrl,
            "method" to resolvedMethod
        )
    }

    /**
     * Validates URL to prevent SSRF attacks.
     * Blocks localhost, private IPs, metadata endpoints.
     */
    private fun validateUrl(url: String) {
        val uri = URI(url)
        val host = uri.host?.lowercase() ?: throw IllegalArgumentException("Invalid URL: no host")

        // Block localhost
        if (host in listOf("localhost", "127.0.0.1", "::1")) {
            throw SecurityException("HTTP_REQUEST cannot target localhost")
        }

        // Block private IP ranges (basic check)
        if (host.startsWith("10.") || host.startsWith("192.168.") || host.startsWith("172.")) {
            throw SecurityException("HTTP_REQUEST cannot target private IP ranges")
        }

        // Block cloud metadata endpoints
        if (host == "169.254.169.254") {
            throw SecurityException("HTTP_REQUEST cannot target cloud metadata endpoints")
        }
    }
}
```

Key changes:
- Replaced `name: String, config: Map<String, Any?>` with typed `url`, `method`, `headers`, `body`, `timeoutSeconds`
- Added `validate()` method with HTTP-specific validations (method enum, URL format)
- Moved SENSITIVE_HEADERS and VALID_METHODS to companion object
- Removed redundant `isSensitiveHeader` method (headers still passed through, just not logged)

Note: The `validate` method needs access to `templateParserService` - we need to adjust the method signature or use an interface. Let me fix this:
  </action>
  <verify>
```bash
./gradlew compileKotlin --quiet 2>&1 | head -30
```

Note: If there's a compilation error about `templateParserService`, we'll fix it in the next iteration.
  </verify>
  <done>WorkflowHttpRequestActionConfig has typed fields (url, method, headers, body, timeoutSeconds) and validate() method</done>
</task>

<task type="auto">
  <name>Task 2: Fix ConfigValidationService to expose TemplateParserService and update HTTP config</name>
  <files>
    src/main/kotlin/riven/core/service/workflow/ConfigValidationService.kt
    src/main/kotlin/riven/core/models/workflow/node/config/actions/WorkflowHttpRequestActionConfig.kt
  </files>
  <action>
The HTTP config's validate() method tried to access `validationService.templateParserService` which is private.

**Option A:** Make templateParserService public in ConfigValidationService
**Option B:** Add a method to check if value is template

Choose Option A for simplicity - update ConfigValidationService to expose TemplateParserService:

In ConfigValidationService.kt, change:
```kotlin
// FROM:
private val templateParserService: TemplateParserService

// TO:
val templateParserService: TemplateParserService
```

This allows configs to call `validationService.templateParserService.isTemplate(value)` when needed.

Then verify WorkflowHttpRequestActionConfig compiles correctly with:
```kotlin
if (url.isNotBlank() && validationService.templateParserService.isTemplate(url)) {
    errors.addAll(validationService.validateTemplateSyntax(url, "url"))
}
```

If this pattern is too verbose, alternatively add a helper method to ConfigValidationService:
```kotlin
fun isTemplate(value: String): Boolean = templateParserService.isTemplate(value)
```

Choose the cleaner approach based on what compiles.
  </action>
  <verify>
```bash
./gradlew compileKotlin --quiet 2>&1 | head -20
```
Both files compile without errors.
  </verify>
  <done>ConfigValidationService exposes template checking capability and WorkflowHttpRequestActionConfig compiles</done>
</task>

<task type="auto">
  <name>Task 3: Refactor WorkflowConditionControlConfig with typed fields</name>
  <files>src/main/kotlin/riven/core/models/workflow/node/config/controls/WorkflowConditionControlConfig.kt</files>
  <action>
Refactor WorkflowConditionControlConfig to replace `config: Map<String, Any?>` with typed fields.

Per CONTEXT.md decisions and RESEARCH.md:
- `expression: String` - The expression to evaluate (stored as string, parsed at execution)
- `contextEntityId: String?` - Optional entity ID for context (template-enabled)
- Expression stored as raw string (matches existing pattern, parsed on validation/execution)

Replace the entire file with:

```kotlin
package riven.core.models.workflow.node.config.controls

import com.fasterxml.jackson.annotation.JsonTypeName
import com.fasterxml.jackson.databind.JsonDeserializer
import com.fasterxml.jackson.databind.annotation.JsonDeserialize
import io.github.oshai.kotlinlogging.KotlinLogging
import io.swagger.v3.oas.annotations.media.Schema
import riven.core.enums.workflow.WorkflowControlType
import riven.core.enums.workflow.WorkflowNodeType
import riven.core.models.workflow.engine.environment.WorkflowExecutionContext
import riven.core.models.workflow.node.NodeServiceProvider
import riven.core.models.workflow.node.config.WorkflowControlConfig
import riven.core.models.workflow.node.config.validation.ConfigValidationError
import riven.core.models.workflow.node.config.validation.ConfigValidationResult
import riven.core.models.workflow.node.service
import riven.core.service.workflow.ConfigValidationService
import riven.core.service.workflow.EntityContextService
import riven.core.service.workflow.ExpressionEvaluatorService
import riven.core.service.workflow.ExpressionParserService
import java.util.*

private val log = KotlinLogging.logger {}

/**
 * Configuration for CONDITION control flow nodes.
 *
 * ## Configuration Properties
 *
 * @property expression SQL-like expression to evaluate (must return boolean)
 * @property contextEntityId Optional entity ID to load as evaluation context (template-enabled)
 * @property timeoutSeconds Optional timeout override in seconds
 *
 * ## Example Configuration
 *
 * ```json
 * {
 *   "version": 1,
 *   "type": "CONTROL_FLOW",
 *   "subType": "CONDITION",
 *   "expression": "entity.status == 'active' && entity.balance > 0",
 *   "contextEntityId": "{{ steps.fetch_account.output.entityId }}"
 * }
 * ```
 *
 * ## Output
 *
 * Returns map with:
 * - `conditionResult`: Boolean result of expression evaluation
 *
 * ## Expression Syntax
 *
 * Supports SQL-like syntax:
 * - Comparison: ==, !=, <, >, <=, >=
 * - Logical: &&, ||, !
 * - Property access: entity.field.nested
 * - Literals: 'string', 123, true, false, null
 *
 * ## DAG Coordination
 *
 * The conditionResult is used by the DAG coordinator to determine which
 * branch to execute next. Conditional edges in the workflow graph reference
 * this node's output to route execution flow.
 */
@Schema(
    name = "WorkflowConditionControlConfig",
    description = "Configuration for CONDITION control flow nodes."
)
@JsonTypeName("workflow_condition_control")
@JsonDeserialize(using = JsonDeserializer.None::class)
data class WorkflowConditionControlConfig(
    override val version: Int = 1,

    @Schema(
        description = "SQL-like expression to evaluate. Must return boolean.",
        example = "entity.status == 'active' && entity.balance > 0"
    )
    val expression: String,

    @Schema(
        description = "Optional entity ID to use as evaluation context. Can be a static UUID or template.",
        example = "{{ steps.fetch_account.output.entityId }}",
        nullable = true
    )
    val contextEntityId: String? = null,

    @Schema(
        description = "Optional timeout override in seconds",
        nullable = true
    )
    val timeoutSeconds: Long? = null

) : WorkflowControlConfig {

    override val type: WorkflowNodeType
        get() = WorkflowNodeType.CONTROL_FLOW

    override val subType: WorkflowControlType
        get() = WorkflowControlType.CONDITION

    /**
     * Validates this configuration.
     *
     * Checks:
     * - expression is not blank
     * - expression has valid syntax (parses without error)
     * - contextEntityId is valid UUID or template if provided
     * - timeout is non-negative if provided
     *
     * Note: Expression syntax is validated by attempting to parse it.
     * The ExpressionParserService must be available for full validation.
     */
    fun validate(
        validationService: ConfigValidationService,
        expressionParserService: ExpressionParserService? = null
    ): ConfigValidationResult {
        val errors = mutableListOf<ConfigValidationError>()

        // Validate expression is not blank
        errors.addAll(validationService.validateRequiredString(expression, "expression"))

        // Validate expression syntax if parser available
        if (expression.isNotBlank() && expressionParserService != null) {
            try {
                expressionParserService.parse(expression)
            } catch (e: Exception) {
                errors.add(ConfigValidationError("expression", "Invalid expression syntax: ${e.message}"))
            }
        }

        // Validate contextEntityId if provided
        if (contextEntityId != null) {
            errors.addAll(validationService.validateTemplateOrUuid(contextEntityId, "contextEntityId"))
        }

        // Validate timeout
        errors.addAll(validationService.validateOptionalDuration(timeoutSeconds, "timeoutSeconds"))

        return ConfigValidationResult(errors)
    }

    override fun execute(
        context: WorkflowExecutionContext,
        inputs: Map<String, Any?>,
        services: NodeServiceProvider
    ): Map<String, Any?> {
        // Extract resolved inputs
        val resolvedExpression = inputs["expression"] as? String ?: expression
        val resolvedContextEntityId = inputs["contextEntityId"] as? String

        // Get services on-demand
        val entityContextService = services.service<EntityContextService>()
        val expressionParserService = services.service<ExpressionParserService>()
        val expressionEvaluatorService = services.service<ExpressionEvaluatorService>()

        // Resolve entity context if provided
        val evaluationContext: Map<String, Any?> = if (resolvedContextEntityId != null) {
            val entityId = UUID.fromString(resolvedContextEntityId)
            entityContextService.buildContext(entityId, context.workspaceId)
        } else {
            emptyMap()
        }

        // Parse and evaluate expression
        val ast = expressionParserService.parse(resolvedExpression)
        val result = expressionEvaluatorService.evaluate(ast, evaluationContext)

        // Validate boolean result
        if (result !is Boolean) {
            throw IllegalStateException(
                "CONDITION expression must evaluate to boolean, got: ${result?.let { it::class.simpleName } ?: "null"}"
            )
        }

        log.debug { "CONDITION evaluated: $resolvedExpression -> $result (context: ${evaluationContext.keys})" }

        // Return boolean for DAG branching
        return mapOf("conditionResult" to result)
    }
}
```

Key changes:
- Replaced `name: String, config: Map<String, Any?>` with typed `expression`, `contextEntityId`, `timeoutSeconds`
- Added `validate()` method with expression syntax validation
- Expression stored as string (per RESEARCH.md recommendation)
- Optional ExpressionParserService in validate() for syntax checking
  </action>
  <verify>
```bash
./gradlew compileKotlin --quiet 2>&1 | head -20
```
  </verify>
  <done>WorkflowConditionControlConfig has typed fields (expression, contextEntityId, timeoutSeconds) and validate() method</done>
</task>

</tasks>

<verification>
1. Both HTTP_REQUEST and CONDITION configs compile without errors
2. Each config has typed fields instead of `config: Map/JsonObject`
3. Each config has `validate()` method
4. HTTP_REQUEST validates method enum
5. CONDITION can validate expression syntax
6. `./gradlew compileKotlin` succeeds
</verification>

<success_criteria>
- WorkflowHttpRequestActionConfig: url, method, headers, body, timeoutSeconds fields
- WorkflowConditionControlConfig: expression, contextEntityId, timeoutSeconds fields
- Both configs have validate() method returning ConfigValidationResult
- HTTP_REQUEST validates method is GET/POST/PUT/DELETE/PATCH
- CONDITION can optionally validate expression syntax
- No compilation errors
</success_criteria>

<output>
After completion, create `.planning/phases/07.1-node-configuration-development/07.1-03-SUMMARY.md`
</output>
