---
phase: 06.1-execution-queue-management
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/main/kotlin/riven/core/entity/workflow/ExecutionQueueEntity.kt
  - src/main/kotlin/riven/core/enums/workflow/ExecutionQueueStatus.kt
  - src/main/kotlin/riven/core/repository/workflow/ExecutionQueueRepository.kt
  - src/main/kotlin/riven/core/service/workflow/ExecutionQueueService.kt
  - schema.sql
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Execution queue table persists workflow execution requests"
    - "SKIP LOCKED query enables concurrent queue consumers"
    - "ExecutionQueueService provides queue management operations"
  artifacts:
    - path: "src/main/kotlin/riven/core/entity/workflow/ExecutionQueueEntity.kt"
      provides: "JPA entity for execution queue table"
      exports: ["ExecutionQueueEntity"]
    - path: "src/main/kotlin/riven/core/enums/workflow/ExecutionQueueStatus.kt"
      provides: "Queue item status enum"
      exports: ["ExecutionQueueStatus"]
    - path: "src/main/kotlin/riven/core/repository/workflow/ExecutionQueueRepository.kt"
      provides: "Data access with SKIP LOCKED queries"
      exports: ["ExecutionQueueRepository"]
    - path: "src/main/kotlin/riven/core/service/workflow/ExecutionQueueService.kt"
      provides: "Queue enqueue and status operations"
      exports: ["ExecutionQueueService"]
  key_links:
    - from: "ExecutionQueueRepository.kt"
      to: "PostgreSQL"
      via: "FOR UPDATE SKIP LOCKED native query"
      pattern: "FOR UPDATE SKIP LOCKED"
    - from: "ExecutionQueueService.kt"
      to: "ExecutionQueueRepository.kt"
      via: "repository injection"
      pattern: "executionQueueRepository"
---

<objective>
Create the database-backed execution queue for durable workflow request queuing.

Purpose: Implement a PostgreSQL-backed queue that survives restarts, supports concurrent consumers via SKIP LOCKED, and provides the foundation for tier-based concurrency control.

Output: ExecutionQueueEntity, ExecutionQueueStatus enum, ExecutionQueueRepository with SKIP LOCKED queries, ExecutionQueueService for queue operations.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06.1-execution-queue-management/06.1-CONTEXT.md
@.planning/phases/06.1-execution-queue-management/06.1-RESEARCH.md
@src/main/kotlin/riven/core/entity/workflow/execution/WorkflowExecutionEntity.kt
@src/main/kotlin/riven/core/repository/workflow/WorkflowExecutionRepository.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ExecutionQueueEntity and status enum</name>
  <files>
    - src/main/kotlin/riven/core/enums/workflow/ExecutionQueueStatus.kt
    - src/main/kotlin/riven/core/entity/workflow/ExecutionQueueEntity.kt
    - schema.sql
  </files>
  <action>
    1. Create ExecutionQueueStatus enum:
       ```kotlin
       package riven.core.enums.workflow

       /**
        * Status of an execution queue item.
        *
        * Lifecycle: PENDING -> CLAIMED -> DISPATCHED (or FAILED)
        */
       enum class ExecutionQueueStatus {
           PENDING,    // Waiting to be processed
           CLAIMED,    // Being processed by dispatcher (claimed via SKIP LOCKED)
           DISPATCHED, // Successfully sent to Temporal
           FAILED      // Failed after max retries or permanent error
       }
       ```

    2. Create ExecutionQueueEntity in entity/workflow/ package:
       - @Entity, @Table(name = "workflow_execution_queue")
       - Fields:
         - id: UUID (primary key, generated)
         - workspaceId: UUID (not null, references workspaces)
         - workflowDefinitionId: UUID (not null, references workflow_definitions)
         - status: ExecutionQueueStatus (enum, default PENDING)
         - createdAt: ZonedDateTime (not null, default now)
         - claimedAt: ZonedDateTime? (null until claimed)
         - dispatchedAt: ZonedDateTime? (null until dispatched)
         - input: Any? (JSONB via @Type(JsonBinaryType::class))
         - attemptCount: Int (default 0)
         - lastError: String? (null until error)
       - Use existing patterns from WorkflowExecutionEntity (same package conventions)

    3. Add DDL to schema.sql:
       ```sql
       -- Execution Queue table for durable workflow request queuing
       CREATE TABLE IF NOT EXISTS public.workflow_execution_queue (
           id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
           workspace_id UUID NOT NULL REFERENCES workspaces(id) ON DELETE CASCADE,
           workflow_definition_id UUID NOT NULL REFERENCES workflow_definitions(id) ON DELETE CASCADE,
           status VARCHAR(20) NOT NULL DEFAULT 'PENDING'
               CHECK (status IN ('PENDING', 'CLAIMED', 'DISPATCHED', 'FAILED')),
           created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
           claimed_at TIMESTAMPTZ,
           dispatched_at TIMESTAMPTZ,
           input JSONB,
           attempt_count INTEGER NOT NULL DEFAULT 0,
           last_error TEXT
       );

       -- Index for efficient queue polling (pending items by age)
       CREATE INDEX IF NOT EXISTS idx_execution_queue_pending
           ON workflow_execution_queue (status, created_at)
           WHERE status = 'PENDING';

       -- Index for workspace-scoped queries
       CREATE INDEX IF NOT EXISTS idx_execution_queue_workspace
           ON workflow_execution_queue (workspace_id, status);
       ```
  </action>
  <verify>
    - `./gradlew compileKotlin` passes
    - ExecutionQueueEntity.kt exists in entity/workflow/
    - ExecutionQueueStatus.kt exists in enums/workflow/
    - schema.sql contains workflow_execution_queue DDL with indexes
  </verify>
  <done>
    ExecutionQueueEntity and ExecutionQueueStatus created with schema DDL including partial indexes for efficient polling.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ExecutionQueueRepository with SKIP LOCKED</name>
  <files>src/main/kotlin/riven/core/repository/workflow/ExecutionQueueRepository.kt</files>
  <action>
    Create ExecutionQueueRepository in repository/workflow/ package:

    ```kotlin
    package riven.core.repository.workflow

    import org.springframework.data.jpa.repository.JpaRepository
    import org.springframework.data.jpa.repository.Query
    import org.springframework.data.repository.query.Param
    import org.springframework.stereotype.Repository
    import riven.core.entity.workflow.ExecutionQueueEntity
    import riven.core.enums.workflow.ExecutionQueueStatus
    import java.util.UUID

    /**
     * Repository for execution queue persistence with concurrent-safe claiming.
     *
     * Uses PostgreSQL FOR UPDATE SKIP LOCKED for safe concurrent queue consumption.
     * Multiple dispatcher instances can claim items without blocking each other.
     */
    @Repository
    interface ExecutionQueueRepository : JpaRepository<ExecutionQueueEntity, UUID> {

        /**
         * Claim pending execution requests for processing.
         *
         * Uses SKIP LOCKED to allow concurrent consumers:
         * - Claimed rows are locked but other PENDING rows remain available
         * - Prevents duplicate processing across instances
         * - Non-blocking for unclaimed rows
         *
         * @param batchSize Maximum items to claim
         * @return List of claimed entities (caller must update status to CLAIMED)
         */
        @Query("""
            SELECT * FROM workflow_execution_queue
            WHERE status = 'PENDING'
            ORDER BY created_at ASC
            LIMIT :batchSize
            FOR UPDATE SKIP LOCKED
        """, nativeQuery = true)
        fun claimPendingExecutions(@Param("batchSize") batchSize: Int): List<ExecutionQueueEntity>

        /**
         * Find queue items by workspace and status.
         *
         * @param workspaceId Workspace to filter
         * @param status Status to filter
         * @return Queue items ordered by creation time
         */
        fun findByWorkspaceIdAndStatusOrderByCreatedAtAsc(
            workspaceId: UUID,
            status: ExecutionQueueStatus
        ): List<ExecutionQueueEntity>

        /**
         * Count pending items for a workspace.
         *
         * @param workspaceId Workspace to count
         * @return Number of pending queue items
         */
        fun countByWorkspaceIdAndStatus(workspaceId: UUID, status: ExecutionQueueStatus): Int

        /**
         * Find stale claimed items (for recovery after crashes).
         *
         * Items claimed but not dispatched within timeout should be reclaimed.
         * Used by recovery job to prevent stuck items.
         *
         * @param minutesAgo Threshold in minutes (claimed_at older than this)
         * @return Stale claimed items
         */
        @Query("""
            SELECT * FROM workflow_execution_queue
            WHERE status = 'CLAIMED'
            AND claimed_at < (CURRENT_TIMESTAMP - INTERVAL '1 minute' * :minutesAgo)
            FOR UPDATE SKIP LOCKED
        """, nativeQuery = true)
        fun findStaleClaimedItems(@Param("minutesAgo") minutesAgo: Int): List<ExecutionQueueEntity>
    }
    ```

    Key patterns:
    - Native query for SKIP LOCKED (not supported in JPQL)
    - ORDER BY created_at ASC for FIFO ordering (per CONTEXT.md)
    - FOR UPDATE locks claimed rows, SKIP LOCKED skips already-locked rows
    - Recovery query for stale claims (crash protection per RESEARCH.md pitfall #3)
  </action>
  <verify>
    - `./gradlew compileKotlin` passes
    - ExecutionQueueRepository.kt exists with @Repository annotation
    - claimPendingExecutions() uses FOR UPDATE SKIP LOCKED
    - findStaleClaimedItems() exists for crash recovery
  </verify>
  <done>
    ExecutionQueueRepository created with SKIP LOCKED queries for concurrent-safe queue consumption.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create ExecutionQueueService</name>
  <files>src/main/kotlin/riven/core/service/workflow/ExecutionQueueService.kt</files>
  <action>
    Create ExecutionQueueService in service/workflow/ package:

    ```kotlin
    package riven.core.service.workflow

    import io.github.oshai.kotlinlogging.KLogger
    import org.springframework.stereotype.Service
    import org.springframework.transaction.annotation.Transactional
    import riven.core.entity.workflow.ExecutionQueueEntity
    import riven.core.enums.workflow.ExecutionQueueStatus
    import riven.core.exceptions.NotFoundException
    import riven.core.repository.workflow.ExecutionQueueRepository
    import riven.core.repository.workflow.WorkflowDefinitionRepository
    import java.time.ZonedDateTime
    import java.util.UUID

    /**
     * Service for managing the workflow execution queue.
     *
     * Handles:
     * - Enqueueing new execution requests (from API)
     * - Status updates (claimed, dispatched, failed)
     * - Queue position and count queries
     * - Stale claim recovery
     *
     * Does NOT handle: Dispatching to Temporal (see ExecutionDispatcherService)
     */
    @Service
    class ExecutionQueueService(
        private val executionQueueRepository: ExecutionQueueRepository,
        private val workflowDefinitionRepository: WorkflowDefinitionRepository,
        private val logger: KLogger
    ) {

        /**
         * Enqueue a workflow execution request.
         *
         * Creates a PENDING queue item that will be processed by the dispatcher.
         * Returns immediately - actual execution happens asynchronously.
         *
         * @param workspaceId Workspace context
         * @param workflowDefinitionId Workflow to execute
         * @param input Optional input parameters
         * @return Created queue entity with ID
         * @throws NotFoundException if workflow definition not found
         * @throws SecurityException if workflow doesn't belong to workspace
         */
        @Transactional
        fun enqueue(
            workspaceId: UUID,
            workflowDefinitionId: UUID,
            input: Map<String, Any>? = null
        ): ExecutionQueueEntity {
            logger.info { "Enqueueing workflow execution: definition=$workflowDefinitionId, workspace=$workspaceId" }

            // Validate workflow definition exists and belongs to workspace
            val definition = workflowDefinitionRepository.findById(workflowDefinitionId)
                .orElseThrow { NotFoundException("Workflow definition not found: $workflowDefinitionId") }

            if (definition.workspaceId != workspaceId) {
                throw SecurityException("Workflow definition $workflowDefinitionId does not belong to workspace $workspaceId")
            }

            val queueEntity = ExecutionQueueEntity(
                workspaceId = workspaceId,
                workflowDefinitionId = workflowDefinitionId,
                status = ExecutionQueueStatus.PENDING,
                createdAt = ZonedDateTime.now(),
                input = input
            )

            val saved = executionQueueRepository.save(queueEntity)
            logger.info { "Enqueued execution: id=${saved.id}" }

            return saved
        }

        /**
         * Mark queue item as claimed.
         *
         * Called by dispatcher after claiming via SKIP LOCKED.
         * Sets status to CLAIMED and records claim time.
         *
         * @param entity Entity to mark claimed
         * @return Updated entity
         */
        @Transactional
        fun markClaimed(entity: ExecutionQueueEntity): ExecutionQueueEntity {
            entity.status = ExecutionQueueStatus.CLAIMED
            entity.claimedAt = ZonedDateTime.now()
            return executionQueueRepository.save(entity)
        }

        /**
         * Mark queue item as dispatched.
         *
         * Called by dispatcher after successful Temporal workflow start.
         *
         * @param entity Entity to mark dispatched
         * @return Updated entity
         */
        @Transactional
        fun markDispatched(entity: ExecutionQueueEntity): ExecutionQueueEntity {
            entity.status = ExecutionQueueStatus.DISPATCHED
            entity.dispatchedAt = ZonedDateTime.now()
            return executionQueueRepository.save(entity)
        }

        /**
         * Mark queue item as failed.
         *
         * Called by dispatcher when execution cannot proceed (permanent error or max retries).
         *
         * @param entity Entity to mark failed
         * @param error Error message
         * @return Updated entity
         */
        @Transactional
        fun markFailed(entity: ExecutionQueueEntity, error: String): ExecutionQueueEntity {
            entity.status = ExecutionQueueStatus.FAILED
            entity.attemptCount = entity.attemptCount + 1
            entity.lastError = error
            return executionQueueRepository.save(entity)
        }

        /**
         * Release a claimed item back to pending (for retry).
         *
         * Used when dispatch fails but retry is possible.
         *
         * @param entity Entity to release
         * @return Updated entity
         */
        @Transactional
        fun releaseToPending(entity: ExecutionQueueEntity): ExecutionQueueEntity {
            entity.status = ExecutionQueueStatus.PENDING
            entity.claimedAt = null
            entity.attemptCount = entity.attemptCount + 1
            return executionQueueRepository.save(entity)
        }

        /**
         * Get pending queue count for a workspace.
         *
         * @param workspaceId Workspace to query
         * @return Number of pending executions
         */
        fun getPendingCount(workspaceId: UUID): Int {
            return executionQueueRepository.countByWorkspaceIdAndStatus(
                workspaceId,
                ExecutionQueueStatus.PENDING
            )
        }

        /**
         * Recover stale claimed items.
         *
         * Items claimed but not dispatched within timeout are released back to PENDING.
         * Prevents items from being stuck after dispatcher crashes.
         *
         * @param timeoutMinutes Threshold for stale claims
         * @return Number of items recovered
         */
        @Transactional
        fun recoverStaleItems(timeoutMinutes: Int = 5): Int {
            val staleItems = executionQueueRepository.findStaleClaimedItems(timeoutMinutes)

            if (staleItems.isEmpty()) {
                return 0
            }

            logger.warn { "Recovering ${staleItems.size} stale claimed items (claimed > $timeoutMinutes minutes ago)" }

            staleItems.forEach { item ->
                releaseToPending(item)
            }

            return staleItems.size
        }
    }
    ```

    Key patterns:
    - Constructor injection (not field injection)
    - KLogger for logging
    - @Transactional on write operations
    - Validation before enqueue (workspace ownership)
    - Recovery method for stale claims (crash protection)
  </action>
  <verify>
    - `./gradlew compileKotlin` passes
    - ExecutionQueueService.kt exists in service/workflow/
    - enqueue() validates workspace ownership
    - markClaimed(), markDispatched(), markFailed() status transitions
    - recoverStaleItems() for crash recovery
  </verify>
  <done>
    ExecutionQueueService created with enqueue, status transitions, and stale claim recovery.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Build verification:
   ```bash
   ./gradlew compileKotlin
   ```

2. Schema complete:
   - workflow_execution_queue table DDL in schema.sql
   - Indexes for efficient polling

3. Entity layer complete:
   - ExecutionQueueStatus enum with all states
   - ExecutionQueueEntity with all required fields

4. Repository layer complete:
   - SKIP LOCKED query for concurrent claiming
   - Stale claim recovery query

5. Service layer complete:
   - enqueue() with validation
   - Status transition methods
   - Stale recovery method
</verification>

<success_criteria>
- ExecutionQueueStatus enum created with PENDING, CLAIMED, DISPATCHED, FAILED
- ExecutionQueueEntity created with all required fields
- workflow_execution_queue DDL added to schema.sql with indexes
- ExecutionQueueRepository created with SKIP LOCKED queries
- ExecutionQueueService created with enqueue and status management
- ./gradlew compileKotlin passes without errors
</success_criteria>

<output>
After completion, create `.planning/phases/06.1-execution-queue-management/06.1-02-SUMMARY.md`
</output>
