---
phase: 06.1-execution-queue-management
plan: 03
type: execute
wave: 2
depends_on: ["06.1-01", "06.1-02"]
files_modified:
  - src/main/kotlin/riven/core/configuration/workflow/TemporalWorkerConfiguration.kt
  - src/main/kotlin/riven/core/service/workflow/ExecutionDispatcherService.kt
  - src/main/kotlin/riven/core/repository/workflow/WorkflowExecutionRepository.kt
  - src/main/kotlin/riven/core/service/workflow/WorkflowExecutionService.kt
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Workers poll workspace-specific task queues for tenant isolation"
    - "ExecutionDispatcherService processes queue with tier-based capacity checks"
    - "WorkflowExecutionService enqueues instead of direct dispatch"
    - "Queue processor runs on schedule with distributed locking"
  artifacts:
    - path: "src/main/kotlin/riven/core/configuration/workflow/TemporalWorkerConfiguration.kt"
      provides: "Multi-queue worker registration"
      exports: ["workerFactory", "WORKFLOWS_DEFAULT_QUEUE", "workspaceQueue"]
    - path: "src/main/kotlin/riven/core/service/workflow/ExecutionDispatcherService.kt"
      provides: "Scheduled queue processor with capacity checks"
      exports: ["ExecutionDispatcherService"]
    - path: "src/main/kotlin/riven/core/service/workflow/WorkflowExecutionService.kt"
      provides: "Queue-based execution start"
      exports: ["startExecution"]
  key_links:
    - from: "ExecutionDispatcherService.kt"
      to: "ShedLockConfiguration.kt"
      via: "@SchedulerLock annotation"
      pattern: "@SchedulerLock"
    - from: "ExecutionDispatcherService.kt"
      to: "WorkspaceTier.kt"
      via: "capacity check"
      pattern: "WorkspaceTier\\.fromPlan"
    - from: "WorkflowExecutionService.kt"
      to: "ExecutionQueueService.kt"
      via: "enqueue call"
      pattern: "executionQueueService\\.enqueue"
---

<objective>
Implement multi-queue Temporal workers, the execution dispatcher service, and modify WorkflowExecutionService to use the queue.

Purpose: Complete the execution queue management system with workspace isolation, tier-based concurrency enforcement, and scheduled queue processing.

Output: Refactored TemporalWorkerConfiguration with multi-queue support, ExecutionDispatcherService with @Scheduled processing, modified WorkflowExecutionService using queue.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06.1-execution-queue-management/06.1-CONTEXT.md
@.planning/phases/06.1-execution-queue-management/06.1-RESEARCH.md
@.planning/phases/06.1-execution-queue-management/06.1-01-SUMMARY.md
@.planning/phases/06.1-execution-queue-management/06.1-02-SUMMARY.md
@src/main/kotlin/riven/core/configuration/workflow/TemporalWorkerConfiguration.kt
@src/main/kotlin/riven/core/service/workflow/WorkflowExecutionService.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor TemporalWorkerConfiguration for multi-queue support</name>
  <files>src/main/kotlin/riven/core/configuration/workflow/TemporalWorkerConfiguration.kt</files>
  <action>
    Refactor TemporalWorkerConfiguration to support multiple task queues per CONTEXT.md decisions:

    1. Define queue naming constants:
       - WORKFLOWS_DEFAULT_QUEUE = "workflows.default" (system/internal workflows)
       - ACTIVITIES_EXTERNAL_API_QUEUE = "activities.external-api" (external API activities)
       - workspaceQueue(workspaceId: UUID) = "workflow.workspace.$workspaceId" (per-workspace)

    2. Update workerFactory() to register workers for multiple queues:
       - Default queue worker: registers WorkflowOrchestrationServiceImpl + activities
       - External API queue worker: placeholder for future external API activities

    3. Add method to ensure workspace worker exists:
       - For now, use the default queue for all workspaces (simplest approach)
       - Comment explaining future per-workspace worker registration

    Key changes from current implementation:
    - Rename WORKFLOW_EXECUTION_TASK_QUEUE to WORKFLOWS_DEFAULT_QUEUE
    - Add companion object functions for queue naming
    - Keep existing workflow/activity registration on default queue

    Note: Per RESEARCH.md, dynamic worker registration for new workspaces is complex.
    V1 approach: Route all workspaces through default queue. Future: per-workspace queues.

    ```kotlin
    companion object {
        /** Default queue for system/internal workflows */
        const val WORKFLOWS_DEFAULT_QUEUE = "workflows.default"

        /** Queue for external API activities (isolation) */
        const val ACTIVITIES_EXTERNAL_API_QUEUE = "activities.external-api"

        /** Generate task queue name for a workspace */
        fun workspaceQueue(workspaceId: UUID): String = "workflow.workspace.$workspaceId"
    }
    ```

    For V1, keep using default queue but structure supports future per-workspace queues.
  </action>
  <verify>
    - `./gradlew compileKotlin` passes
    - TemporalWorkerConfiguration.kt has WORKFLOWS_DEFAULT_QUEUE constant
    - workspaceQueue() companion function exists
    - Worker still registers correctly (no functional change to current behavior)
  </verify>
  <done>
    TemporalWorkerConfiguration refactored with multi-queue naming support. V1 uses default queue; structure ready for per-workspace queues.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add active execution count query to WorkflowExecutionRepository</name>
  <files>src/main/kotlin/riven/core/repository/workflow/WorkflowExecutionRepository.kt</files>
  <action>
    Add a query to count active (RUNNING) executions per workspace:

    ```kotlin
    /**
     * Count active workflow executions for a workspace.
     *
     * Used by ExecutionDispatcherService to check tier capacity.
     * Active = RUNNING status (workflow started but not completed).
     *
     * @param workspaceId Workspace to count
     * @return Number of currently running executions
     */
    @Query("""
        SELECT COUNT(*) FROM workflow_executions
        WHERE workspace_id = :workspaceId
        AND status = 'RUNNING'
    """, nativeQuery = true)
    fun countActiveByWorkspace(@Param("workspaceId") workspaceId: UUID): Int
    ```

    Add necessary imports:
    - org.springframework.data.jpa.repository.Query
    - org.springframework.data.repository.query.Param

    This query is used by ExecutionDispatcherService to enforce tier-based concurrency limits.
  </action>
  <verify>
    - `./gradlew compileKotlin` passes
    - countActiveByWorkspace() method exists with @Query annotation
    - Query filters by workspace_id and status = 'RUNNING'
  </verify>
  <done>
    WorkflowExecutionRepository has countActiveByWorkspace() for capacity checking.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create ExecutionDispatcherService</name>
  <files>src/main/kotlin/riven/core/service/workflow/ExecutionDispatcherService.kt</files>
  <action>
    Create ExecutionDispatcherService that processes the execution queue:

    ```kotlin
    package riven.core.service.workflow

    import io.github.oshai.kotlinlogging.KLogger
    import io.temporal.client.WorkflowClient
    import io.temporal.client.WorkflowOptions
    import net.javacrumbs.shedlock.spring.annotation.SchedulerLock
    import org.springframework.scheduling.annotation.Scheduled
    import org.springframework.stereotype.Service
    import org.springframework.transaction.annotation.Transactional
    import riven.core.configuration.workflow.TemporalWorkerConfiguration
    import riven.core.entity.workflow.ExecutionQueueEntity
    import riven.core.entity.workflow.execution.WorkflowExecutionEntity
    import riven.core.enums.workflow.ExecutionQueueStatus
    import riven.core.enums.workflow.WorkflowStatus
    import riven.core.enums.workflow.WorkflowTriggerType
    import riven.core.enums.workspace.WorkspaceTier
    import riven.core.models.workflow.engine.WorkflowExecutionInput
    import riven.core.repository.workflow.ExecutionQueueRepository
    import riven.core.repository.workflow.WorkflowDefinitionRepository
    import riven.core.repository.workflow.WorkflowDefinitionVersionRepository
    import riven.core.repository.workflow.WorkflowExecutionRepository
    import riven.core.repository.workspace.WorkspaceRepository
    import riven.core.service.workflow.engine.WorkflowOrchestration
    import java.time.ZonedDateTime
    import java.util.UUID

    /**
     * Service that processes the execution queue and dispatches to Temporal.
     *
     * Runs on a schedule with distributed locking (ShedLock) to ensure
     * only one instance processes the queue at a time across deployments.
     *
     * Flow:
     * 1. Claim pending items via SKIP LOCKED
     * 2. For each item, check workspace tier capacity
     * 3. If capacity available, dispatch to Temporal and mark DISPATCHED
     * 4. If at capacity, leave in queue (will retry next poll)
     * 5. On error, mark FAILED or release for retry
     */
    @Service
    class ExecutionDispatcherService(
        private val executionQueueRepository: ExecutionQueueRepository,
        private val executionQueueService: ExecutionQueueService,
        private val workflowExecutionRepository: WorkflowExecutionRepository,
        private val workflowDefinitionRepository: WorkflowDefinitionRepository,
        private val workflowDefinitionVersionRepository: WorkflowDefinitionVersionRepository,
        private val workspaceRepository: WorkspaceRepository,
        private val workflowClient: WorkflowClient,
        private val logger: KLogger
    ) {

        companion object {
            /** Batch size for queue processing */
            const val BATCH_SIZE = 10

            /** Polling interval in milliseconds (5 seconds) */
            const val POLL_INTERVAL_MS = 5000L

            /** Maximum dispatch attempts before marking FAILED */
            const val MAX_ATTEMPTS = 3
        }

        /**
         * Process the execution queue.
         *
         * Called on fixed delay schedule with distributed lock.
         * Only one instance across the cluster processes at a time.
         */
        @Scheduled(fixedDelay = POLL_INTERVAL_MS)
        @SchedulerLock(
            name = "processExecutionQueue",
            lockAtMostFor = "4m",
            lockAtLeastFor = "10s"
        )
        @Transactional
        fun processQueue() {
            val pending = executionQueueRepository.claimPendingExecutions(BATCH_SIZE)

            if (pending.isEmpty()) {
                return
            }

            logger.debug { "Processing ${pending.size} queue items" }

            for (item in pending) {
                try {
                    processQueueItem(item)
                } catch (e: Exception) {
                    handleProcessingError(item, e)
                }
            }
        }

        /**
         * Process a single queue item.
         *
         * Checks workspace capacity and dispatches if available.
         */
        private fun processQueueItem(item: ExecutionQueueEntity) {
            // Mark as claimed
            executionQueueService.markClaimed(item)

            // Get workspace and check tier capacity
            val workspace = workspaceRepository.findById(item.workspaceId).orElse(null)
            if (workspace == null) {
                logger.warn { "Workspace ${item.workspaceId} not found, marking item ${item.id} as failed" }
                executionQueueService.markFailed(item, "Workspace not found")
                return
            }

            val tier = WorkspaceTier.fromPlan(workspace.plan)
            val activeCount = workflowExecutionRepository.countActiveByWorkspace(item.workspaceId)

            if (activeCount >= tier.maxConcurrentWorkflows) {
                // At capacity - release back to pending for later retry
                logger.info {
                    "Workspace ${item.workspaceId} at capacity ($activeCount/${tier.maxConcurrentWorkflows}), " +
                    "releasing item ${item.id} back to queue"
                }
                executionQueueService.releaseToPending(item)
                return
            }

            // Capacity available - dispatch to Temporal
            dispatchToTemporal(item)
        }

        /**
         * Dispatch queue item to Temporal.
         */
        private fun dispatchToTemporal(item: ExecutionQueueEntity) {
            logger.info { "Dispatching queue item ${item.id} for workflow ${item.workflowDefinitionId}" }

            // Fetch workflow definition and version
            val workflowDefinition = workflowDefinitionRepository.findById(item.workflowDefinitionId).orElse(null)
            if (workflowDefinition == null) {
                executionQueueService.markFailed(item, "Workflow definition not found")
                return
            }

            val workflowVersion = workflowDefinitionVersionRepository
                .findByWorkflowDefinitionIdAndVersionNumber(
                    item.workflowDefinitionId,
                    workflowDefinition.versionNumber
                )
            if (workflowVersion == null) {
                executionQueueService.markFailed(item, "Workflow version not found")
                return
            }

            // Extract node IDs
            val nodeIds = extractNodeIds(workflowVersion.workflow)

            // Create execution record
            val executionId = UUID.randomUUID()
            val engineWorkflowId = UUID.randomUUID()
            val engineRunId = UUID.randomUUID()

            val executionEntity = WorkflowExecutionEntity(
                workspaceId = item.workspaceId,
                workflowDefinitionId = item.workflowDefinitionId,
                workflowVersionId = workflowVersion.id!!,
                engineWorkflowId = engineWorkflowId,
                engineRunId = engineRunId,
                status = WorkflowStatus.RUNNING,
                triggerType = WorkflowTriggerType.FUNCTION,
                startedAt = ZonedDateTime.now(),
                completedAt = null,
                durationMs = 0,
                error = emptyMap<String, Any>(),
                input = item.input,
                output = null
            )

            val savedExecution = workflowExecutionRepository.save(executionEntity)
            val savedExecutionId = savedExecution.id!!

            // Start Temporal workflow
            try {
                val workflowStub = workflowClient.newWorkflowStub(
                    WorkflowOrchestration::class.java,
                    WorkflowOptions.newBuilder()
                        .setWorkflowId("execution-$savedExecutionId")
                        .setTaskQueue(TemporalWorkerConfiguration.WORKFLOWS_DEFAULT_QUEUE)
                        .build()
                )

                val workflowInput = WorkflowExecutionInput(
                    workflowDefinitionId = item.workflowDefinitionId,
                    nodeIds = nodeIds,
                    workspaceId = item.workspaceId
                )

                WorkflowClient.start { workflowStub.execute(workflowInput) }

                // Mark queue item as dispatched
                executionQueueService.markDispatched(item)

                logger.info { "Dispatched execution $savedExecutionId for queue item ${item.id}" }

            } catch (e: Exception) {
                logger.error(e) { "Failed to start Temporal workflow for queue item ${item.id}" }

                // Update execution record to FAILED
                val failedExecution = savedExecution.copy(
                    status = WorkflowStatus.FAILED,
                    completedAt = ZonedDateTime.now(),
                    error = mapOf("message" to (e.message ?: "Unknown error"))
                )
                workflowExecutionRepository.save(failedExecution)

                throw e // Re-throw to trigger error handling
            }
        }

        /**
         * Handle processing error for a queue item.
         */
        private fun handleProcessingError(item: ExecutionQueueEntity, error: Exception) {
            logger.error(error) { "Error processing queue item ${item.id}" }

            if (item.attemptCount >= MAX_ATTEMPTS) {
                // Max attempts reached - mark as failed
                executionQueueService.markFailed(item, error.message ?: "Unknown error")
            } else {
                // Release for retry
                executionQueueService.releaseToPending(item)
            }
        }

        /**
         * Extract node IDs from workflow definition.
         * (Copied from WorkflowExecutionService - consider extracting to shared utility)
         */
        @Suppress("UNCHECKED_CAST")
        private fun extractNodeIds(workflow: Any): List<UUID> {
            if (workflow is Map<*, *>) {
                val nodes = workflow["nodes"] as? List<*>
                if (nodes != null) {
                    return nodes.mapNotNull { node ->
                        if (node is Map<*, *>) {
                            val idValue = node["id"]
                            when (idValue) {
                                is String -> try {
                                    UUID.fromString(idValue)
                                } catch (e: IllegalArgumentException) { null }
                                is UUID -> idValue
                                else -> null
                            }
                        } else null
                    }
                }
            }
            logger.warn { "Could not extract node IDs from workflow" }
            return emptyList()
        }

        /**
         * Recover stale claimed items.
         *
         * Runs less frequently than main queue processing.
         * Recovers items stuck in CLAIMED state after dispatcher crash.
         */
        @Scheduled(fixedDelay = 60000) // Every minute
        @SchedulerLock(
            name = "recoverStaleQueueItems",
            lockAtMostFor = "2m",
            lockAtLeastFor = "30s"
        )
        fun recoverStaleItems() {
            val recovered = executionQueueService.recoverStaleItems(5)
            if (recovered > 0) {
                logger.info { "Recovered $recovered stale queue items" }
            }
        }
    }
    ```

    Key features:
    - @Scheduled with fixed delay (5 seconds)
    - @SchedulerLock for distributed safety
    - Tier-based capacity checking
    - Release back to queue when at capacity
    - Stale item recovery on separate schedule
    - MAX_ATTEMPTS before permanent failure
  </action>
  <verify>
    - `./gradlew compileKotlin` passes
    - ExecutionDispatcherService.kt exists with @Scheduled annotation
    - processQueue() has @SchedulerLock annotation
    - Capacity check uses WorkspaceTier.fromPlan()
    - Dispatches to WORKFLOWS_DEFAULT_QUEUE
  </verify>
  <done>
    ExecutionDispatcherService created with scheduled queue processing, capacity checks, and stale recovery.
  </done>
</task>

<task type="auto">
  <name>Task 4: Modify WorkflowExecutionService to use queue</name>
  <files>src/main/kotlin/riven/core/service/workflow/WorkflowExecutionService.kt</files>
  <action>
    Modify WorkflowExecutionService to enqueue instead of direct dispatch:

    1. Add ExecutionQueueService dependency via constructor injection

    2. Modify startExecution() method:
       - Instead of creating execution record and dispatching to Temporal directly
       - Call executionQueueService.enqueue() to queue the request
       - Return response indicating execution is queued (not started)
       - Remove direct Temporal workflow start code (moved to ExecutionDispatcherService)

    3. Keep validation logic (workspace ownership check)

    4. Update return value to reflect queued status:
       ```kotlin
       return mapOf(
           "queueId" to savedQueueItem.id,
           "status" to "QUEUED",
           "message" to "Workflow execution queued. Will start when capacity available."
       )
       ```

    5. Update method documentation to reflect new behavior

    The key change: startExecution() now queues instead of dispatches.
    Actual dispatch happens in ExecutionDispatcherService.processQueue().

    Keep the activity logging but adjust details to reflect queueing.
  </action>
  <verify>
    - `./gradlew compileKotlin` passes
    - WorkflowExecutionService.kt has ExecutionQueueService dependency
    - startExecution() calls executionQueueService.enqueue()
    - No direct Temporal WorkflowClient.start() in startExecution()
    - Returns "QUEUED" status instead of "STARTED"
  </verify>
  <done>
    WorkflowExecutionService modified to enqueue execution requests instead of direct dispatch.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Build verification:
   ```bash
   ./gradlew compileKotlin
   ```

2. Multi-queue configuration:
   - TemporalWorkerConfiguration has queue naming constants
   - workspaceQueue() function generates workspace-specific names

3. Capacity tracking:
   - WorkflowExecutionRepository.countActiveByWorkspace() exists
   - ExecutionDispatcherService checks tier limits before dispatch

4. Queue processing:
   - ExecutionDispatcherService has @Scheduled processQueue()
   - Uses @SchedulerLock for distributed safety
   - Releases items back to queue when at capacity
   - Stale recovery runs separately

5. Integration:
   - WorkflowExecutionService enqueues instead of direct dispatch
   - Returns "QUEUED" status to caller
</verification>

<success_criteria>
- TemporalWorkerConfiguration refactored with multi-queue naming
- WorkflowExecutionRepository has countActiveByWorkspace() query
- ExecutionDispatcherService created with scheduled processing and capacity checks
- WorkflowExecutionService modified to use queue
- All @SchedulerLock annotations use correct lock names
- ./gradlew compileKotlin passes without errors
</success_criteria>

<output>
After completion, create `.planning/phases/06.1-execution-queue-management/06.1-03-SUMMARY.md`
</output>
