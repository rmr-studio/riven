# Phase 6.1: Execution Queue Management - Research

**Researched:** 2026-01-19
**Domain:** Temporal multi-queue workers, database-backed execution queue, workspace tier-based concurrency limits
**Confidence:** HIGH

## Summary

Researched the ecosystem for implementing execution queue management with Temporal Java SDK, database-backed queuing, and workspace-based concurrency limits. The architecture involves three complementary systems:

1. **Temporal Task Queue Organization** - Multiple Worker entities within a single WorkerFactory, each polling a dedicated task queue (workspace queues, default queue, external-api queue)
2. **Application-Level Queue** - PostgreSQL-backed queue using `FOR UPDATE SKIP LOCKED` pattern for durability and concurrency-safe job claiming
3. **Concurrency Enforcement** - Workspace tier enum defines limits; application tracks active executions before dispatching to Temporal

Key finding: **Don't manage concurrency at the Temporal level.** Temporal task queues don't have built-in per-tenant rate limiting. The application layer must track active executions per workspace and gate dispatching to Temporal based on workspace tier limits.

**Primary recommendation:** Implement a database-backed execution queue table. A polling scheduler (`@Scheduled` with ShedLock for distributed safety) claims pending jobs using `SKIP LOCKED`, checks workspace active execution count, and dispatches to the appropriate Temporal task queue only when capacity allows. Track active executions by counting `RUNNING` status in `workflow_executions` table.

## Standard Stack

The established libraries/tools for this domain:

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| io.temporal:temporal-sdk | 1.24.1 | Temporal Java SDK | Already in project, multi-worker support |
| io.temporal:temporal-spring-boot-starter | 1.31.0 | Spring Boot integration | Already in project, autoconfigure support |
| Spring Data JPA | (Spring managed) | Database queue persistence | Already in project, SKIP LOCKED support via native queries |
| ShedLock | 7.5.0 | Distributed scheduler lock | Prevents duplicate queue processing across instances |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| Spring @Scheduled | (Spring managed) | Polling trigger | Queue processing scheduler |
| PostgreSQL SKIP LOCKED | Native SQL | Concurrent job claiming | Multi-instance queue consumers |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Database queue | Redis/RabbitMQ | External dependency; PostgreSQL sufficient for this scale, already in stack |
| ShedLock | Leader election | ShedLock simpler for single-task locking; leader election overkill |
| Per-workspace task queues | Single shared queue | Per-workspace enables future per-tenant worker scaling |

**Installation (Gradle Kotlin DSL):**
```kotlin
dependencies {
    // Already present
    implementation("io.temporal:temporal-sdk:1.24.1")
    implementation("io.temporal:temporal-spring-boot-starter:1.31.0")

    // Add for distributed scheduling lock
    implementation("net.javacrumbs.shedlock:shedlock-spring:7.5.0")
    implementation("net.javacrumbs.shedlock:shedlock-provider-jdbc-template:7.5.0")
}
```

**Database Table (shedlock):**
```sql
CREATE TABLE shedlock (
    name VARCHAR(64) PRIMARY KEY,
    lock_until TIMESTAMP(3) NOT NULL,
    locked_at TIMESTAMP(3) NOT NULL,
    locked_by VARCHAR(255) NOT NULL
);
```

## Architecture Patterns

### Recommended Project Structure
```
src/main/kotlin/riven/core/
├── configuration/
│   └── workflow/
│       ├── TemporalEngineConfiguration.kt      # Existing
│       ├── TemporalWorkerConfiguration.kt      # Refactor for multi-queue
│       └── ShedLockConfiguration.kt            # NEW - distributed lock
├── entity/
│   └── workflow/
│       └── ExecutionQueueEntity.kt             # NEW - queue table entity
├── enums/
│   └── workspace/
│       └── WorkspaceTier.kt                    # NEW or extend WorkspacePlan
├── repository/
│   └── workflow/
│       └── ExecutionQueueRepository.kt         # NEW - queue data access
├── service/
│   └── workflow/
│       ├── WorkflowExecutionService.kt         # Modify - queue instead of direct dispatch
│       ├── ExecutionQueueService.kt            # NEW - queue management
│       └── ExecutionDispatcherService.kt       # NEW - queue processor
```

### Pattern 1: Multi-Queue Worker Configuration
**What:** Create multiple Worker entities within single WorkerFactory, each polling different task queue
**When to use:** Tenant isolation, activity separation, workload partitioning
**Example:**
```kotlin
// Source: Temporal Java SDK docs - WorkerFactory supports multiple workers
@Configuration
class TemporalWorkerConfiguration(
    private val workflowServiceStubs: WorkflowServiceStubs,
    private val coordinationService: WorkflowCoordinationService,
    private val logger: KLogger
) {
    companion object {
        const val DEFAULT_QUEUE = "workflows.default"
        const val EXTERNAL_API_QUEUE = "activities.external-api"
        fun workspaceQueue(workspaceId: UUID) = "workflow.workspace.$workspaceId"
    }

    private lateinit var workerFactoryInstance: WorkerFactory

    @Bean
    fun workerFactory(): WorkerFactory {
        val client = WorkflowClient.newInstance(workflowServiceStubs)
        val factory = WorkerFactory.newInstance(client)

        // Default queue worker - system/internal workflows
        val defaultWorker = factory.newWorker(DEFAULT_QUEUE)
        defaultWorker.registerWorkflowImplementationTypes(WorkflowOrchestrationServiceImpl::class.java)
        defaultWorker.registerActivitiesImplementations(coordinationService)

        // External API activities worker - separate for isolation
        val externalApiWorker = factory.newWorker(EXTERNAL_API_QUEUE)
        // Register external API activities here

        factory.start()
        workerFactoryInstance = factory
        return factory
    }

    // Dynamic workspace queue registration (called when workspace executes first workflow)
    fun ensureWorkspaceWorker(workspaceId: UUID) {
        // Workers for workspace queues can be created on-demand
        // or pre-registered for known active workspaces
    }

    @PreDestroy
    fun shutdown() {
        if (::workerFactoryInstance.isInitialized) {
            workerFactoryInstance.shutdown()
        }
    }
}
```

### Pattern 2: Database-Backed Execution Queue
**What:** PostgreSQL table stores pending execution requests; scheduler claims and dispatches
**When to use:** Durability requirements, concurrency control, restart safety
**Example:**
```kotlin
// Entity
@Entity
@Table(name = "workflow_execution_queue")
data class ExecutionQueueEntity(
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    val id: UUID? = null,

    @Column(name = "workspace_id", nullable = false)
    val workspaceId: UUID,

    @Column(name = "workflow_definition_id", nullable = false)
    val workflowDefinitionId: UUID,

    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false)
    var status: ExecutionQueueStatus = ExecutionQueueStatus.PENDING,

    @Column(name = "created_at", nullable = false)
    val createdAt: ZonedDateTime = ZonedDateTime.now(),

    @Column(name = "claimed_at")
    var claimedAt: ZonedDateTime? = null,

    @Column(name = "dispatched_at")
    var dispatchedAt: ZonedDateTime? = null,

    @Type(JsonBinaryType::class)
    @Column(name = "input", columnDefinition = "jsonb")
    val input: Map<String, Any>? = null,

    @Column(name = "attempt_count", nullable = false)
    var attemptCount: Int = 0,

    @Column(name = "last_error")
    var lastError: String? = null
)

enum class ExecutionQueueStatus {
    PENDING,    // Waiting to be processed
    CLAIMED,    // Being processed by a dispatcher
    DISPATCHED, // Sent to Temporal
    FAILED      // Failed after max retries
}
```

### Pattern 3: SKIP LOCKED Queue Consumer
**What:** Use PostgreSQL `FOR UPDATE SKIP LOCKED` for concurrent job claiming
**When to use:** Multiple application instances processing same queue
**Example:**
```kotlin
// Repository with native query
interface ExecutionQueueRepository : JpaRepository<ExecutionQueueEntity, UUID> {

    @Query("""
        SELECT * FROM workflow_execution_queue
        WHERE status = 'PENDING'
        ORDER BY created_at ASC
        LIMIT :batchSize
        FOR UPDATE SKIP LOCKED
    """, nativeQuery = true)
    fun claimPendingExecutions(@Param("batchSize") batchSize: Int): List<ExecutionQueueEntity>

    @Query("""
        SELECT COUNT(*) FROM workflow_executions
        WHERE workspace_id = :workspaceId
        AND status = 'RUNNING'
    """, nativeQuery = true)
    fun countActiveExecutions(@Param("workspaceId") workspaceId: UUID): Int

    fun findByWorkspaceIdAndStatusOrderByCreatedAtAsc(
        workspaceId: UUID,
        status: ExecutionQueueStatus
    ): List<ExecutionQueueEntity>
}
```

### Pattern 4: Workspace Tier Enum with Concurrency Limits
**What:** Enum defines max concurrent executions per workspace tier
**When to use:** Tier-based billing, resource isolation
**Example:**
```kotlin
// Source: Kotlin enum classes with properties pattern
enum class WorkspaceTier(
    val maxConcurrentWorkflows: Int,
    val displayName: String
) {
    FREE(1, "Free"),
    STARTUP(3, "Startup"),
    SCALE(5, "Scale"),
    ENTERPRISE(10, "Enterprise");

    companion object {
        fun fromPlan(plan: WorkspacePlan): WorkspaceTier = when (plan) {
            WorkspacePlan.FREE -> FREE
            WorkspacePlan.STARTUP -> STARTUP
            WorkspacePlan.SCALE -> SCALE
            WorkspacePlan.ENTERPRISE -> ENTERPRISE
        }
    }
}

// Extension for WorkspaceEntity
fun WorkspaceEntity.tier(): WorkspaceTier = WorkspaceTier.fromPlan(this.plan)
```

### Pattern 5: Polling Scheduler with ShedLock
**What:** `@Scheduled` with distributed lock prevents duplicate processing across instances
**When to use:** Distributed deployments, multiple application instances
**Example:**
```kotlin
// Source: ShedLock + Spring @Scheduled pattern
@Configuration
@EnableScheduling
@EnableSchedulerLock(defaultLockAtMostFor = "5m")
class ShedLockConfiguration {
    @Bean
    fun lockProvider(dataSource: DataSource): LockProvider {
        return JdbcTemplateLockProvider(
            JdbcTemplateLockProvider.Configuration.builder()
                .withJdbcTemplate(JdbcTemplate(dataSource))
                .usingDbTime()
                .build()
        )
    }
}

@Service
class ExecutionDispatcherService(
    private val queueRepository: ExecutionQueueRepository,
    private val workspaceRepository: WorkspaceRepository,
    private val workflowClient: WorkflowClient,
    private val logger: KLogger
) {
    companion object {
        const val BATCH_SIZE = 10
        const val POLL_INTERVAL_MS = 5000L
    }

    @Scheduled(fixedDelay = POLL_INTERVAL_MS)
    @SchedulerLock(
        name = "processExecutionQueue",
        lockAtMostFor = "4m",
        lockAtLeastFor = "10s"
    )
    @Transactional
    fun processQueue() {
        val pending = queueRepository.claimPendingExecutions(BATCH_SIZE)

        for (item in pending) {
            try {
                processQueueItem(item)
            } catch (e: Exception) {
                handleFailure(item, e)
            }
        }
    }

    private fun processQueueItem(item: ExecutionQueueEntity) {
        val workspace = workspaceRepository.findById(item.workspaceId)
            .orElseThrow { NotFoundException("Workspace not found") }

        val tier = WorkspaceTier.fromPlan(workspace.plan)
        val activeCount = queueRepository.countActiveExecutions(item.workspaceId)

        if (activeCount >= tier.maxConcurrentWorkflows) {
            // Workspace at capacity - leave in queue
            logger.info { "Workspace ${item.workspaceId} at capacity ($activeCount/${tier.maxConcurrentWorkflows})" }
            return
        }

        // Dispatch to Temporal
        dispatchToTemporal(item, workspace)
    }

    private fun dispatchToTemporal(item: ExecutionQueueEntity, workspace: WorkspaceEntity) {
        val taskQueue = "workflow.workspace.${workspace.id}"

        // Create and start workflow
        val workflowStub = workflowClient.newWorkflowStub(
            WorkflowOrchestration::class.java,
            WorkflowOptions.newBuilder()
                .setWorkflowId("execution-${item.id}")
                .setTaskQueue(taskQueue)
                .build()
        )

        WorkflowClient.start { workflowStub.execute(/* input */) }

        // Update queue item
        item.status = ExecutionQueueStatus.DISPATCHED
        item.dispatchedAt = ZonedDateTime.now()
        queueRepository.save(item)
    }
}
```

### Anti-Patterns to Avoid
- **Temporal-level rate limiting for tenants:** Task queues don't have per-tenant limits; application must enforce
- **Single shared queue without workspace isolation:** Noisy neighbor problem; use per-workspace queues
- **Polling without distributed lock:** Multiple instances process same items; use ShedLock
- **In-memory queue:** Lost on restart; use database-backed queue
- **Blocking on queue full:** Don't wait synchronously; queue and return immediately

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Distributed scheduler lock | Custom database locking | ShedLock | Battle-tested, handles clock skew, multiple backends |
| Concurrent job claiming | Custom transaction isolation | `FOR UPDATE SKIP LOCKED` | PostgreSQL native, lock-free for unclaimed rows |
| Multi-queue workers | Custom thread pools | Temporal WorkerFactory | Single factory manages multiple workers correctly |
| Workflow execution tracking | Custom state machine | Temporal workflow status | Event-sourced, durable, queryable |
| Retry with backoff | Custom retry loops | Spring @Retryable or manual backoff | Standard patterns, configurable |

**Key insight:** The execution queue is a control plane concern, not a data plane concern. It gates what enters Temporal, not what Temporal does. Temporal handles execution once dispatched; the application handles admission control.

## Common Pitfalls

### Pitfall 1: Task Queue Mismatch Between Worker and Client
**What goes wrong:** Workflows stuck in "SCHEDULED" status, never execute
**Why it happens:** Worker registers queue "workflow-execution-queue" but client starts workflow with "workflow.workspace.xxx"
**How to avoid:**
- Use constants/functions for queue names
- Ensure workers exist for all queues used by clients
- Log queue names at startup
**Warning signs:** Temporal UI shows workflows scheduled but not running

### Pitfall 2: Race Condition in Concurrency Check
**What goes wrong:** More workflows started than tier limit allows
**Why it happens:** Check active count, then dispatch - gap allows concurrent dispatches
**How to avoid:**
- Use transaction isolation with `SKIP LOCKED`
- Re-check count after claiming queue item
- Accept slight over-provisioning as acceptable (Temporal handles execution)
**Warning signs:** Active count exceeds tier limit during load spikes

### Pitfall 3: Stale Queue Items After Restart
**What goes wrong:** Queue items stuck in CLAIMED status forever
**Why it happens:** Application crashes after claiming but before dispatching
**How to avoid:**
- Add `claimed_at` timestamp
- Background job reclaims stale items (claimed > N minutes ago, not dispatched)
- Set `lockAtMostFor` in ShedLock appropriately
**Warning signs:** Queue items with old `claimed_at`, status = CLAIMED

### Pitfall 4: ShedLock Without Database Time
**What goes wrong:** Lock released too early or held too long
**Why it happens:** Clock skew between application servers
**How to avoid:**
- Use `.usingDbTime()` when configuring JdbcTemplateLockProvider
- Ensure database server time is synchronized (NTP)
**Warning signs:** Duplicate executions, tasks run twice

### Pitfall 5: Forgetting Worker Registration for Dynamic Queues
**What goes wrong:** Workflows dispatched to workspace queue but no worker listening
**Why it happens:** Workers created for known queues at startup; new workspaces added later
**How to avoid:**
- Option A: Pre-register workers for all workspace queues at startup (query database)
- Option B: Use single workspace queue, route via workflow ID
- Option C: Dynamic worker creation (complex, not recommended initially)
**Warning signs:** New workspaces can't execute workflows

## Code Examples

Verified patterns from official sources:

### Complete Execution Queue Table Schema
```sql
-- Source: PostgreSQL SKIP LOCKED pattern + Spring JPA entity mapping
CREATE TABLE workflow_execution_queue (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workspace_id UUID NOT NULL REFERENCES workspaces(id) ON DELETE CASCADE,
    workflow_definition_id UUID NOT NULL REFERENCES workflow_definitions(id) ON DELETE CASCADE,
    status VARCHAR(20) NOT NULL DEFAULT 'PENDING'
        CHECK (status IN ('PENDING', 'CLAIMED', 'DISPATCHED', 'FAILED')),
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    claimed_at TIMESTAMPTZ,
    dispatched_at TIMESTAMPTZ,
    input JSONB,
    attempt_count INTEGER NOT NULL DEFAULT 0,
    last_error TEXT
);

-- Index for efficient queue polling
CREATE INDEX idx_execution_queue_pending
    ON workflow_execution_queue (status, created_at)
    WHERE status = 'PENDING';

-- Index for workspace isolation
CREATE INDEX idx_execution_queue_workspace
    ON workflow_execution_queue (workspace_id, status);

-- RLS Policy
ALTER TABLE workflow_execution_queue ENABLE ROW LEVEL SECURITY;

CREATE POLICY "execution_queue_by_workspace" ON workflow_execution_queue
    FOR ALL TO authenticated
    USING (workspace_id IN (
        SELECT workspace_id FROM workspace_members WHERE user_id = auth.uid()
    ));
```

### Workspace Tier Integration
```kotlin
// Source: Kotlin enum pattern + existing WorkspacePlan
enum class WorkspaceTier(
    val maxConcurrentWorkflows: Int,
    val queuePollPriority: Int,  // Higher = checked first
    val displayName: String
) {
    FREE(1, 1, "Free"),
    STARTUP(3, 2, "Startup"),
    SCALE(5, 3, "Scale"),
    ENTERPRISE(10, 4, "Enterprise");

    companion object {
        fun fromPlan(plan: WorkspacePlan): WorkspaceTier = when (plan) {
            WorkspacePlan.FREE -> FREE
            WorkspacePlan.STARTUP -> STARTUP
            WorkspacePlan.SCALE -> SCALE
            WorkspacePlan.ENTERPRISE -> ENTERPRISE
        }

        val DEFAULT = FREE
    }
}
```

### Modified WorkflowExecutionService (Queue Instead of Direct Dispatch)
```kotlin
// Source: Adaptation of existing WorkflowExecutionService
@Service
class WorkflowExecutionService(
    private val executionQueueRepository: ExecutionQueueRepository,
    private val workflowDefinitionRepository: WorkflowDefinitionRepository,
    private val activityService: ActivityService,
    private val authTokenService: AuthTokenService,
    private val logger: KLogger
) {
    /**
     * Queue a workflow execution request.
     *
     * Instead of dispatching directly to Temporal, this method:
     * 1. Validates the workflow definition exists and belongs to workspace
     * 2. Creates a queue entry with PENDING status
     * 3. Returns immediately with queue item ID
     *
     * The ExecutionDispatcherService will process the queue and dispatch
     * to Temporal when workspace has available capacity.
     */
    @Transactional
    fun queueExecution(request: StartWorkflowExecutionRequest): QueueExecutionResponse {
        val userId = authTokenService.getUserId()

        logger.info { "Queueing workflow execution for definition ${request.workflowDefinitionId}" }

        // Validate workflow definition
        val workflowDefinition = workflowDefinitionRepository.findById(request.workflowDefinitionId)
            .orElseThrow { NotFoundException("Workflow definition not found") }

        if (workflowDefinition.workspaceId != request.workspaceId) {
            throw SecurityException("Workflow definition does not belong to workspace")
        }

        // Create queue entry
        val queueEntry = ExecutionQueueEntity(
            workspaceId = request.workspaceId,
            workflowDefinitionId = request.workflowDefinitionId,
            input = request.input,
            status = ExecutionQueueStatus.PENDING
        )

        val saved = executionQueueRepository.save(queueEntry)

        logger.info { "Queued execution: ${saved.id}" }

        return QueueExecutionResponse(
            queueId = saved.id!!,
            status = "QUEUED",
            message = "Workflow execution queued. Will start when capacity available."
        )
    }
}

data class QueueExecutionResponse(
    val queueId: UUID,
    val status: String,
    val message: String
)
```

### Active Execution Count Query
```kotlin
// Source: Spring Data JPA native query pattern
interface WorkflowExecutionRepository : JpaRepository<WorkflowExecutionEntity, UUID> {

    @Query("""
        SELECT COUNT(*) FROM workflow_executions
        WHERE workspace_id = :workspaceId
        AND status IN ('RUNNING', 'PENDING')
    """, nativeQuery = true)
    fun countActiveByWorkspace(@Param("workspaceId") workspaceId: UUID): Int

    @Query("""
        SELECT workspace_id, COUNT(*) as active_count
        FROM workflow_executions
        WHERE status IN ('RUNNING', 'PENDING')
        GROUP BY workspace_id
    """, nativeQuery = true)
    fun countActiveByAllWorkspaces(): List<WorkspaceActiveCount>
}

interface WorkspaceActiveCount {
    fun getWorkspaceId(): UUID
    fun getActiveCount(): Int
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Single task queue for all | Per-tenant task queues | Best practice 2024+ | Better isolation, future per-tenant scaling |
| Manual poller configuration | Poller Autoscaling | Temporal SDK 2024 | Better throughput, less configuration |
| Application-level state tracking | Temporal workflow status | Always | Trust Temporal for execution state |
| Custom distributed locks | ShedLock | 2020+ | Battle-tested, multiple backends |

**New tools/patterns to consider:**
- **Temporal Nexus:** Cross-namespace communication for future multi-tenant expansion
- **Worker Versioning:** Safe deployment of workflow changes
- **Poller Autoscaling:** Dynamic poller count based on load

**Deprecated/outdated:**
- **Manual poller count configuration:** Use autoscaling unless specific tuning needed
- **In-memory job queues:** Not durable; use database-backed

## Open Questions

Things that couldn't be fully resolved:

1. **Dynamic Worker Registration for New Workspaces**
   - What we know: Workers must be registered at startup for known task queues
   - What's unclear: Best practice for workspaces created after startup
   - Recommendation: Start with routing via workflow ID prefix in single queue; evolve to per-workspace queues when scale demands

2. **Optimal Polling Interval**
   - What we know: Balance between latency and database load
   - What's unclear: Specific interval for this workload
   - Recommendation: Start with 5 seconds, tune based on monitoring

3. **Stale Claim Recovery**
   - What we know: Claimed items can become stale if processor crashes
   - What's unclear: Optimal timeout before reclaiming
   - Recommendation: Implement background job that reclaims items claimed > 5 minutes ago

4. **Non-Tenant Queue Limits**
   - What we know: Default and external-api queues need separate limits
   - What's unclear: Exact values for production
   - Recommendation: Start with 50 concurrent for default, 20 for external-api; tune based on load

## Sources

### Primary (HIGH confidence)
- [Temporal Task Queues Documentation](https://docs.temporal.io/task-queue) - Task queue concepts, naming, routing
- [Temporal Worker Performance](https://docs.temporal.io/develop/worker-performance) - Worker options, thread pools, poller configuration
- [Temporal Java SDK Core Application](https://docs.temporal.io/develop/java/core-application) - WorkerFactory, Worker registration
- [Temporal Multi-Tenancy](https://docs.temporal.io/evaluate/development-production-features/multi-tenancy) - Namespace isolation, noisy neighbor
- [ShedLock GitHub](https://github.com/lukas-krecan/ShedLock) - v7.5.0, distributed lock configuration
- [PostgreSQL SKIP LOCKED - Vlad Mihalcea](https://vladmihalcea.com/database-job-queue-skip-locked/) - Job queue pattern, Hibernate integration

### Secondary (MEDIUM confidence)
- [Temporal Community - Multiple Task Queues](https://community.temporal.io/t/is-it-possible-for-a-worker-to-have-multiple-task-queues/7876) - Multi-worker pattern verification
- [Temporal Community - Multi-Tenant Strategy](https://community.temporal.io/t/multi-tenant-strategy-with-shared-services/6104) - Per-tenant queue patterns
- [Spring Boot Scheduling Best Practices](https://dev.to/dixitgurv/spring-boot-scheduling-best-practices-503h) - @Scheduled patterns
- [Practical SQL Queueing - Notch](https://wearenotch.com/blog/practical-queueing-using-sql-part-2-do-it-simply-using-spring-boot-and-jpa/) - Spring JPA queue consumer

### Tertiary (LOW confidence - needs validation)
- Optimal polling interval (5s proposed) - based on general guidance, needs production validation
- Non-tenant queue limits (50/20) - arbitrary starting points, need tuning

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - Temporal SDK, ShedLock, SKIP LOCKED are established patterns
- Architecture: HIGH - Multi-worker pattern verified in Temporal docs and community
- Pitfalls: HIGH - Common issues documented in Temporal community forums
- Code examples: MEDIUM - Adapted from verified patterns, need integration testing

**Research date:** 2026-01-19
**Valid until:** 2026-02-19 (30 days - patterns stable, may need Temporal SDK version check)

**Critical constraints:**
- Application-level concurrency control required (Temporal doesn't enforce per-tenant limits)
- Database-backed queue for durability (survives restarts)
- ShedLock for distributed safety (multiple instances)

---

*Phase: 06.1-execution-queue-management*
*Research completed: 2026-01-19*
*Ready for planning: yes*
