---
phase: 03-temporal-workflow-engine
plan: 01
type: execute
---

<objective>
Implement core Temporal workflow orchestration with worker registration, activity execution, and REST API integration.

Purpose: Enable workflow execution via Temporal, establishing the foundation for DAG-based workflow orchestration with entity integration.
Output: Working Temporal workflow that can be triggered via REST API, execute activities, and persist execution state to PostgreSQL.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-temporal-workflow-engine/03-RESEARCH.md

# Prior phase context
@.planning/phases/01-expression-system-foundation/01-01-SUMMARY.md
@.planning/phases/02-entity-context-integration/02-01-SUMMARY.md

# Codebase context
@.planning/codebase/ARCHITECTURE.md
@.planning/codebase/STACK.md

# Existing infrastructure
@src/main/kotlin/riven/core/configuration/workflow/TemporalEngineConfiguration.kt
@src/main/kotlin/riven/core/entity/workflow/WorkflowDefinitionEntity.kt
@src/main/kotlin/riven/core/entity/workflow/WorkflowNodeEntity.kt
@src/main/kotlin/riven/core/entity/workflow/execution/WorkflowExecutionEntity.kt
@src/main/kotlin/riven/core/service/workflow/ExpressionEvaluatorService.kt
@src/main/kotlin/riven/core/service/workflow/EntityContextService.kt

**Tech stack available:**
- Temporal SDK 1.24.1 (upgrade to 1.32.1 pending)
- Spring Boot 3.5.3 with dependency injection
- Existing WorkflowServiceStubs bean (TemporalEngineConfiguration)
- Expression evaluation system (Phase 1)
- Entity context resolution (Phase 2)

**Established patterns:**
- Service layer with constructor injection
- JPA entities with JSONB for complex payloads
- Activity logging via ActivityService
- Transactional boundaries with @Transactional

**Research findings (03-RESEARCH.md):**
- Use workflow as deterministic orchestrator (no side effects)
- Activities execute non-deterministic operations (DB, HTTP, etc.)
- Spring beans can be autowired into activity implementations
- Worker factory must register workflows and activities before starting
- Activity timeouts are MANDATORY (setStartToCloseTimeout)
- Use typed stubs for type safety

**Critical constraints from research:**
- Workflows MUST be deterministic (no UUID.randomUUID(), System.currentTimeMillis(), Thread.sleep(), DB calls, HTTP)
- Use Workflow SDK alternatives: Workflow.randomUUID(), Workflow.currentTimeMillis(), Workflow.sleep()
- Activities are stateless (singleton instances handling concurrent executions)
- Task queue names MUST match between worker registration and workflow start
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Temporal workflow and activity definitions with worker registration</name>
  <files>
    src/main/kotlin/riven/core/service/workflow/temporal/workflows/WorkflowExecutionWorkflow.kt,
    src/main/kotlin/riven/core/service/workflow/temporal/workflows/WorkflowExecutionWorkflowImpl.kt,
    src/main/kotlin/riven/core/service/workflow/temporal/activities/WorkflowNodeActivities.kt,
    src/main/kotlin/riven/core/service/workflow/temporal/activities/WorkflowNodeActivitiesImpl.kt,
    src/main/kotlin/riven/core/service/workflow/temporal/workers/TemporalWorkerConfiguration.kt,
    src/main/kotlin/riven/core/models/workflow/temporal/WorkflowExecutionInput.kt,
    src/main/kotlin/riven/core/models/workflow/temporal/WorkflowExecutionResult.kt
  </files>
  <action>
Create Temporal workflow orchestration infrastructure following patterns from 03-RESEARCH.md:

1. **Workflow interface and implementation:**
   - WorkflowExecutionWorkflow interface with @WorkflowInterface annotation
   - Single @WorkflowMethod: `execute(input: WorkflowExecutionInput): WorkflowExecutionResult`
   - WorkflowExecutionWorkflowImpl with deterministic orchestration logic (NO side effects)
   - Create activity stub with ActivityOptions (setStartToCloseTimeout = 5 minutes, RetryOptions with max 3 attempts)
   - Simple sequential execution for v1 (iterate nodes, call activity per node, collect results)
   - AVOID: UUID.randomUUID(), System.currentTimeMillis(), Thread.sleep(), DB calls - use Workflow SDK alternatives only

2. **Activity interface and implementation:**
   - WorkflowNodeActivities interface with @ActivityInterface annotation
   - Single @ActivityMethod: `executeNode(nodeId: UUID, workspaceId: UUID): NodeExecutionResult`
   - WorkflowNodeActivitiesImpl as @Component (Spring bean) with constructor-injected dependencies:
     - WorkflowNodeRepository (fetch node configuration)
     - WorkflowExecutionNodeRepository (persist node execution state)
     - EntityService (for ACTION nodes that create/update entities)
     - ExpressionEvaluatorService and EntityContextService (for CONTROL nodes with conditional logic)
   - Activity implementation is STATELESS - use method parameters for all data, no instance fields modified during execution
   - Handle node type routing: ACTION vs CONTROL vs TRIGGER (focus on ACTION for v1, stub others)
   - Update WorkflowExecutionNodeEntity status (RUNNING â†’ COMPLETED/FAILED) and persist results

3. **Worker configuration:**
   - TemporalWorkerConfiguration as @Configuration class
   - Constructor-inject existing WorkflowServiceStubs bean and WorkflowNodeActivitiesImpl
   - Create WorkerFactory bean with WorkflowClient.newInstance(workflowServiceStubs)
   - Create Worker for task queue "workflow-execution-queue"
   - Register WorkflowExecutionWorkflowImpl via registerWorkflowImplementationTypes()
   - Register activities via registerActivitiesImplementations() with Spring bean instance
   - Start factory with factory.start()
   - Add @PreDestroy method for graceful shutdown

4. **Input/output models:**
   - WorkflowExecutionInput data class: workflowDefinitionId (UUID), nodeIds (List&lt;UUID&gt;), workspaceId (UUID)
   - WorkflowExecutionResult data class: executionId (UUID), status (String), nodeResults (List&lt;NodeExecutionResult&gt;)
   - NodeExecutionResult data class: nodeId (UUID), status (String), output (Any?)

**Why avoid certain patterns:**
- DON'T use UUID.randomUUID() in workflow (non-deterministic) - use Workflow.randomUUID() instead
- DON'T call repositories directly in workflow (side effects) - all DB operations MUST go through activities
- DON'T use standard Thread/CompletableFuture in workflow (breaks determinism) - use Async.function() and Promise if needed
- DON'T create new activity stubs per invocation (performance) - create once as class field
- DON'T omit activity timeouts (workflows hang indefinitely) - setStartToCloseTimeout is MANDATORY
  </action>
  <verify>
./gradlew build succeeds with no compilation errors
./gradlew test runs successfully (no test failures)
Worker logs show "Registered workflow: WorkflowExecutionWorkflow" and "Registered activities: WorkflowNodeActivities"
  </verify>
  <done>
Workflow interface with @WorkflowMethod defined
Workflow implementation with deterministic orchestration and activity stub created
Activity interface with @ActivityMethod defined
Activity implementation as Spring bean with dependency injection and node execution logic
Worker configuration bean that registers workflows and activities, starts successfully
Input/output models defined for workflow communication
Code compiles and worker starts without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Create REST API endpoint for triggering workflow executions</name>
  <files>
    src/main/kotlin/riven/core/controller/workflow/WorkflowExecutionController.kt,
    src/main/kotlin/riven/core/service/workflow/WorkflowExecutionService.kt,
    src/main/kotlin/riven/core/models/request/workflow/StartWorkflowExecutionRequest.kt
  </files>
  <action>
Implement REST API for workflow execution following existing controller patterns:

1. **Controller:**
   - WorkflowExecutionController as @RestController
   - @RequestMapping("/api/v1/workflow/executions")
   - @PreAuthorize with workspace security check
   - POST /api/v1/workflow/executions/start endpoint
   - Accepts StartWorkflowExecutionRequest (workflowDefinitionId, workspaceId)
   - Returns ExecutionResponse (workflowId, executionId, status = "STARTED")
   - Delegate to WorkflowExecutionService.startExecution()
   - Follow existing controller patterns from EntityTypeController (thin delegation, proper error handling)

2. **Service:**
   - WorkflowExecutionService as @Service
   - Constructor-inject: WorkflowClient (from Temporal autoconfigure or create from WorkflowServiceStubs), WorkflowDefinitionRepository, WorkflowExecutionRepository, ActivityService
   - startExecution() method:
     a. Validate workspace access (workspaceId matches workflow definition)
     b. Fetch WorkflowDefinitionEntity by ID (with nodes and edges for DAG)
     c. Create WorkflowExecutionEntity (status = RUNNING, workflowDefinitionId, workspaceId)
     d. Persist execution record to PostgreSQL (captures execution start time, user, workspace)
     e. Create typed workflow stub with WorkflowClient.newWorkflowStub():
        - WorkflowId: "execution-${executionEntity.id}"
        - TaskQueue: "workflow-execution-queue" (MUST match worker registration)
        - WorkflowOptions with timeouts
     f. Prepare WorkflowExecutionInput (workflowDefinitionId, nodeIds from DAG topological sort or simple order for v1, workspaceId)
     g. Start workflow asynchronously: WorkflowClient.start { workflow.execute(input) }
     h. Log activity via ActivityService (WORKFLOW_EXECUTION, CREATE, execution details)
     i. Return ExecutionResponse with workflowId and executionId
   - Handle errors: NotFoundException if workflow definition missing, AccessDeniedException if workspace mismatch

3. **Request model:**
   - StartWorkflowExecutionRequest data class: workflowDefinitionId (UUID), workspaceId (UUID)

**Why this approach:**
- Asynchronous start (WorkflowClient.start) returns immediately, doesn't block REST endpoint - improves API responsiveness
- WorkflowExecutionEntity persists BEFORE starting Temporal workflow - enables execution tracking even if Temporal fails
- Typed stub provides compile-time type safety - catches interface mismatches early
- Task queue name consistency critical - "workflow-execution-queue" must match worker registration or workflows fail with "No worker found"
- Activity logging provides audit trail for workflow triggers
  </action>
  <verify>
./gradlew build succeeds
curl -X POST http://localhost:8081/api/v1/workflow/executions/start -H "Content-Type: application/json" -d '{"workflowDefinitionId":"uuid","workspaceId":"uuid"}' returns 200 with executionId
Worker logs show workflow execution starting
PostgreSQL workflow_executions table has new row with status RUNNING
  </verify>
  <done>
Controller endpoint accepts POST request and returns execution response
Service creates execution record in PostgreSQL, starts Temporal workflow asynchronously
Request model defined with proper validation
Workflow starts successfully when triggered via API (confirmed by worker logs)
Execution record persisted with RUNNING status
Activity log created for execution start
  </done>
</task>

<task type="auto">
  <name>Task 3: Add integration test validating end-to-end workflow execution</name>
  <files>
    src/test/kotlin/riven/core/service/workflow/WorkflowExecutionIntegrationTest.kt,
    src/main/resources/application-test.yml
  </files>
  <action>
Create integration test proving workflow execution works end-to-end:

1. **Test setup:**
   - Use @SpringBootTest with embedded Temporal test server (io.temporal:temporal-testing:1.24.1 already in testImplementation)
   - Configure test Temporal server with TestWorkflowEnvironment from Temporal testing SDK
   - Register test worker with WorkflowExecutionWorkflowImpl and WorkflowNodeActivitiesImpl
   - Mock dependencies in WorkflowNodeActivitiesImpl (EntityService, repositories) with Mockito
   - Prepare test data: WorkflowDefinitionEntity with 2 simple ACTION nodes (creates entities)

2. **Test cases:**
   - `testSimpleWorkflowExecution()`:
     a. Create test WorkflowDefinitionEntity in H2 test database
     b. Call WorkflowExecutionService.startExecution()
     c. Wait for workflow completion (use WorkflowStub.getResult() with timeout)
     d. Verify WorkflowExecutionResult contains 2 node results
     e. Verify WorkflowExecutionEntity status updated to COMPLETED
     f. Verify WorkflowExecutionNodeEntity records exist for both nodes with COMPLETED status
   - `testWorkflowWithMockedEntityCreation()`:
     a. Mock EntityService.createEntity() to return test entity
     b. Trigger workflow execution
     c. Verify activity called EntityService.createEntity() exactly twice (2 nodes)
     d. Verify workflow completes successfully

3. **Configuration (application-test.yml):**
   - Override riven.workflow.engine.target to use test Temporal server
   - H2 database configuration for workflow entities

**Why this test structure:**
- TestWorkflowEnvironment provides isolated Temporal server - no external dependencies, fast test execution
- Mocking EntityService prevents actual database writes during tests - keeps tests focused on workflow orchestration logic
- Waiting for workflow completion synchronously in tests is acceptable - production uses async start, tests verify behavior
- H2 database for JPA entities enables full integration test without PostgreSQL dependency
  </action>
  <verify>
./gradlew test runs WorkflowExecutionIntegrationTest successfully
Test logs show workflow execution starting and completing
Test assertions pass (workflow result contains expected node results, execution status COMPLETED)
Test completes in under 10 seconds
  </verify>
  <done>
Integration test exists with @SpringBootTest and Temporal test server
Test validates workflow starts via service, executes activities, and completes successfully
Test verifies WorkflowExecutionEntity and WorkflowExecutionNodeEntity persistence
Test uses mocked dependencies to isolate workflow orchestration logic
All test assertions pass, test completes without errors
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] ./gradlew clean build succeeds without errors
- [ ] ./gradlew test passes all tests including new WorkflowExecutionIntegrationTest
- [ ] Worker starts and logs show workflow and activity registration
- [ ] POST to /api/v1/workflow/executions/start returns execution response
- [ ] Temporal workflow executes and updates WorkflowExecutionEntity status
- [ ] Activity execution persists results to WorkflowExecutionNodeEntity
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- Temporal workflow orchestration operational (workflow interface, implementation, activities, worker)
- REST API endpoint triggers workflow execution asynchronously
- Integration test validates end-to-end execution with mocked dependencies
- No compilation errors, no test failures
- Worker registration successful, workflows can be triggered via API
- Execution state persists to PostgreSQL (workflow_executions, workflow_execution_nodes tables)
  </success_criteria>

<output>
After completion, create `.planning/phases/03-temporal-workflow-engine/03-01-SUMMARY.md`:

# Phase 3 Plan 1: Temporal Workflow Engine Summary

**[Substantive one-liner describing what shipped]**

## Accomplishments

- [Key outcome 1]
- [Key outcome 2]

## Files Created/Modified

- `path/to/file.kt` - Description
- `path/to/another.kt` - Description

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Ready for Phase 4: Action Executors
</output>
