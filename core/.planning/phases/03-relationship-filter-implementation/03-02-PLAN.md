---
phase: 03-relationship-filter-implementation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/main/kotlin/riven/core/service/entity/query/AttributeSqlGenerator.kt
  - src/main/kotlin/riven/core/service/entity/query/RelationshipSqlGenerator.kt
autonomous: true

must_haves:
  truths:
    - "EXISTS condition generates SQL matching entities with at least one related entity"
    - "NOT_EXISTS condition generates SQL matching entities with no related entities"
    - "TargetEquals condition generates SQL matching entities related to specific entity IDs"
    - "TargetMatches condition generates SQL with JOIN to target entities and nested filter applied"
    - "TargetTypeMatches condition generates SQL with OR-branched type predicates and optional per-branch filters"
    - "Nested filters inside TargetMatches reference target entity alias (not root e alias)"
    - "Each subquery uses unique table aliases from ParameterNameGenerator"
    - "All subqueries include deleted = false checks"
  artifacts:
    - path: "src/main/kotlin/riven/core/service/entity/query/RelationshipSqlGenerator.kt"
      provides: "EXISTS subquery SQL generation for all RelationshipCondition variants"
      exports: ["RelationshipSqlGenerator"]
    - path: "src/main/kotlin/riven/core/service/entity/query/AttributeSqlGenerator.kt"
      provides: "Attribute SQL generation with parameterized entity alias"
      contains: "entityAlias: String"
  key_links:
    - from: "RelationshipSqlGenerator"
      to: "SqlFragment"
      via: "returns SqlFragment from every generate method"
      pattern: "SqlFragment\\("
    - from: "RelationshipSqlGenerator"
      to: "ParameterNameGenerator"
      via: "generates unique parameter names and table aliases"
      pattern: "paramGen\\.next"
    - from: "AttributeSqlGenerator.generate"
      to: "entityAlias parameter"
      via: "replaces hardcoded e. prefix"
      pattern: "entityAlias.*=.*\"e\""
---

<objective>
Create RelationshipSqlGenerator that produces parameterized EXISTS/NOT EXISTS subqueries for all RelationshipCondition variants, and add entityAlias parameter to AttributeSqlGenerator for nested relationship filter support.

Purpose: This is the core SQL generation for relationship filtering. EXISTS subqueries correlate to the outer entity, support nested filters via a callback function, and produce unique aliases to prevent conflicts at any nesting depth.

Output: RelationshipSqlGenerator class handling all 5 condition types + backward-compatible entityAlias refactor of AttributeSqlGenerator.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-relationship-filter-implementation/03-CONTEXT.md
@.planning/phases/03-relationship-filter-implementation/03-RESEARCH.md

@src/main/kotlin/riven/core/service/entity/query/SqlFragment.kt
@src/main/kotlin/riven/core/service/entity/query/ParameterNameGenerator.kt
@src/main/kotlin/riven/core/service/entity/query/AttributeSqlGenerator.kt
@src/main/kotlin/riven/core/models/entity/query/RelationshipCondition.kt
@src/main/kotlin/riven/core/models/entity/query/QueryFilter.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add entityAlias parameter to AttributeSqlGenerator</name>
  <files>src/main/kotlin/riven/core/service/entity/query/AttributeSqlGenerator.kt</files>
  <action>
Add an `entityAlias: String = "e"` parameter to the `generate()` public method of AttributeSqlGenerator. This is backward-compatible -- existing callers that don't pass the parameter get the default "e" behavior.

**Changes to `generate()` signature:**
```kotlin
fun generate(
    attributeId: UUID,
    operator: FilterOperator,
    value: Any?,
    paramGen: ParameterNameGenerator,
    entityAlias: String = "e"       // NEW: defaults to root entity alias
): SqlFragment
```

**Changes to all private methods:**
Pass `entityAlias` through to every private method that generates SQL containing `e.payload`. Each private method gets a new parameter `entityAlias: String`.

Replace ALL hardcoded `e.payload` references with `$entityAlias.payload` in the SQL strings:
- `generateEquals`: `"e.payload @> ..."` becomes `"$entityAlias.payload @> ..."`
- `generateNotEquals`: `"e.payload ? ..."` and `"e.payload->..."` become `"$entityAlias.payload ? ..."` and `"$entityAlias.payload->..."`
- `generateNumericComparison`: both `e.payload->` references become `$entityAlias.payload->`
- `generateContains`, `generateNotContains`, `generateStartsWith`, `generateEndsWith`: `e.payload->` becomes `$entityAlias.payload->`
- `generateIn`, `generateNotIn`: `e.payload->` and `e.payload ?` become `$entityAlias.payload->` and `$entityAlias.payload ?`
- `generateIsNull`, `generateIsNotNull`: `e.payload->` becomes `$entityAlias.payload->`

This is a mechanical find-and-replace of `e.payload` with `$entityAlias.payload` in every SQL string, plus threading the parameter through. No logic changes.

**Critical:** Do NOT change the `"e.payload"` pattern to `"${entityAlias}.payload"` -- use string interpolation correctly. In raw strings and regular strings, use `$entityAlias.payload` (Kotlin interpolates `$entityAlias` and `.payload` is literal).

Actually, be careful: `$entityAlias.payload` in Kotlin string interpolation would try to access a `.payload` property. Use `${entityAlias}.payload` instead to ensure only the variable is interpolated.

Update the class KDoc to mention the entityAlias parameter and its purpose (nested relationship filter support).
  </action>
  <verify>Run `./gradlew compileKotlin` -- must compile. Existing behavior preserved: all SQL strings produce identical output when entityAlias defaults to "e".</verify>
  <done>AttributeSqlGenerator.generate() accepts entityAlias parameter defaulting to "e". All SQL generation uses the parameterized alias instead of hardcoded "e".</done>
</task>

<task type="auto">
  <name>Task 2: Create RelationshipSqlGenerator for all RelationshipCondition variants</name>
  <files>src/main/kotlin/riven/core/service/entity/query/RelationshipSqlGenerator.kt</files>
  <action>
Create `RelationshipSqlGenerator` in `service/entity/query/` package. This class generates parameterized EXISTS/NOT EXISTS subqueries for filtering entities by their relationships.

**Design:** The generator does NOT hold a reference to the visitor. Instead, for TargetMatches and TargetTypeMatches (which need recursive nested filter SQL), the `generate()` method accepts a `nestedFilterVisitor` function parameter. This avoids circular dependencies.

**Public API:**

```kotlin
class RelationshipSqlGenerator {
    fun generate(
        relationshipId: UUID,
        condition: RelationshipCondition,
        paramGen: ParameterNameGenerator,
        entityAlias: String = "e",
        nestedFilterVisitor: ((QueryFilter, ParameterNameGenerator, String) -> SqlFragment)? = null
    ): SqlFragment
}
```

The `nestedFilterVisitor` lambda signature is `(filter: QueryFilter, paramGen: ParameterNameGenerator, entityAlias: String) -> SqlFragment`. It's called by TargetMatches and TargetTypeMatches to process nested filters. The caller (the visitor in Plan 03) provides this lambda. The lambda is nullable -- if null and a TargetMatches/TargetTypeMatches is encountered, throw `UnsupportedOperationException("Nested filter visitor required for TargetMatches/TargetTypeMatches conditions")`.

**generate() method dispatch:**
Use `when (condition)` with exhaustive matching on RelationshipCondition:
- `Exists` -> `generateExists(relationshipId, paramGen, entityAlias)`
- `NotExists` -> `generateNotExists(relationshipId, paramGen, entityAlias)`
- `TargetEquals` -> `generateTargetEquals(relationshipId, condition.entityIds, paramGen, entityAlias)`
- `TargetMatches` -> `generateTargetMatches(relationshipId, condition.filter, paramGen, entityAlias, nestedFilterVisitor!!)`
- `TargetTypeMatches` -> `generateTargetTypeMatches(relationshipId, condition.branches, paramGen, entityAlias, nestedFilterVisitor!!)`
- `CountMatches` -> throw `UnsupportedOperationException("CountMatches is not supported in this version. See v2 requirements REL-09.")`

**Private methods:**

**`generateExists(relationshipId, paramGen, entityAlias)` -> SqlFragment:**
```sql
EXISTS (
    SELECT 1 FROM entity_relationships {relAlias}
    WHERE {relAlias}.source_entity_id = {entityAlias}.id
      AND {relAlias}.relationship_field_id = :{relParam}
      AND {relAlias}.deleted = false
)
```
- `relAlias` = `"r_${paramGen.next("a")}"`  (unique alias)
- `relParam` = `paramGen.next("rel")`
- Parameters: `mapOf(relParam to relationshipId)`

**`generateNotExists(...)` -> SqlFragment:**
Same as generateExists but with `NOT EXISTS` prefix.

**`generateTargetEquals(relationshipId, entityIds, paramGen, entityAlias)` -> SqlFragment:**
Convert entityIds (List<String>) to List<UUID> via UUID.fromString().
```sql
EXISTS (
    SELECT 1 FROM entity_relationships {relAlias}
    WHERE {relAlias}.source_entity_id = {entityAlias}.id
      AND {relAlias}.relationship_field_id = :{relParam}
      AND {relAlias}.target_entity_id IN (:{targetParam})
      AND {relAlias}.deleted = false
)
```
- `targetParam` = `paramGen.next("te")`
- Parameters: `mapOf(relParam to relationshipId, targetParam to uuidList)`

**`generateTargetMatches(relationshipId, nestedFilter, paramGen, entityAlias, visitor)` -> SqlFragment:**
This JOINs to the `entities` table to access the target entity's payload.
- Generate unique aliases: `relAlias = "r_${paramGen.next("a")}"`, `targetAlias = "t_${paramGen.next("a")}"`
- Call `visitor(nestedFilter, paramGen, targetAlias)` to get the nested filter SQL fragment
```sql
EXISTS (
    SELECT 1 FROM entity_relationships {relAlias}
    JOIN entities {targetAlias} ON {relAlias}.target_entity_id = {targetAlias}.id AND {targetAlias}.deleted = false
    WHERE {relAlias}.source_entity_id = {entityAlias}.id
      AND {relAlias}.relationship_field_id = :{relParam}
      AND {relAlias}.deleted = false
      AND {nestedFragment.sql}
)
```
- Parameters: merge `mapOf(relParam to relationshipId)` with `nestedFragment.parameters`

**`generateTargetTypeMatches(relationshipId, branches, paramGen, entityAlias, visitor)` -> SqlFragment:**
Same structure as TargetMatches but with OR-branched type predicates.
- Generate `relAlias` and `targetAlias` (same pattern as TargetMatches)
- For each TypeBranch:
  - Generate `typeParam = paramGen.next("ttm_type")`
  - Create type condition: `SqlFragment("{targetAlias}.type_id = :{typeParam}", mapOf(typeParam to branch.entityTypeId))`
  - If `branch.filter != null`: call `visitor(branch.filter, paramGen, targetAlias)` and AND it with type condition
  - If `branch.filter == null`: just the type condition
- Combine all branch fragments with OR using `.reduce { acc, f -> acc.or(f) }`
```sql
EXISTS (
    SELECT 1 FROM entity_relationships {relAlias}
    JOIN entities {targetAlias} ON {relAlias}.target_entity_id = {targetAlias}.id AND {targetAlias}.deleted = false
    WHERE {relAlias}.source_entity_id = {entityAlias}.id
      AND {relAlias}.relationship_field_id = :{relParam}
      AND {relAlias}.deleted = false
      AND {combinedBranches.sql}
)
```

**Important implementation details:**
- Use `buildString` for multi-line SQL construction (consistent with codebase patterns)
- All aliases generated via ParameterNameGenerator ensure uniqueness across arbitrary nesting depth
- Always check `deleted = false` on entity_relationships table
- Always check `deleted = false` on target entities (in JOIN condition for TargetMatches/TargetTypeMatches)
- Do NOT add workspace_id filtering in subqueries (per CONTEXT.md decision)
- `entityAlias` parameter allows correlation to either root entity (`e`) or a nested target entity (`t_X`)

Include comprehensive KDoc explaining:
- EXISTS subquery pattern and why it's preferred over JOINs
- The nestedFilterVisitor callback pattern and why it exists (avoiding circular deps)
- Alias generation strategy for nested queries
- Workspace isolation is on root query only
  </action>
  <verify>Run `./gradlew compileKotlin` -- must compile. The class has one public method (`generate`) with exhaustive RelationshipCondition dispatch.</verify>
  <done>RelationshipSqlGenerator produces correct parameterized EXISTS/NOT EXISTS subqueries for Exists, NotExists, TargetEquals, TargetMatches, and TargetTypeMatches conditions. CountMatches throws UnsupportedOperationException.</done>
</task>

</tasks>

<verification>
1. `./gradlew compileKotlin` passes
2. AttributeSqlGenerator.generate() has backward-compatible entityAlias parameter defaulting to "e"
3. RelationshipSqlGenerator handles all 5 in-scope RelationshipCondition variants
4. Generated SQL uses unique aliases (r_0, t_0, r_3, t_3, etc.) from ParameterNameGenerator
5. TargetMatches SQL JOINs entities table with deleted = false
6. TargetTypeMatches SQL uses OR semantics across branches
7. CountMatches throws UnsupportedOperationException
</verification>

<success_criteria>
- EXISTS/NOT EXISTS subqueries correlate to correct entity alias
- Nested filters reference target entity alias, not root alias
- Unique table aliases prevent SQL ambiguity at any nesting depth
- All parameters are named and bound (no string concatenation of user input)
- Backward compatibility preserved for AttributeSqlGenerator
</success_criteria>

<output>
After completion, create `.planning/phases/03-relationship-filter-implementation/03-02-SUMMARY.md`
</output>
