---
phase: 03-relationship-filter-implementation
plan: 03
type: execute
wave: 2
depends_on: ["03-02"]
files_modified:
  - src/main/kotlin/riven/core/service/entity/query/AttributeFilterVisitor.kt
autonomous: true

must_haves:
  truths:
    - "QueryFilter.Relationship nodes dispatch to RelationshipSqlGenerator"
    - "Relationship depth is tracked separately from AND/OR nesting depth"
    - "TargetMatches nested filters recurse through the visitor with the target entity alias"
    - "TargetTypeMatches branch filters recurse through the visitor with the target entity alias"
    - "Relationship depth is enforced during generation as a safety net"
    - "Existing attribute filter and AND/OR behavior is unchanged"
  artifacts:
    - path: "src/main/kotlin/riven/core/service/entity/query/AttributeFilterVisitor.kt"
      provides: "Complete filter tree visitor handling both attribute and relationship filters"
      contains: "RelationshipSqlGenerator"
  key_links:
    - from: "AttributeFilterVisitor.visitRelationship"
      to: "RelationshipSqlGenerator.generate"
      via: "delegation with nestedFilterVisitor callback"
      pattern: "relationshipSqlGenerator\\.generate"
    - from: "RelationshipSqlGenerator nestedFilterVisitor callback"
      to: "AttributeFilterVisitor.visitInternal"
      via: "lambda passed to generate()"
      pattern: "nestedFilterVisitor.*visitInternal|visitInternal.*entityAlias"
---

<objective>
Wire RelationshipSqlGenerator into AttributeFilterVisitor, replacing the Phase 2 placeholder with real relationship filter dispatch and separate relationship depth tracking.

Purpose: This completes the filter tree traversal -- the visitor can now handle any combination of attribute filters, relationship filters, AND/OR composition, and arbitrary nesting up to both depth limits (AND/OR nesting + relationship traversal).

Output: AttributeFilterVisitor handles QueryFilter.Relationship by delegating to RelationshipSqlGenerator with proper depth tracking and nested filter callback.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-relationship-filter-implementation/03-CONTEXT.md
@.planning/phases/03-relationship-filter-implementation/03-RESEARCH.md
@.planning/phases/03-relationship-filter-implementation/03-02-SUMMARY.md

@src/main/kotlin/riven/core/service/entity/query/AttributeFilterVisitor.kt
@src/main/kotlin/riven/core/service/entity/query/RelationshipSqlGenerator.kt
@src/main/kotlin/riven/core/service/entity/query/AttributeSqlGenerator.kt
@src/main/kotlin/riven/core/service/entity/query/SqlFragment.kt
@src/main/kotlin/riven/core/service/entity/query/ParameterNameGenerator.kt
@src/main/kotlin/riven/core/exceptions/query/QueryFilterException.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add RelationshipSqlGenerator dependency and relationship depth tracking</name>
  <files>src/main/kotlin/riven/core/service/entity/query/AttributeFilterVisitor.kt</files>
  <action>
Modify AttributeFilterVisitor to accept RelationshipSqlGenerator as a constructor dependency and track relationship depth separately from AND/OR nesting depth.

**Constructor changes:**
```kotlin
class AttributeFilterVisitor(
    private val attributeSqlGenerator: AttributeSqlGenerator,
    private val relationshipSqlGenerator: RelationshipSqlGenerator,  // NEW
    private val maxNestingDepth: Int = DEFAULT_MAX_NESTING_DEPTH,
    private val maxRelationshipDepth: Int = DEFAULT_MAX_RELATIONSHIP_DEPTH  // NEW
)
```

Add companion object constant: `const val DEFAULT_MAX_RELATIONSHIP_DEPTH = 3`

**Public visit() method changes:**
Add an overload or modify the existing `visit()` to support entityAlias:
```kotlin
fun visit(
    filter: QueryFilter,
    paramGen: ParameterNameGenerator,
    entityAlias: String = "e"  // NEW: defaults to root entity
): SqlFragment {
    return visitInternal(filter, depth = 0, relationshipDepth = 0, paramGen, entityAlias)
}
```

**visitInternal changes:**
Add `relationshipDepth: Int` and `entityAlias: String` parameters:
```kotlin
private fun visitInternal(
    filter: QueryFilter,
    depth: Int,
    relationshipDepth: Int,
    paramGen: ParameterNameGenerator,
    entityAlias: String
): SqlFragment
```

The existing `depth` parameter continues to track AND/OR nesting (checked against maxNestingDepth). The new `relationshipDepth` tracks relationship traversals (checked against maxRelationshipDepth).

Update the dispatch:
- `QueryFilter.Attribute` -> `visitAttribute(filter, paramGen, entityAlias)` -- pass entityAlias through
- `QueryFilter.Relationship` -> `visitRelationship(filter, relationshipDepth, paramGen, entityAlias)`
- `QueryFilter.And` -> `visitAnd(filter.conditions, depth, relationshipDepth, paramGen, entityAlias)`
- `QueryFilter.Or` -> `visitOr(filter.conditions, depth, relationshipDepth, paramGen, entityAlias)`

**visitAnd/visitOr changes:**
Add `relationshipDepth` and `entityAlias` parameters. Pass them through to `visitInternal`. These methods increment `depth + 1` (AND/OR depth) but pass `relationshipDepth` unchanged.

**visitAttribute changes:**
Add `entityAlias: String` parameter. Pass it to `attributeSqlGenerator.generate(..., entityAlias = entityAlias)`.

Remove the `@Suppress("UNUSED_PARAMETER")` annotation from visitRelationship -- the parameters will now be used.

Update class KDoc to document:
- Two separate depth counters: AND/OR nesting (`depth`/`maxNestingDepth`) and relationship traversal (`relationshipDepth`/`maxRelationshipDepth`)
- The entityAlias parameter for nested relationship filter support
- RelationshipSqlGenerator dependency
  </action>
  <verify>Run `./gradlew compileKotlin` -- must compile. The visitor now accepts RelationshipSqlGenerator in constructor.</verify>
  <done>AttributeFilterVisitor has RelationshipSqlGenerator dependency, relationship depth tracking separate from AND/OR depth, and entityAlias threaded through all visit methods.</done>
</task>

<task type="auto">
  <name>Task 2: Implement visitRelationship with delegation and nested filter callback</name>
  <files>src/main/kotlin/riven/core/service/entity/query/AttributeFilterVisitor.kt</files>
  <action>
Replace the Phase 2 placeholder `visitRelationship` with real implementation that delegates to RelationshipSqlGenerator.

**visitRelationship implementation:**
```kotlin
private fun visitRelationship(
    filter: QueryFilter.Relationship,
    relationshipDepth: Int,
    paramGen: ParameterNameGenerator,
    entityAlias: String
): SqlFragment {
    if (relationshipDepth >= maxRelationshipDepth) {
        throw RelationshipDepthExceededException(
            relationshipDepth + 1,
            maxRelationshipDepth
        )
    }

    val nestedVisitor: (QueryFilter, ParameterNameGenerator, String) -> SqlFragment =
        { nestedFilter, nestedParamGen, nestedEntityAlias ->
            visitInternal(
                nestedFilter,
                depth = 0,      // Reset AND/OR depth for nested filter
                relationshipDepth = relationshipDepth + 1,
                nestedParamGen,
                nestedEntityAlias
            )
        }

    return relationshipSqlGenerator.generate(
        relationshipId = filter.relationshipId,
        condition = filter.condition,
        paramGen = paramGen,
        entityAlias = entityAlias,
        nestedFilterVisitor = nestedVisitor
    )
}
```

**Key details:**
1. Depth check: `relationshipDepth >= maxRelationshipDepth` throws `RelationshipDepthExceededException`. This is a SAFETY NET -- the eager QueryFilterValidator (Plan 01) catches this first, but the visitor enforces it too.
2. The `nestedVisitor` lambda creates a closure that captures `relationshipDepth` and passes `relationshipDepth + 1` for the next level.
3. AND/OR depth resets to 0 for nested filters inside relationship traversals. A new subquery context gets its own AND/OR depth budget.
4. The `nestedEntityAlias` comes from RelationshipSqlGenerator (it will be `t_X` for the target entity alias).
5. The shared `paramGen` instance ensures parameter name uniqueness across the entire query tree.

**Imports to add:**
- `import riven.core.exceptions.query.RelationshipDepthExceededException`

**Imports to remove (if present):**
- Remove the `@Suppress("UNUSED_PARAMETER")` annotation and its import if it was explicitly imported

Update the class-level KDoc example to show a mixed attribute + relationship filter:
```kotlin
 * // Mixed attribute + relationship filter
 * val filter = QueryFilter.And(listOf(
 *     QueryFilter.Attribute(statusId, EQUALS, FilterValue.Literal("Active")),
 *     QueryFilter.Relationship(clientRelId, RelationshipCondition.Exists)
 * ))
 * val fragment = visitor.visit(filter, paramGen)
```
  </action>
  <verify>Run `./gradlew compileKotlin` -- must compile without errors or warnings. Verify the UnsupportedOperationException is gone -- the placeholder is replaced with real delegation. Verify the import for RelationshipDepthExceededException is present.</verify>
  <done>AttributeFilterVisitor.visitRelationship delegates to RelationshipSqlGenerator with nested filter callback. Relationship depth is checked before delegation. AND/OR depth resets for nested subquery contexts. The Phase 2 placeholder is fully replaced.</done>
</task>

</tasks>

<verification>
1. `./gradlew compileKotlin` passes with no errors or warnings
2. `UnsupportedOperationException` for relationship filters is gone
3. Existing attribute filter behavior unchanged (entityAlias defaults to "e")
4. Relationship depth tracked independently from AND/OR depth
5. Nested filters inside TargetMatches use target entity alias (not "e")
6. ParameterNameGenerator shared across entire query tree for uniqueness
</verification>

<success_criteria>
- The visitor handles any QueryFilter tree containing attributes, relationships, AND, OR in any combination
- Two independent depth limits enforced: AND/OR nesting (default 10) and relationship traversal (default 3)
- Nested relationship filters correctly reference target entity aliases
- No placeholder code remains from Phase 2
</success_criteria>

<output>
After completion, create `.planning/phases/03-relationship-filter-implementation/03-03-SUMMARY.md`
</output>
