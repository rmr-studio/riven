---
phase: 03-relationship-filter-implementation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/main/kotlin/riven/core/exceptions/query/QueryFilterException.kt
  - src/main/kotlin/riven/core/service/entity/query/QueryFilterValidator.kt
autonomous: true

must_haves:
  truths:
    - "Invalid relationshipId throws descriptive exception before SQL generation"
    - "Relationship depth exceeding maxDepth throws descriptive exception"
    - "Invalid TargetTypeMatches branch entityTypeId throws descriptive exception"
    - "All validation errors across the tree are collected and reported in a single exception"
    - "AND/OR nesting does not increment the relationship depth counter"
  artifacts:
    - path: "src/main/kotlin/riven/core/exceptions/query/QueryFilterException.kt"
      provides: "Relationship-specific exception subclasses"
      contains: "InvalidRelationshipReferenceException"
    - path: "src/main/kotlin/riven/core/service/entity/query/QueryFilterValidator.kt"
      provides: "Eager filter tree validation before SQL generation"
      exports: ["QueryFilterValidator"]
  key_links:
    - from: "QueryFilterValidator"
      to: "QueryFilterException sealed hierarchy"
      via: "accumulates errors as exception subclasses"
      pattern: "InvalidRelationshipReferenceException|RelationshipDepthExceededException|InvalidTypeBranchException"
    - from: "QueryFilterValidator"
      to: "EntityRelationshipDefinition"
      via: "pre-loaded map for O(1) lookups"
      pattern: "Map<UUID.*EntityRelationshipDefinition>"
---

<objective>
Create eager filter tree validation that walks the entire QueryFilter tree before SQL generation to collect all relationship validation errors.

Purpose: Fail fast with complete error context -- invalid relationship references, depth violations, and bad type branches are caught upfront in a single pass rather than surfacing one at a time during SQL generation.

Output: QueryFilterValidator class and relationship-specific exceptions added to the sealed hierarchy.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-relationship-filter-implementation/03-CONTEXT.md
@.planning/phases/03-relationship-filter-implementation/03-RESEARCH.md

@src/main/kotlin/riven/core/exceptions/query/QueryFilterException.kt
@src/main/kotlin/riven/core/models/entity/query/QueryFilter.kt
@src/main/kotlin/riven/core/models/entity/query/RelationshipCondition.kt
@src/main/kotlin/riven/core/models/entity/query/EntityQuery.kt
@src/main/kotlin/riven/core/models/entity/configuration/EntityRelationshipDefinition.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend QueryFilterException sealed hierarchy with relationship exceptions</name>
  <files>src/main/kotlin/riven/core/exceptions/query/QueryFilterException.kt</files>
  <action>
Add these exception subclasses to the existing sealed class in QueryFilterException.kt:

1. `InvalidRelationshipReferenceException(val relationshipId: UUID, val reason: String)` extending QueryFilterException.
   Message: "Relationship $relationshipId: $reason"

2. `RelationshipDepthExceededException(val depth: Int, val maxDepth: Int)` extending QueryFilterException.
   Message: "Relationship traversal depth $depth exceeds maximum $maxDepth"

3. `InvalidTypeBranchException(val entityTypeId: UUID, val relationshipId: UUID, val reason: String)` extending QueryFilterException.
   Message: "Type branch $entityTypeId for relationship $relationshipId: $reason"

4. `QueryValidationException(val validationErrors: List<QueryFilterException>)` extending QueryFilterException.
   Message: "Query validation failed with ${validationErrors.size} error(s): " + validationErrors.joinToString("; ") { it.message ?: "unknown" }
   This is the wrapper exception that contains ALL collected errors from a validation pass.

Add necessary imports (java.util.UUID). Keep existing exceptions unchanged.

Note: The sealed class must remain `sealed class QueryFilterException(message: String) : RuntimeException(message)`. New subclasses go in the same file as the existing ones.
  </action>
  <verify>Run `./gradlew compileKotlin` -- must compile without errors. Verify all 4 new exception classes exist alongside the 3 existing ones (7 total subclasses).</verify>
  <done>QueryFilterException sealed hierarchy contains InvalidRelationshipReferenceException, RelationshipDepthExceededException, InvalidTypeBranchException, and QueryValidationException alongside existing exceptions.</done>
</task>

<task type="auto">
  <name>Task 2: Create QueryFilterValidator for eager filter tree validation</name>
  <files>src/main/kotlin/riven/core/service/entity/query/QueryFilterValidator.kt</files>
  <action>
Create `QueryFilterValidator` in `service/entity/query/` package. This class walks the entire QueryFilter tree before SQL generation to collect ALL validation errors.

**Public API:**

```kotlin
class QueryFilterValidator {
    fun validate(
        filter: QueryFilter,
        relationshipDefinitions: Map<UUID, EntityRelationshipDefinition>,
        maxDepth: Int
    ): List<QueryFilterException>
}
```

Note: The validator receives a pre-loaded `Map<UUID, EntityRelationshipDefinition>` -- callers (Phase 5's EntityQueryService) will build this from `entityType.relationships?.associateBy { it.id }`. No database lookups inside the validator.

**Internal structure:**

Use a private `ValidationContext` data class holding:
- `relationshipDefinitions: Map<UUID, EntityRelationshipDefinition>`
- `maxDepth: Int`
- `errors: MutableList<QueryFilterException>` (accumulates errors)

**Tree walk logic (`walkFilter` private method):**

Dispatch on QueryFilter type:
- `QueryFilter.Attribute` -- no relationship validation needed, return immediately
- `QueryFilter.And` -- recurse into each condition with SAME `relationshipDepth` (AND/OR does NOT increment relationship depth)
- `QueryFilter.Or` -- recurse into each condition with SAME `relationshipDepth` (AND/OR does NOT increment relationship depth)
- `QueryFilter.Relationship` -- this is where validation happens:
  1. Check `relationshipDepth >= maxDepth`. If exceeded, add `RelationshipDepthExceededException(relationshipDepth + 1, maxDepth)` to errors. CONTINUE checking (don't stop early -- collect all errors).
  2. Look up `filter.relationshipId` in `relationshipDefinitions`. If not found, add `InvalidRelationshipReferenceException(filter.relationshipId, "not found in entity type relationship definitions")`. CONTINUE checking.
  3. Validate the condition via `validateCondition(filter.condition, definition, context, relationshipDepth + 1)` where `definition` may be null (if lookup failed).

**Condition validation (`validateCondition` private method):**

Dispatch on RelationshipCondition type:
- `Exists` -- no additional validation
- `NotExists` -- no additional validation
- `TargetEquals` -- no additional validation (entityIds validated at model level)
- `TargetMatches` -- recurse: `walkFilter(condition.filter, context, newRelationshipDepth)`
- `TargetTypeMatches` -- validate each branch:
  - If `definition != null` and `definition.allowPolymorphic == false`:
    - Get valid entity type keys from `definition.entityTypeKeys ?: emptyList()`
    - NOTE: TypeBranch uses `entityTypeId` (UUID) but definition uses `entityTypeKeys` (String keys). We cannot cross-reference these without a key-to-ID mapping. For now, skip this specific validation (it requires entity type lookup that Phase 5 will provide). Add a TODO comment noting this.
  - Recurse into each branch's filter (if non-null): `walkFilter(branch.filter, context, newRelationshipDepth)`
- `CountMatches` -- add nothing (out of scope for Phase 3, handled as unsupported at generation time)

**Key design points:**
- `relationshipDepth` parameter on `walkFilter` starts at 0, increments ONLY on `QueryFilter.Relationship` nodes
- AND/OR nesting depth is NOT tracked here (that's handled by the existing visitor in AttributeFilterVisitor)
- Error collection: always continue walking after finding an error to collect everything
- The public `validate()` method returns the errors list. Callers decide whether/how to throw.

Include comprehensive KDoc on the class and public method explaining:
- This is an eager pre-validation pass before SQL generation
- Errors are collected, not thrown, so callers get complete diagnostics
- The validator does NOT generate SQL
  </action>
  <verify>Run `./gradlew compileKotlin` -- must compile without errors. The class should have exactly one public method (`validate`) returning `List<QueryFilterException>`.</verify>
  <done>QueryFilterValidator walks the filter tree collecting relationship depth violations, invalid relationship references, and type branch errors into a single list without generating SQL.</done>
</task>

</tasks>

<verification>
1. `./gradlew compileKotlin` passes
2. QueryFilterException.kt has 7 subclasses total (3 existing + 4 new)
3. QueryFilterValidator.validate() returns empty list for attribute-only filters
4. QueryFilterValidator.validate() returns RelationshipDepthExceededException for depth > maxDepth
5. QueryFilterValidator.validate() returns InvalidRelationshipReferenceException for unknown relationshipId
6. QueryFilterValidator collects MULTIPLE errors in a single pass (not fail-fast)
</verification>

<success_criteria>
- Eager validation catches invalid relationships before SQL generation
- All errors collected in single tree walk
- Relationship depth tracked separately from AND/OR nesting depth
- Exception hierarchy extends cleanly from existing sealed class
</success_criteria>

<output>
After completion, create `.planning/phases/03-relationship-filter-implementation/03-01-SUMMARY.md`
</output>
