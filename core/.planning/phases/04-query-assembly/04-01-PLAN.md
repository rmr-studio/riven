---
phase: 04-query-assembly
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/main/kotlin/riven/core/models/entity/query/EntityQueryResult.kt
  - src/main/kotlin/riven/core/service/entity/query/AssembledQuery.kt
  - src/main/kotlin/riven/core/service/entity/query/EntityQueryAssembler.kt
autonomous: true

must_haves:
  truths:
    - "EntityQueryAssembler produces a parameterized data query with SELECT e.*, workspace_id filter, type_id filter, deleted=false, ORDER BY created_at DESC id ASC, and LIMIT/OFFSET"
    - "EntityQueryAssembler produces a separate parameterized count query with SELECT COUNT(*) and same WHERE clause but no ORDER BY or LIMIT/OFFSET"
    - "Pagination validation rejects limit < 1, limit > 500, and offset < 0 with descriptive IllegalArgumentException"
    - "EntityQueryResult carries entities list, totalCount, hasNextPage boolean, and projection passthrough"
    - "A single ParameterNameGenerator is shared between base conditions and filter visitor to prevent parameter name collisions"
  artifacts:
    - path: "src/main/kotlin/riven/core/service/entity/query/EntityQueryAssembler.kt"
      provides: "Complete SELECT + COUNT query assembly from filter visitor output"
      exports: ["EntityQueryAssembler"]
    - path: "src/main/kotlin/riven/core/service/entity/query/AssembledQuery.kt"
      provides: "Data class holding paired data + count SqlFragments"
      exports: ["AssembledQuery"]
    - path: "src/main/kotlin/riven/core/models/entity/query/EntityQueryResult.kt"
      provides: "Response model for query execution results"
      exports: ["EntityQueryResult"]
  key_links:
    - from: "src/main/kotlin/riven/core/service/entity/query/EntityQueryAssembler.kt"
      to: "src/main/kotlin/riven/core/service/entity/query/AttributeFilterVisitor.kt"
      via: "constructor injection, calls visitor.visit(filter, paramGen)"
      pattern: "filterVisitor\\.visit"
    - from: "src/main/kotlin/riven/core/service/entity/query/EntityQueryAssembler.kt"
      to: "src/main/kotlin/riven/core/service/entity/query/SqlFragment.kt"
      via: "composes base WHERE with filter WHERE via SqlFragment.and()"
      pattern: "baseFragment\\.and\\(filterFragment\\)"
    - from: "src/main/kotlin/riven/core/service/entity/query/EntityQueryAssembler.kt"
      to: "src/main/kotlin/riven/core/service/entity/query/ParameterNameGenerator.kt"
      via: "single shared instance for workspace, type, limit, offset params AND filter visitor params"
      pattern: "paramGen\\.next"
---

<objective>
Create the EntityQueryAssembler that composes complete parameterized SELECT and COUNT queries from filter visitor output, with pagination validation and a response model.

Purpose: Phase 4 bridges the gap between SQL fragment generation (Phases 2-3) and query execution (Phase 5). The assembler wraps visitor output in complete SQL statements with workspace isolation, default ordering, and pagination. The response model provides a typed container for query results.

Output: EntityQueryAssembler.kt, AssembledQuery.kt, EntityQueryResult.kt -- ready for Phase 5 to execute.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-query-assembly/04-CONTEXT.md
@.planning/phases/04-query-assembly/04-RESEARCH.md
@src/main/kotlin/riven/core/service/entity/query/SqlFragment.kt
@src/main/kotlin/riven/core/service/entity/query/ParameterNameGenerator.kt
@src/main/kotlin/riven/core/service/entity/query/AttributeFilterVisitor.kt
@src/main/kotlin/riven/core/models/entity/query/EntityQuery.kt
@src/main/kotlin/riven/core/models/entity/query/QueryPagination.kt
@src/main/kotlin/riven/core/models/entity/query/QueryProjection.kt
@src/main/kotlin/riven/core/models/entity/Entity.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create EntityQueryResult response model and AssembledQuery data class</name>
  <files>
    src/main/kotlin/riven/core/models/entity/query/EntityQueryResult.kt
    src/main/kotlin/riven/core/service/entity/query/AssembledQuery.kt
  </files>
  <action>
Create two simple data classes:

**EntityQueryResult.kt** in `riven.core.models.entity.query`:
- `entities: List<Entity>` -- matching entities for current page (import from `riven.core.models.entity.Entity`)
- `totalCount: Long` -- total matching entities across all pages
- `hasNextPage: Boolean` -- whether more results exist beyond current page
- `projection: QueryProjection?` -- passthrough of the projection used for the query
- Add `@Schema` OpenAPI annotation on the class (matches existing pattern in QueryPagination, QueryProjection)
- Add KDoc documenting each property and noting that `hasNextPage` is computed as `(offset + limit) < totalCount`

**AssembledQuery.kt** in `riven.core.service.entity.query`:
- `dataQuery: SqlFragment` -- the SELECT e.* query with ORDER BY, LIMIT, OFFSET
- `countQuery: SqlFragment` -- the SELECT COUNT(*) query with same WHERE but no ORDER BY/LIMIT/OFFSET
- Add KDoc explaining that both queries share the same WHERE clause conditions and that the executor runs them separately (potentially in parallel)
  </action>
  <verify>
`./gradlew compileKotlin` succeeds with no errors.
  </verify>
  <done>
EntityQueryResult data class exists with entities, totalCount, hasNextPage, projection fields. AssembledQuery data class exists with dataQuery and countQuery SqlFragment fields. Both compile cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create EntityQueryAssembler with pagination validation and query composition</name>
  <files>
    src/main/kotlin/riven/core/service/entity/query/EntityQueryAssembler.kt
  </files>
  <action>
Create `EntityQueryAssembler` in `riven.core.service.entity.query` as a Spring `@Service` with constructor injection of `AttributeFilterVisitor`.

**Public API -- single `assemble` method:**
```
fun assemble(
    entityTypeId: UUID,
    workspaceId: UUID,
    filter: QueryFilter?,
    pagination: QueryPagination,
    paramGen: ParameterNameGenerator
): AssembledQuery
```

**Implementation steps inside `assemble`:**

1. **Validate pagination first** (private `validatePagination` method):
   - `require(pagination.limit >= 1)` with message `"Limit must be at least 1, was: ${pagination.limit}"`
   - `require(pagination.limit <= MAX_LIMIT)` with message `"Limit must not exceed $MAX_LIMIT, was: ${pagination.limit}"`
   - `require(pagination.offset >= 0)` with message `"Offset must be non-negative, was: ${pagination.offset}"`

2. **Build base WHERE clause** (private `buildBaseWhereClause` method):
   - Generate params via `paramGen.next("ws")` for workspace_id and `paramGen.next("type")` for type_id
   - SQL: `e.workspace_id = :ws_0 AND e.type_id = :type_1 AND e.deleted = false`
   - Return SqlFragment with the two bound parameters (workspace UUID and entityType UUID)
   - Note: `e.deleted = false` is a literal, NOT a parameter -- it's always false

3. **Build filter WHERE clause** (if filter is non-null):
   - Call `filterVisitor.visit(filter, paramGen)` using the SAME paramGen instance (critical for unique params)
   - If filter is null, skip this step

4. **Combine WHERE clauses**:
   - If filter produced a fragment: `baseFragment.and(filterFragment)`
   - If no filter: just `baseFragment`

5. **Build data query** (private `buildDataQuery` method):
   - Generate params via `paramGen.next("limit")` and `paramGen.next("offset")`
   - SQL structure:
     ```
     SELECT e.*
     FROM entities e
     WHERE {combined WHERE clause}
     ORDER BY e.created_at DESC, e.id ASC
     LIMIT :limit_N OFFSET :offset_N
     ```
   - Return SqlFragment with whereFragment.parameters + limit/offset parameters
   - Bind `pagination.limit` and `pagination.offset` as parameter values

6. **Build count query** (private `buildCountQuery` method):
   - SQL structure:
     ```
     SELECT COUNT(*)
     FROM entities e
     WHERE {combined WHERE clause}
     ```
   - Return SqlFragment with ONLY whereFragment.parameters (no limit/offset, no ORDER BY)
   - Reuse the same whereFragment that the data query uses

7. **Return AssembledQuery(dataQuery, countQuery)**

**Companion object:**
- `const val MAX_LIMIT = 500`

**Important implementation notes:**
- Use `buildString { }` for SQL construction (matches existing pattern in RelationshipSqlGenerator)
- Do NOT put workspace_id in relationship subqueries -- that's the visitor/generator's concern and they intentionally omit it
- The `paramGen` passed in is created by the caller (Phase 5 will create it). This ensures the single-generator-per-query-tree pattern. Do not create a new ParameterNameGenerator inside the assembler.
- The entity alias is always `"e"` at the assembler level -- this is the root query
- Add comprehensive KDoc on the class explaining its role as the bridge between filter visitors and query execution
- Add `@Service` annotation (not `@Component`) to follow codebase convention
  </action>
  <verify>
`./gradlew compileKotlin` succeeds with no errors. Verify the file contains: `@Service` annotation, `AttributeFilterVisitor` constructor parameter, `assemble` method returning `AssembledQuery`, `validatePagination` with MAX_LIMIT=500, `buildBaseWhereClause` with workspace_id + type_id + deleted=false, `buildDataQuery` with ORDER BY and LIMIT/OFFSET, `buildCountQuery` without ORDER BY or LIMIT/OFFSET.
  </verify>
  <done>
EntityQueryAssembler is a Spring @Service that accepts entityTypeId, workspaceId, optional filter, pagination, and paramGen. It validates pagination (limit 1-500, offset >= 0), builds base WHERE with workspace+type+deleted filters, optionally combines with visitor filter output, and returns AssembledQuery with separate data and count SqlFragments. All parameter names are unique via the shared ParameterNameGenerator.
  </done>
</task>

</tasks>

<verification>
1. `./gradlew compileKotlin` -- all three new files compile without errors
2. EntityQueryAssembler accepts AttributeFilterVisitor via constructor injection
3. Pagination validation throws IllegalArgumentException for limit=0, limit=501, offset=-1
4. Base WHERE clause includes workspace_id, type_id, and deleted=false
5. Data query includes ORDER BY created_at DESC, id ASC and LIMIT/OFFSET
6. Count query has identical WHERE clause but no ORDER BY or LIMIT/OFFSET
7. Single ParameterNameGenerator flows through both base conditions and filter visitor
</verification>

<success_criteria>
- PAGE-01: Limit parameter caps result count with default of 100 (via QueryPagination default + assembler LIMIT clause)
- PAGE-02: Offset parameter skips results with default of 0 (via QueryPagination default + assembler OFFSET clause)
- PAGE-03: Projection includeAttributes hints available to callers (QueryProjection already exists, EntityQueryResult passes it through)
- PAGE-04: Projection includeRelationships hints available to callers (QueryProjection already exists, EntityQueryResult passes it through)
- AssembledQuery contains both data and count queries as separate SqlFragments ready for Phase 5 execution
</success_criteria>

<output>
After completion, create `.planning/phases/04-query-assembly/04-01-SUMMARY.md`
</output>
