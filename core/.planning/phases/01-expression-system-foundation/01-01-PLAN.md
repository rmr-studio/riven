---
phase: 01-expression-system-foundation
plan: 01
type: execute
---

<objective>
Build SQL-like expression parser and evaluator with type-safe evaluation against dynamic data contexts.

Purpose: Enable workflow conditional logic and data access through expressions like `entity.status = 'active' AND count > 10`. This is the foundation for all workflow decision-making and data manipulation.

Output: Working expression system with parser (string → AST), evaluator (AST + context → result), and comprehensive test coverage.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/STACK.md
@.planning/codebase/ARCHITECTURE.md
@.planning/codebase/CONVENTIONS.md

**Existing Code:**
@src/main/kotlin/riven/core/models/common/Expression.kt (commented-out expression model - uncomment and adapt)

**Tech Stack:**
- Kotlin 2.1.21 with Spring Boot 3.5.3
- JUnit 5 + Mockito for testing (already configured)
- No external parser libraries needed (hand-written recursive descent parser)

**Established Patterns:**
- Service layer: Constructor injection, `@Service` stereotype
- Domain models: Immutable data classes in `models/` package
- Error handling: Custom exceptions extending RuntimeException
- Testing: Service tests in `src/test/kotlin/riven/`, suffix `Test`
- Logging: Kotlin Logging with structured context

**Constraining Decisions:**
- None yet (Phase 1)

**Issues Being Addressed:**
- None yet
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refine Expression domain model</name>
  <files>src/main/kotlin/riven/core/models/common/Expression.kt</files>
  <action>
Uncomment the existing Expression sealed class structure and refine it for SQL-like syntax support.

**What to do:**
- Uncomment and clean up existing sealed class hierarchy
- Add support for SQL operators: `=` (equality), `AND`, `OR`, `>`, `<`, `>=`, `<=`, `!=`
- Add `PropertyAccess` expression type for field traversal: `entity.status`, `client.address.city`
- Keep: `Literal`, `BinaryOp`, `Conditional`
- Remove function calls and templates for v1 (defer to Phase 4)
- Add `Operator` enum with SQL-style operators
- Make all expression types immutable data classes

**What to avoid and WHY:**
- Don't add complex function support yet (no `uppercase()`, `round()`, etc.) - Phase 1 focuses on basic comparisons and field access only
- Don't add aggregations (`SUM`, `COUNT`) - defer to future phases
- Don't use external parser libraries (ANTLR, JParsec) - hand-written parser is simpler and more maintainable for our SQL-like subset

**Structure:**
```kotlin
package riven.core.models.common

enum class Operator {
    // Comparison
    EQUALS, NOT_EQUALS, GREATER_THAN, LESS_THAN, GREATER_EQUALS, LESS_EQUALS,
    // Logical
    AND, OR
}

sealed class Expression {
    data class Literal(val value: Any) : Expression()
    data class PropertyAccess(val path: List<String>) : Expression()
    data class BinaryOp(val left: Expression, val operator: Operator, val right: Expression) : Expression()
}
```
  </action>
  <verify>Kotlin compiles without errors: `./gradlew compileKotlin`</verify>
  <done>Expression.kt uncommented, refined for SQL-like syntax, compiles successfully</done>
</task>

<task type="auto">
  <name>Task 2: Implement expression parser</name>
  <files>src/main/kotlin/riven/core/service/workflow/ExpressionParserService.kt, src/test/kotlin/riven/core/service/workflow/ExpressionParserServiceTest.kt</files>
  <action>
Create a recursive descent parser that converts SQL-like expression strings into Expression AST.

**ExpressionParserService:**
- Annotate with `@Service`
- Constructor injection (no dependencies needed yet)
- Main method: `fun parse(expression: String): Expression`
- Tokenize input: Split on operators, parentheses, whitespace (preserve quoted strings)
- Parse tokens into AST using recursive descent:
  - `parseExpression()` - handles `OR` (lowest precedence)
  - `parseAnd()` - handles `AND`
  - `parseComparison()` - handles `=`, `!=`, `>`, `<`, `>=`, `<=`
  - `parsePrimary()` - handles literals, property access, parentheses
- Property access: `entity.status` → `PropertyAccess(["entity", "status"])`
- Literals: Numbers (Int/Long/Double), Strings (single quotes), Booleans (true/false)
- Throw `IllegalArgumentException` with clear message on parse errors

**What to avoid and WHY:**
- Don't use regex for parsing - recursive descent is more maintainable and provides better error messages
- Don't support function calls yet (no `COUNT()`, `SUM()`) - Phase 1 is comparisons only
- Don't add operator precedence beyond AND > OR > comparison - keep it simple

**Test cases (ExpressionParserServiceTest):**
- Simple comparison: `"status = 'active'"` → `BinaryOp(PropertyAccess(["status"]), EQUALS, Literal("active"))`
- Logical AND: `"status = 'active' AND count > 10"`
- Logical OR: `"priority = 'high' OR amount > 1000"`
- Nested properties: `"client.address.city = 'NYC'"`
- Combined: `"(status = 'active' OR status = 'pending') AND count > 5"`
- Error cases: Invalid syntax, unbalanced parentheses, unknown operators
  </action>
  <verify>All tests pass: `./gradlew test --tests ExpressionParserServiceTest`</verify>
  <done>Parser converts SQL-like strings to Expression AST, all tests pass, error handling works</done>
</task>

<task type="auto">
  <name>Task 3: Implement expression evaluator</name>
  <files>src/main/kotlin/riven/core/service/workflow/ExpressionEvaluatorService.kt, src/test/kotlin/riven/core/service/workflow/ExpressionEvaluatorServiceTest.kt</files>
  <action>
Create an evaluator that executes Expression AST against a data context and returns the result.

**ExpressionEvaluatorService:**
- Annotate with `@Service`
- Constructor injection (no dependencies needed yet)
- Main method: `fun evaluate(expression: Expression, context: Map<String, Any?>): Any?`
- Handle each expression type:
  - `Literal`: Return value directly
  - `PropertyAccess`: Traverse context using path (support nested maps: `context["entity"]?.get("status")`)
  - `BinaryOp`: Evaluate left and right, apply operator with type coercion
- Type coercion rules:
  - String comparisons: Case-sensitive
  - Number comparisons: Convert Int/Long/Double as needed
  - Boolean operators: Truthy evaluation (null/false = false, everything else = true)
- Return type: `Any?` (Boolean for comparisons, original type for property access)
- Throw `IllegalArgumentException` for type mismatches with clear message

**What to avoid and WHY:**
- Don't add complex type casting (no `String` → `Int` coercion) - fail fast on type errors to catch issues early
- Don't support implicit null handling (null should fail comparisons) - explicit is better than implicit
- Don't cache evaluation results - stateless evaluation keeps it simple and thread-safe

**Test cases (ExpressionEvaluatorServiceTest):**
- Simple equality: `status = 'active'` with context `{"status": "active"}` → `true`
- Number comparison: `count > 10` with context `{"count": 15}` → `true`
- Logical AND: `status = 'active' AND count > 10`
- Logical OR: `priority = 'high' OR amount > 1000`
- Nested property: `client.address.city = 'NYC'` with nested map context
- Type mismatches: `count > 'abc'` should throw `IllegalArgumentException`
- Missing properties: `unknownField = 'value'` should throw `IllegalArgumentException`
  </action>
  <verify>All tests pass: `./gradlew test --tests ExpressionEvaluatorServiceTest`</verify>
  <done>Evaluator executes expressions against context, all tests pass, type safety enforced</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `./gradlew compileKotlin` succeeds without errors
- [ ] `./gradlew test --tests *Expression*` passes all tests
- [ ] Expression model supports SQL-like syntax (=, AND, OR, property access)
- [ ] Parser converts strings to AST correctly
- [ ] Evaluator executes AST against context with type safety
- [ ] Error messages are clear and actionable
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No TypeScript/Kotlin compiler errors
- Expression system ready for entity context integration (Phase 2)
- Test coverage for parsing and evaluation
- Clear error handling for invalid syntax and type mismatches
</success_criteria>

<output>
After completion, create `.planning/phases/01-expression-system-foundation/01-01-SUMMARY.md`:

# Phase 1 Plan 1: Expression System Foundation Summary

**[One-line summary of what shipped]**

## Accomplishments

- [Key outcome 1]
- [Key outcome 2]
- [Key outcome 3]

## Files Created/Modified

- `src/main/kotlin/riven/core/models/common/Expression.kt` - Expression domain model
- `src/main/kotlin/riven/core/service/workflow/ExpressionParserService.kt` - SQL-like parser
- `src/main/kotlin/riven/core/service/workflow/ExpressionEvaluatorService.kt` - Expression evaluator
- `src/test/kotlin/riven/core/service/workflow/ExpressionParserServiceTest.kt` - Parser tests
- `src/test/kotlin/riven/core/service/workflow/ExpressionEvaluatorServiceTest.kt` - Evaluator tests

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Phase Readiness

Ready for Phase 2: Entity Context Integration
</output>
