/* tslint:disable */
/* eslint-disable */
/**
 * Riven Core API
 * API documentation for Riven Core services.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { CountMatches } from './CountMatches';
import {
    instanceOfCountMatches,
    CountMatchesFromJSON,
    CountMatchesFromJSONTyped,
    CountMatchesToJSON,
} from './CountMatches';
import type { Exists } from './Exists';
import {
    instanceOfExists,
    ExistsFromJSON,
    ExistsFromJSONTyped,
    ExistsToJSON,
} from './Exists';
import type { NotExists } from './NotExists';
import {
    instanceOfNotExists,
    NotExistsFromJSON,
    NotExistsFromJSONTyped,
    NotExistsToJSON,
} from './NotExists';
import type { TargetEquals } from './TargetEquals';
import {
    instanceOfTargetEquals,
    TargetEqualsFromJSON,
    TargetEqualsFromJSONTyped,
    TargetEqualsToJSON,
} from './TargetEquals';
import type { TargetMatches } from './TargetMatches';
import {
    instanceOfTargetMatches,
    TargetMatchesFromJSON,
    TargetMatchesFromJSONTyped,
    TargetMatchesToJSON,
} from './TargetMatches';

/**
 * @type RelationshipCondition
 * Condition for evaluating relationships in filters.
 * @export
 */
export type RelationshipCondition = { type: 'CountMatches' } & CountMatches | { type: 'Exists' } & Exists | { type: 'NotExists' } & NotExists | { type: 'TargetEquals' } & TargetEquals | { type: 'TargetMatches' } & TargetMatches;

export function RelationshipConditionFromJSON(json: any): RelationshipCondition {
    return RelationshipConditionFromJSONTyped(json, false);
}

export function RelationshipConditionFromJSONTyped(json: any, ignoreDiscriminator: boolean): RelationshipCondition {
    if (json == null) {
        return json;
    }
    switch (json['type']) {
        case 'CountMatches':
            return Object.assign({}, CountMatchesFromJSONTyped(json, true), { type: 'CountMatches' } as const);
        case 'Exists':
            return Object.assign({}, ExistsFromJSONTyped(json, true), { type: 'Exists' } as const);
        case 'NotExists':
            return Object.assign({}, NotExistsFromJSONTyped(json, true), { type: 'NotExists' } as const);
        case 'TargetEquals':
            return Object.assign({}, TargetEqualsFromJSONTyped(json, true), { type: 'TargetEquals' } as const);
        case 'TargetMatches':
            return Object.assign({}, TargetMatchesFromJSONTyped(json, true), { type: 'TargetMatches' } as const);
        default:
            return json;
    }
}

export function RelationshipConditionToJSON(json: any): any {
    return RelationshipConditionToJSONTyped(json, false);
}

export function RelationshipConditionToJSONTyped(value?: RelationshipCondition | null, ignoreDiscriminator: boolean = false): any {
    if (value == null) {
        return value;
    }
    switch (value['type']) {
        case 'CountMatches':
            return Object.assign({}, CountMatchesToJSON(value), { type: 'CountMatches' } as const);
        case 'Exists':
            return Object.assign({}, ExistsToJSON(value), { type: 'Exists' } as const);
        case 'NotExists':
            return Object.assign({}, NotExistsToJSON(value), { type: 'NotExists' } as const);
        case 'TargetEquals':
            return Object.assign({}, TargetEqualsToJSON(value), { type: 'TargetEquals' } as const);
        case 'TargetMatches':
            return Object.assign({}, TargetMatchesToJSON(value), { type: 'TargetMatches' } as const);
        default:
            return value;
    }
}

