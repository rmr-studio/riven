/* tslint:disable */
/* eslint-disable */
/**
 * Riven Core API
 * API documentation for Riven Core services.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  CreateWorkflowEdgeRequest,
  ExecutionQueueRequest,
  SaveWorkflowDefinitionRequest,
  SaveWorkflowDefinitionResponse,
  SaveWorkflowNodeRequest,
  SaveWorkflowNodeResponse,
  StartWorkflowExecutionRequest,
  WorkflowDefinition,
  WorkflowEdge,
  WorkflowExecutionRecord,
  WorkflowExecutionSummaryResponse,
  WorkflowGraph,
  WorkflowNodeConfigField,
} from '../models/index';
import {
    CreateWorkflowEdgeRequestFromJSON,
    CreateWorkflowEdgeRequestToJSON,
    ExecutionQueueRequestFromJSON,
    ExecutionQueueRequestToJSON,
    SaveWorkflowDefinitionRequestFromJSON,
    SaveWorkflowDefinitionRequestToJSON,
    SaveWorkflowDefinitionResponseFromJSON,
    SaveWorkflowDefinitionResponseToJSON,
    SaveWorkflowNodeRequestFromJSON,
    SaveWorkflowNodeRequestToJSON,
    SaveWorkflowNodeResponseFromJSON,
    SaveWorkflowNodeResponseToJSON,
    StartWorkflowExecutionRequestFromJSON,
    StartWorkflowExecutionRequestToJSON,
    WorkflowDefinitionFromJSON,
    WorkflowDefinitionToJSON,
    WorkflowEdgeFromJSON,
    WorkflowEdgeToJSON,
    WorkflowExecutionRecordFromJSON,
    WorkflowExecutionRecordToJSON,
    WorkflowExecutionSummaryResponseFromJSON,
    WorkflowExecutionSummaryResponseToJSON,
    WorkflowGraphFromJSON,
    WorkflowGraphToJSON,
    WorkflowNodeConfigFieldFromJSON,
    WorkflowNodeConfigFieldToJSON,
} from '../models/index';

export interface CreateEdgeRequest {
    workspaceId: string;
    createWorkflowEdgeRequest: CreateWorkflowEdgeRequest;
}

export interface DeleteEdgeRequest {
    id: string;
    workspaceId: string;
}

export interface DeleteNodeRequest {
    id: string;
    workspaceId: string;
}

export interface DeleteWorkflowRequest {
    id: string;
    workspaceId: string;
}

export interface GetExecutionRequest {
    id: string;
    workspaceId: string;
}

export interface GetExecutionSummaryRequest {
    id: string;
    workspaceId: string;
}

export interface GetWorkflowRequest {
    id: string;
    workspaceId: string;
}

export interface GetWorkflowGraphRequest {
    workflowDefinitionId: string;
    workspaceId: string;
}

export interface ListWorkflowExecutionsRequest {
    workflowDefinitionId: string;
    workspaceId: string;
}

export interface ListWorkflowsRequest {
    workspaceId: string;
}

export interface ListWorkspaceExecutionsRequest {
    workspaceId: string;
}

export interface SaveNodeRequest {
    workspaceId: string;
    saveWorkflowNodeRequest: SaveWorkflowNodeRequest;
}

export interface SaveWorkflowRequest {
    workspaceId: string;
    saveWorkflowDefinitionRequest: SaveWorkflowDefinitionRequest;
}

export interface StartExecutionRequest {
    startWorkflowExecutionRequest: StartWorkflowExecutionRequest;
}

/**
 * 
 */
export class WorkflowApi extends runtime.BaseAPI {

    /**
     * Creates a new edge connecting two workflow nodes in the workspace.
     * Create a new workflow edge
     */
    async createEdgeRaw(requestParameters: CreateEdgeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<WorkflowEdge>> {
        if (requestParameters['workspaceId'] == null) {
            throw new runtime.RequiredError(
                'workspaceId',
                'Required parameter "workspaceId" was null or undefined when calling createEdge().'
            );
        }

        if (requestParameters['createWorkflowEdgeRequest'] == null) {
            throw new runtime.RequiredError(
                'createWorkflowEdgeRequest',
                'Required parameter "createWorkflowEdgeRequest" was null or undefined when calling createEdge().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/workflow/graph/edges/workspace/{workspaceId}`;
        urlPath = urlPath.replace(`{${"workspaceId"}}`, encodeURIComponent(String(requestParameters['workspaceId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateWorkflowEdgeRequestToJSON(requestParameters['createWorkflowEdgeRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkflowEdgeFromJSON(jsonValue));
    }

    /**
     * Creates a new edge connecting two workflow nodes in the workspace.
     * Create a new workflow edge
     */
    async createEdge(requestParameters: CreateEdgeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<WorkflowEdge> {
        const response = await this.createEdgeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Soft-deletes a workflow edge. Does not affect connected nodes.
     * Delete workflow edge
     */
    async deleteEdgeRaw(requestParameters: DeleteEdgeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling deleteEdge().'
            );
        }

        if (requestParameters['workspaceId'] == null) {
            throw new runtime.RequiredError(
                'workspaceId',
                'Required parameter "workspaceId" was null or undefined when calling deleteEdge().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['workspaceId'] != null) {
            queryParameters['workspaceId'] = requestParameters['workspaceId'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/workflow/graph/edges/{id}`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Soft-deletes a workflow edge. Does not affect connected nodes.
     * Delete workflow edge
     */
    async deleteEdge(requestParameters: DeleteEdgeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteEdgeRaw(requestParameters, initOverrides);
    }

    /**
     * Soft-deletes a workflow node and all edges connected to it. This maintains graph consistency.
     * Delete workflow node (cascades to connected edges)
     */
    async deleteNodeRaw(requestParameters: DeleteNodeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling deleteNode().'
            );
        }

        if (requestParameters['workspaceId'] == null) {
            throw new runtime.RequiredError(
                'workspaceId',
                'Required parameter "workspaceId" was null or undefined when calling deleteNode().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['workspaceId'] != null) {
            queryParameters['workspaceId'] = requestParameters['workspaceId'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/workflow/graph/nodes/{id}`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Soft-deletes a workflow node and all edges connected to it. This maintains graph consistency.
     * Delete workflow node (cascades to connected edges)
     */
    async deleteNode(requestParameters: DeleteNodeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteNodeRaw(requestParameters, initOverrides);
    }

    /**
     * Soft-deletes a workflow definition. The definition can be restored if needed.
     * Delete workflow definition
     */
    async deleteWorkflowRaw(requestParameters: DeleteWorkflowRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling deleteWorkflow().'
            );
        }

        if (requestParameters['workspaceId'] == null) {
            throw new runtime.RequiredError(
                'workspaceId',
                'Required parameter "workspaceId" was null or undefined when calling deleteWorkflow().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['workspaceId'] != null) {
            queryParameters['workspaceId'] = requestParameters['workspaceId'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/workflow/definitions/{id}`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Soft-deletes a workflow definition. The definition can be restored if needed.
     * Delete workflow definition
     */
    async deleteWorkflow(requestParameters: DeleteWorkflowRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteWorkflowRaw(requestParameters, initOverrides);
    }

    /**
     * Get workflow execution by ID
     */
    async getExecutionRaw(requestParameters: GetExecutionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<WorkflowExecutionRecord>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getExecution().'
            );
        }

        if (requestParameters['workspaceId'] == null) {
            throw new runtime.RequiredError(
                'workspaceId',
                'Required parameter "workspaceId" was null or undefined when calling getExecution().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['workspaceId'] != null) {
            queryParameters['workspaceId'] = requestParameters['workspaceId'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/workflow/executions/{id}`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkflowExecutionRecordFromJSON(jsonValue));
    }

    /**
     * Get workflow execution by ID
     */
    async getExecution(requestParameters: GetExecutionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<WorkflowExecutionRecord> {
        const response = await this.getExecutionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns execution record and status for each node in the workflow
     * Get execution summary with node details
     */
    async getExecutionSummaryRaw(requestParameters: GetExecutionSummaryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<WorkflowExecutionSummaryResponse>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getExecutionSummary().'
            );
        }

        if (requestParameters['workspaceId'] == null) {
            throw new runtime.RequiredError(
                'workspaceId',
                'Required parameter "workspaceId" was null or undefined when calling getExecutionSummary().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['workspaceId'] != null) {
            queryParameters['workspaceId'] = requestParameters['workspaceId'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/workflow/executions/{id}/summary`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkflowExecutionSummaryResponseFromJSON(jsonValue));
    }

    /**
     * Returns execution record and status for each node in the workflow
     * Get execution summary with node details
     */
    async getExecutionSummary(requestParameters: GetExecutionSummaryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<WorkflowExecutionSummaryResponse> {
        const response = await this.getExecutionSummaryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves the configuration schemas for all workflow node types. Returns a map where keys are node identifiers (e.g., \'ACTION.CREATE_ENTITY\') and values are lists of configuration fields.
     * Get workflow node configuration schemas
     */
    async getNodeConfigSchemasRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<{ [key: string]: Array<WorkflowNodeConfigField>; }>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/workflow/definitions/node-schemas`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Retrieves the configuration schemas for all workflow node types. Returns a map where keys are node identifiers (e.g., \'ACTION.CREATE_ENTITY\') and values are lists of configuration fields.
     * Get workflow node configuration schemas
     */
    async getNodeConfigSchemas(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<{ [key: string]: Array<WorkflowNodeConfigField>; }> {
        const response = await this.getNodeConfigSchemasRaw(initOverrides);
        return await response.value();
    }

    /**
     * Retrieves a workflow definition by its ID. Requires workspace access.
     * Get workflow definition by ID
     */
    async getWorkflowRaw(requestParameters: GetWorkflowRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<WorkflowDefinition>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getWorkflow().'
            );
        }

        if (requestParameters['workspaceId'] == null) {
            throw new runtime.RequiredError(
                'workspaceId',
                'Required parameter "workspaceId" was null or undefined when calling getWorkflow().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['workspaceId'] != null) {
            queryParameters['workspaceId'] = requestParameters['workspaceId'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/workflow/definitions/{id}`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkflowDefinitionFromJSON(jsonValue));
    }

    /**
     * Retrieves a workflow definition by its ID. Requires workspace access.
     * Get workflow definition by ID
     */
    async getWorkflow(requestParameters: GetWorkflowRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<WorkflowDefinition> {
        const response = await this.getWorkflowRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the complete DAG structure with all nodes and edges for the workflow definition.
     * Get complete workflow graph (nodes and edges)
     */
    async getWorkflowGraphRaw(requestParameters: GetWorkflowGraphRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<WorkflowGraph>> {
        if (requestParameters['workflowDefinitionId'] == null) {
            throw new runtime.RequiredError(
                'workflowDefinitionId',
                'Required parameter "workflowDefinitionId" was null or undefined when calling getWorkflowGraph().'
            );
        }

        if (requestParameters['workspaceId'] == null) {
            throw new runtime.RequiredError(
                'workspaceId',
                'Required parameter "workspaceId" was null or undefined when calling getWorkflowGraph().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['workspaceId'] != null) {
            queryParameters['workspaceId'] = requestParameters['workspaceId'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/workflow/graph/workflow/{workflowDefinitionId}`;
        urlPath = urlPath.replace(`{${"workflowDefinitionId"}}`, encodeURIComponent(String(requestParameters['workflowDefinitionId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkflowGraphFromJSON(jsonValue));
    }

    /**
     * Returns the complete DAG structure with all nodes and edges for the workflow definition.
     * Get complete workflow graph (nodes and edges)
     */
    async getWorkflowGraph(requestParameters: GetWorkflowGraphRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<WorkflowGraph> {
        const response = await this.getWorkflowGraphRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns execution history ordered by most recent first
     * List all executions for a workflow definition
     */
    async listWorkflowExecutionsRaw(requestParameters: ListWorkflowExecutionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<WorkflowExecutionRecord>>> {
        if (requestParameters['workflowDefinitionId'] == null) {
            throw new runtime.RequiredError(
                'workflowDefinitionId',
                'Required parameter "workflowDefinitionId" was null or undefined when calling listWorkflowExecutions().'
            );
        }

        if (requestParameters['workspaceId'] == null) {
            throw new runtime.RequiredError(
                'workspaceId',
                'Required parameter "workspaceId" was null or undefined when calling listWorkflowExecutions().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['workspaceId'] != null) {
            queryParameters['workspaceId'] = requestParameters['workspaceId'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/workflow/executions/workflow/{workflowDefinitionId}`;
        urlPath = urlPath.replace(`{${"workflowDefinitionId"}}`, encodeURIComponent(String(requestParameters['workflowDefinitionId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(WorkflowExecutionRecordFromJSON));
    }

    /**
     * Returns execution history ordered by most recent first
     * List all executions for a workflow definition
     */
    async listWorkflowExecutions(requestParameters: ListWorkflowExecutionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<WorkflowExecutionRecord>> {
        const response = await this.listWorkflowExecutionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves all workflow definitions associated with the specified workspace.
     * List all workflow definitions for workspace
     */
    async listWorkflowsRaw(requestParameters: ListWorkflowsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<WorkflowDefinition>>> {
        if (requestParameters['workspaceId'] == null) {
            throw new runtime.RequiredError(
                'workspaceId',
                'Required parameter "workspaceId" was null or undefined when calling listWorkflows().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/workflow/definitions/workspace/{workspaceId}`;
        urlPath = urlPath.replace(`{${"workspaceId"}}`, encodeURIComponent(String(requestParameters['workspaceId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(WorkflowDefinitionFromJSON));
    }

    /**
     * Retrieves all workflow definitions associated with the specified workspace.
     * List all workflow definitions for workspace
     */
    async listWorkflows(requestParameters: ListWorkflowsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<WorkflowDefinition>> {
        const response = await this.listWorkflowsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns all workflow executions across all workflows in workspace
     * List all executions for workspace
     */
    async listWorkspaceExecutionsRaw(requestParameters: ListWorkspaceExecutionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<WorkflowExecutionRecord>>> {
        if (requestParameters['workspaceId'] == null) {
            throw new runtime.RequiredError(
                'workspaceId',
                'Required parameter "workspaceId" was null or undefined when calling listWorkspaceExecutions().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/workflow/executions/workspace/{workspaceId}`;
        urlPath = urlPath.replace(`{${"workspaceId"}}`, encodeURIComponent(String(requestParameters['workspaceId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(WorkflowExecutionRecordFromJSON));
    }

    /**
     * Returns all workflow executions across all workflows in workspace
     * List all executions for workspace
     */
    async listWorkspaceExecutions(requestParameters: ListWorkspaceExecutionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<WorkflowExecutionRecord>> {
        const response = await this.listWorkspaceExecutionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Saves a workflow node - creates new if id is null, updates existing if id is provided. Config changes on update create a new version.
     * Save a workflow node
     */
    async saveNodeRaw(requestParameters: SaveNodeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SaveWorkflowNodeResponse>> {
        if (requestParameters['workspaceId'] == null) {
            throw new runtime.RequiredError(
                'workspaceId',
                'Required parameter "workspaceId" was null or undefined when calling saveNode().'
            );
        }

        if (requestParameters['saveWorkflowNodeRequest'] == null) {
            throw new runtime.RequiredError(
                'saveWorkflowNodeRequest',
                'Required parameter "saveWorkflowNodeRequest" was null or undefined when calling saveNode().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/workflow/graph/workspace/{workspaceId}/node`;
        urlPath = urlPath.replace(`{${"workspaceId"}}`, encodeURIComponent(String(requestParameters['workspaceId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SaveWorkflowNodeRequestToJSON(requestParameters['saveWorkflowNodeRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SaveWorkflowNodeResponseFromJSON(jsonValue));
    }

    /**
     * Saves a workflow node - creates new if id is null, updates existing if id is provided. Config changes on update create a new version.
     * Save a workflow node
     */
    async saveNode(requestParameters: SaveNodeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SaveWorkflowNodeResponse> {
        const response = await this.saveNodeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Saves a workflow definition - creates new if id is null, updates existing if id is provided. Only metadata is updated on existing definitions.
     * Save a workflow definition
     */
    async saveWorkflowRaw(requestParameters: SaveWorkflowRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SaveWorkflowDefinitionResponse>> {
        if (requestParameters['workspaceId'] == null) {
            throw new runtime.RequiredError(
                'workspaceId',
                'Required parameter "workspaceId" was null or undefined when calling saveWorkflow().'
            );
        }

        if (requestParameters['saveWorkflowDefinitionRequest'] == null) {
            throw new runtime.RequiredError(
                'saveWorkflowDefinitionRequest',
                'Required parameter "saveWorkflowDefinitionRequest" was null or undefined when calling saveWorkflow().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/workflow/definitions/workspace/{workspaceId}`;
        urlPath = urlPath.replace(`{${"workspaceId"}}`, encodeURIComponent(String(requestParameters['workspaceId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SaveWorkflowDefinitionRequestToJSON(requestParameters['saveWorkflowDefinitionRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SaveWorkflowDefinitionResponseFromJSON(jsonValue));
    }

    /**
     * Saves a workflow definition - creates new if id is null, updates existing if id is provided. Only metadata is updated on existing definitions.
     * Save a workflow definition
     */
    async saveWorkflow(requestParameters: SaveWorkflowRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SaveWorkflowDefinitionResponse> {
        const response = await this.saveWorkflowRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Queue a workflow execution
     */
    async startExecutionRaw(requestParameters: StartExecutionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExecutionQueueRequest>> {
        if (requestParameters['startWorkflowExecutionRequest'] == null) {
            throw new runtime.RequiredError(
                'startWorkflowExecutionRequest',
                'Required parameter "startWorkflowExecutionRequest" was null or undefined when calling startExecution().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/workflow/executions/start`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: StartWorkflowExecutionRequestToJSON(requestParameters['startWorkflowExecutionRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ExecutionQueueRequestFromJSON(jsonValue));
    }

    /**
     * Queue a workflow execution
     */
    async startExecution(requestParameters: StartExecutionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExecutionQueueRequest> {
        const response = await this.startExecutionRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
