/* tslint:disable */
/* eslint-disable */
/**
 * Riven Core API
 * API documentation for Riven Core services.
 *
 * The version of the OpenAPI document: v1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from '../runtime';
import type {
  CreateEntityTypeRequest,
  DeleteEntityResponse,
  DeleteTypeDefinitionRequest,
  Entity,
  EntityType,
  EntityTypeImpactResponse,
  SaveEntityRequest,
  SaveEntityResponse,
  SaveTypeDefinitionRequest,
} from '../models/index';
import {
  CreateEntityTypeRequestFromJSON,
  CreateEntityTypeRequestToJSON,
  DeleteEntityResponseFromJSON,
  DeleteEntityResponseToJSON,
  DeleteTypeDefinitionRequestFromJSON,
  DeleteTypeDefinitionRequestToJSON,
  EntityFromJSON,
  EntityToJSON,
  EntityTypeFromJSON,
  EntityTypeToJSON,
  EntityTypeImpactResponseFromJSON,
  EntityTypeImpactResponseToJSON,
  SaveEntityRequestFromJSON,
  SaveEntityRequestToJSON,
  SaveEntityResponseFromJSON,
  SaveEntityResponseToJSON,
  SaveTypeDefinitionRequestFromJSON,
  SaveTypeDefinitionRequestToJSON,
} from '../models/index';

export interface CreateEntityTypeOperationRequest {
  workspaceId: string;
  createEntityTypeRequest: CreateEntityTypeRequest;
}

export interface DeleteEntityRequest {
  workspaceId: string;
  requestBody: Array<string>;
}

export interface DeleteEntityTypeByKeyRequest {
  workspaceId: string;
  key: string;
  impactConfirmed?: boolean;
}

export interface DeleteEntityTypeDefinitionRequest {
  workspaceId: string;
  deleteTypeDefinitionRequest: DeleteTypeDefinitionRequest;
  impactConfirmed?: boolean;
}

export interface GetEntityByTypeIdForWorkspaceRequest {
  workspaceId: string;
  id: string;
}

export interface GetEntityByTypeIdInForWorkspaceRequest {
  workspaceId: string;
  ids: Array<string>;
}

export interface GetEntityTypeByKeyForWorkspaceRequest {
  workspaceId: string;
  key: string;
}

export interface GetEntityTypesForWorkspaceRequest {
  workspaceId: string;
}

export interface SaveEntityOperationRequest {
  workspaceId: string;
  entityTypeId: string;
  saveEntityRequest: SaveEntityRequest;
}

export interface SaveEntityTypeDefinitionRequest {
  workspaceId: string;
  saveTypeDefinitionRequest: SaveTypeDefinitionRequest;
  impactConfirmed?: boolean;
}

export interface UpdateEntityTypeRequest {
  workspaceId: string;
  entityType: EntityType;
}

/**
 *
 */
export class EntityApi extends runtime.BaseAPI {
  /**
   * Creates and publishes a new entity type for the specified workspace.
   * Create a new entity type
   */
  async createEntityTypeRaw(
    requestParameters: CreateEntityTypeOperationRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<EntityType>> {
    if (requestParameters['workspaceId'] == null) {
      throw new runtime.RequiredError(
        'workspaceId',
        'Required parameter "workspaceId" was null or undefined when calling createEntityType().',
      );
    }

    if (requestParameters['createEntityTypeRequest'] == null) {
      throw new runtime.RequiredError(
        'createEntityTypeRequest',
        'Required parameter "createEntityTypeRequest" was null or undefined when calling createEntityType().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('bearerAuth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }

    let urlPath = `/api/v1/entity/schema/workspace/{workspaceId}`;
    urlPath = urlPath.replace(
      `{${'workspaceId'}}`,
      encodeURIComponent(String(requestParameters['workspaceId'])),
    );

    const response = await this.request(
      {
        path: urlPath,
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: CreateEntityTypeRequestToJSON(requestParameters['createEntityTypeRequest']),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => EntityTypeFromJSON(jsonValue));
  }

  /**
   * Creates and publishes a new entity type for the specified workspace.
   * Create a new entity type
   */
  async createEntityType(
    requestParameters: CreateEntityTypeOperationRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<EntityType> {
    const response = await this.createEntityTypeRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Deleted the specified entity instance within the workspace.
   * Deletes an entity instance
   */
  async deleteEntityRaw(
    requestParameters: DeleteEntityRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<DeleteEntityResponse>> {
    if (requestParameters['workspaceId'] == null) {
      throw new runtime.RequiredError(
        'workspaceId',
        'Required parameter "workspaceId" was null or undefined when calling deleteEntity().',
      );
    }

    if (requestParameters['requestBody'] == null) {
      throw new runtime.RequiredError(
        'requestBody',
        'Required parameter "requestBody" was null or undefined when calling deleteEntity().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('bearerAuth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }

    let urlPath = `/api/v1/entity/workspace/{workspaceId}`;
    urlPath = urlPath.replace(
      `{${'workspaceId'}}`,
      encodeURIComponent(String(requestParameters['workspaceId'])),
    );

    const response = await this.request(
      {
        path: urlPath,
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
        body: requestParameters['requestBody'],
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      DeleteEntityResponseFromJSON(jsonValue),
    );
  }

  /**
   * Deleted the specified entity instance within the workspace.
   * Deletes an entity instance
   */
  async deleteEntity(
    requestParameters: DeleteEntityRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<DeleteEntityResponse> {
    const response = await this.deleteEntityRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Deletes the specified entity type by its key for the given workspace.
   * Delete an entity type by key
   */
  async deleteEntityTypeByKeyRaw(
    requestParameters: DeleteEntityTypeByKeyRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<EntityTypeImpactResponse>> {
    if (requestParameters['workspaceId'] == null) {
      throw new runtime.RequiredError(
        'workspaceId',
        'Required parameter "workspaceId" was null or undefined when calling deleteEntityTypeByKey().',
      );
    }

    if (requestParameters['key'] == null) {
      throw new runtime.RequiredError(
        'key',
        'Required parameter "key" was null or undefined when calling deleteEntityTypeByKey().',
      );
    }

    const queryParameters: any = {};

    if (requestParameters['impactConfirmed'] != null) {
      queryParameters['impactConfirmed'] = requestParameters['impactConfirmed'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('bearerAuth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }

    let urlPath = `/api/v1/entity/schema/workspace/{workspaceId}/key/{key}`;
    urlPath = urlPath.replace(
      `{${'workspaceId'}}`,
      encodeURIComponent(String(requestParameters['workspaceId'])),
    );
    urlPath = urlPath.replace(`{${'key'}}`, encodeURIComponent(String(requestParameters['key'])));

    const response = await this.request(
      {
        path: urlPath,
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      EntityTypeImpactResponseFromJSON(jsonValue),
    );
  }

  /**
   * Deletes the specified entity type by its key for the given workspace.
   * Delete an entity type by key
   */
  async deleteEntityTypeByKey(
    requestParameters: DeleteEntityTypeByKeyRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<EntityTypeImpactResponse> {
    const response = await this.deleteEntityTypeByKeyRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Removes an attribute or relationship from the specified entity type for the given workspace.
   * Removes an attribute or relationship from an entity type
   */
  async deleteEntityTypeDefinitionRaw(
    requestParameters: DeleteEntityTypeDefinitionRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<EntityTypeImpactResponse>> {
    if (requestParameters['workspaceId'] == null) {
      throw new runtime.RequiredError(
        'workspaceId',
        'Required parameter "workspaceId" was null or undefined when calling deleteEntityTypeDefinition().',
      );
    }

    if (requestParameters['deleteTypeDefinitionRequest'] == null) {
      throw new runtime.RequiredError(
        'deleteTypeDefinitionRequest',
        'Required parameter "deleteTypeDefinitionRequest" was null or undefined when calling deleteEntityTypeDefinition().',
      );
    }

    const queryParameters: any = {};

    if (requestParameters['impactConfirmed'] != null) {
      queryParameters['impactConfirmed'] = requestParameters['impactConfirmed'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('bearerAuth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }

    let urlPath = `/api/v1/entity/schema/workspace/{workspaceId}/definition`;
    urlPath = urlPath.replace(
      `{${'workspaceId'}}`,
      encodeURIComponent(String(requestParameters['workspaceId'])),
    );

    const response = await this.request(
      {
        path: urlPath,
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
        body: DeleteTypeDefinitionRequestToJSON(requestParameters['deleteTypeDefinitionRequest']),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      EntityTypeImpactResponseFromJSON(jsonValue),
    );
  }

  /**
   * Removes an attribute or relationship from the specified entity type for the given workspace.
   * Removes an attribute or relationship from an entity type
   */
  async deleteEntityTypeDefinition(
    requestParameters: DeleteEntityTypeDefinitionRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<EntityTypeImpactResponse> {
    const response = await this.deleteEntityTypeDefinitionRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Retrieves all entity associated with the specified workspace and specified entity type.This will also fetch all relevant linked entities.
   * Get all entity types for an workspace for a provided entity type
   */
  async getEntityByTypeIdForWorkspaceRaw(
    requestParameters: GetEntityByTypeIdForWorkspaceRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<Array<Entity>>> {
    if (requestParameters['workspaceId'] == null) {
      throw new runtime.RequiredError(
        'workspaceId',
        'Required parameter "workspaceId" was null or undefined when calling getEntityByTypeIdForWorkspace().',
      );
    }

    if (requestParameters['id'] == null) {
      throw new runtime.RequiredError(
        'id',
        'Required parameter "id" was null or undefined when calling getEntityByTypeIdForWorkspace().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('bearerAuth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }

    let urlPath = `/api/v1/entity/workspace/{workspaceId}/type/{id}`;
    urlPath = urlPath.replace(
      `{${'workspaceId'}}`,
      encodeURIComponent(String(requestParameters['workspaceId'])),
    );
    urlPath = urlPath.replace(`{${'id'}}`, encodeURIComponent(String(requestParameters['id'])));

    const response = await this.request(
      {
        path: urlPath,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(EntityFromJSON));
  }

  /**
   * Retrieves all entity associated with the specified workspace and specified entity type.This will also fetch all relevant linked entities.
   * Get all entity types for an workspace for a provided entity type
   */
  async getEntityByTypeIdForWorkspace(
    requestParameters: GetEntityByTypeIdForWorkspaceRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<Array<Entity>> {
    const response = await this.getEntityByTypeIdForWorkspaceRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Retrieves all entity associated with the specified workspace and specified entity types.This will also fetch all relevant linked entities.
   * Get all entity types for an workspace for all provided type keys
   */
  async getEntityByTypeIdInForWorkspaceRaw(
    requestParameters: GetEntityByTypeIdInForWorkspaceRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<{ [key: string]: Array<Entity> }>> {
    if (requestParameters['workspaceId'] == null) {
      throw new runtime.RequiredError(
        'workspaceId',
        'Required parameter "workspaceId" was null or undefined when calling getEntityByTypeIdInForWorkspace().',
      );
    }

    if (requestParameters['ids'] == null) {
      throw new runtime.RequiredError(
        'ids',
        'Required parameter "ids" was null or undefined when calling getEntityByTypeIdInForWorkspace().',
      );
    }

    const queryParameters: any = {};

    if (requestParameters['ids'] != null) {
      queryParameters['ids'] = requestParameters['ids'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('bearerAuth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }

    let urlPath = `/api/v1/entity/workspace/{workspaceId}`;
    urlPath = urlPath.replace(
      `{${'workspaceId'}}`,
      encodeURIComponent(String(requestParameters['workspaceId'])),
    );

    const response = await this.request(
      {
        path: urlPath,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse<any>(response);
  }

  /**
   * Retrieves all entity associated with the specified workspace and specified entity types.This will also fetch all relevant linked entities.
   * Get all entity types for an workspace for all provided type keys
   */
  async getEntityByTypeIdInForWorkspace(
    requestParameters: GetEntityByTypeIdInForWorkspaceRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<{ [key: string]: Array<Entity> }> {
    const response = await this.getEntityByTypeIdInForWorkspaceRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Retrieves a specific entity type by its key associated with the specified workspace.
   * Get an entity type by key for an workspace
   */
  async getEntityTypeByKeyForWorkspaceRaw(
    requestParameters: GetEntityTypeByKeyForWorkspaceRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<EntityType>> {
    if (requestParameters['workspaceId'] == null) {
      throw new runtime.RequiredError(
        'workspaceId',
        'Required parameter "workspaceId" was null or undefined when calling getEntityTypeByKeyForWorkspace().',
      );
    }

    if (requestParameters['key'] == null) {
      throw new runtime.RequiredError(
        'key',
        'Required parameter "key" was null or undefined when calling getEntityTypeByKeyForWorkspace().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('bearerAuth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }

    let urlPath = `/api/v1/entity/schema/workspace/{workspaceId}/key/{key}`;
    urlPath = urlPath.replace(
      `{${'workspaceId'}}`,
      encodeURIComponent(String(requestParameters['workspaceId'])),
    );
    urlPath = urlPath.replace(`{${'key'}}`, encodeURIComponent(String(requestParameters['key'])));

    const response = await this.request(
      {
        path: urlPath,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => EntityTypeFromJSON(jsonValue));
  }

  /**
   * Retrieves a specific entity type by its key associated with the specified workspace.
   * Get an entity type by key for an workspace
   */
  async getEntityTypeByKeyForWorkspace(
    requestParameters: GetEntityTypeByKeyForWorkspaceRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<EntityType> {
    const response = await this.getEntityTypeByKeyForWorkspaceRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Retrieves all entity types associated with the specified workspace.
   * Get all entity types for an workspace
   */
  async getEntityTypesForWorkspaceRaw(
    requestParameters: GetEntityTypesForWorkspaceRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<Array<EntityType>>> {
    if (requestParameters['workspaceId'] == null) {
      throw new runtime.RequiredError(
        'workspaceId',
        'Required parameter "workspaceId" was null or undefined when calling getEntityTypesForWorkspace().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('bearerAuth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }

    let urlPath = `/api/v1/entity/schema/workspace/{workspaceId}`;
    urlPath = urlPath.replace(
      `{${'workspaceId'}}`,
      encodeURIComponent(String(requestParameters['workspaceId'])),
    );

    const response = await this.request(
      {
        path: urlPath,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(EntityTypeFromJSON));
  }

  /**
   * Retrieves all entity types associated with the specified workspace.
   * Get all entity types for an workspace
   */
  async getEntityTypesForWorkspace(
    requestParameters: GetEntityTypesForWorkspaceRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<Array<EntityType>> {
    const response = await this.getEntityTypesForWorkspaceRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Saves either a new entity, or an updated instance within the specified workspace.
   * Saves an entity instance
   */
  async saveEntityRaw(
    requestParameters: SaveEntityOperationRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<SaveEntityResponse>> {
    if (requestParameters['workspaceId'] == null) {
      throw new runtime.RequiredError(
        'workspaceId',
        'Required parameter "workspaceId" was null or undefined when calling saveEntity().',
      );
    }

    if (requestParameters['entityTypeId'] == null) {
      throw new runtime.RequiredError(
        'entityTypeId',
        'Required parameter "entityTypeId" was null or undefined when calling saveEntity().',
      );
    }

    if (requestParameters['saveEntityRequest'] == null) {
      throw new runtime.RequiredError(
        'saveEntityRequest',
        'Required parameter "saveEntityRequest" was null or undefined when calling saveEntity().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('bearerAuth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }

    let urlPath = `/api/v1/entity/workspace/{workspaceId}/type/{entityTypeId}`;
    urlPath = urlPath.replace(
      `{${'workspaceId'}}`,
      encodeURIComponent(String(requestParameters['workspaceId'])),
    );
    urlPath = urlPath.replace(
      `{${'entityTypeId'}}`,
      encodeURIComponent(String(requestParameters['entityTypeId'])),
    );

    const response = await this.request(
      {
        path: urlPath,
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: SaveEntityRequestToJSON(requestParameters['saveEntityRequest']),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      SaveEntityResponseFromJSON(jsonValue),
    );
  }

  /**
   * Saves either a new entity, or an updated instance within the specified workspace.
   * Saves an entity instance
   */
  async saveEntity(
    requestParameters: SaveEntityOperationRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<SaveEntityResponse> {
    const response = await this.saveEntityRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Adds or updates an attribute or relationship in the specified entity type for the given workspace.
   * Add or update an attribute or relationship
   */
  async saveEntityTypeDefinitionRaw(
    requestParameters: SaveEntityTypeDefinitionRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<EntityTypeImpactResponse>> {
    if (requestParameters['workspaceId'] == null) {
      throw new runtime.RequiredError(
        'workspaceId',
        'Required parameter "workspaceId" was null or undefined when calling saveEntityTypeDefinition().',
      );
    }

    if (requestParameters['saveTypeDefinitionRequest'] == null) {
      throw new runtime.RequiredError(
        'saveTypeDefinitionRequest',
        'Required parameter "saveTypeDefinitionRequest" was null or undefined when calling saveEntityTypeDefinition().',
      );
    }

    const queryParameters: any = {};

    if (requestParameters['impactConfirmed'] != null) {
      queryParameters['impactConfirmed'] = requestParameters['impactConfirmed'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('bearerAuth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }

    let urlPath = `/api/v1/entity/schema/workspace/{workspaceId}/definition`;
    urlPath = urlPath.replace(
      `{${'workspaceId'}}`,
      encodeURIComponent(String(requestParameters['workspaceId'])),
    );

    const response = await this.request(
      {
        path: urlPath,
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: SaveTypeDefinitionRequestToJSON(requestParameters['saveTypeDefinitionRequest']),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      EntityTypeImpactResponseFromJSON(jsonValue),
    );
  }

  /**
   * Adds or updates an attribute or relationship in the specified entity type for the given workspace.
   * Add or update an attribute or relationship
   */
  async saveEntityTypeDefinition(
    requestParameters: SaveEntityTypeDefinitionRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<EntityTypeImpactResponse> {
    const response = await this.saveEntityTypeDefinitionRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Updates the data for an already existing entity type for the specified workspace.
   * Updates an existing entity type configuration
   */
  async updateEntityTypeRaw(
    requestParameters: UpdateEntityTypeRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<EntityType>> {
    if (requestParameters['workspaceId'] == null) {
      throw new runtime.RequiredError(
        'workspaceId',
        'Required parameter "workspaceId" was null or undefined when calling updateEntityType().',
      );
    }

    if (requestParameters['entityType'] == null) {
      throw new runtime.RequiredError(
        'entityType',
        'Required parameter "entityType" was null or undefined when calling updateEntityType().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('bearerAuth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }

    let urlPath = `/api/v1/entity/schema/workspace/{workspaceId}/configuration`;
    urlPath = urlPath.replace(
      `{${'workspaceId'}}`,
      encodeURIComponent(String(requestParameters['workspaceId'])),
    );

    const response = await this.request(
      {
        path: urlPath,
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: EntityTypeToJSON(requestParameters['entityType']),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => EntityTypeFromJSON(jsonValue));
  }

  /**
   * Updates the data for an already existing entity type for the specified workspace.
   * Updates an existing entity type configuration
   */
  async updateEntityType(
    requestParameters: UpdateEntityTypeRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<EntityType> {
    const response = await this.updateEntityTypeRaw(requestParameters, initOverrides);
    return await response.value();
  }
}
