---
phase: 02-supabase-adapter
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/auth/auth-error.ts
  - lib/auth/adapters/supabase/mappers.ts
  - lib/auth/adapters/supabase/error-mapper.ts
  - lib/auth/adapters/supabase/supabase-adapter.ts
  - lib/auth/factory.ts
  - lib/auth/index.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "SupabaseAuthAdapter implements all 9 AuthProvider interface methods"
    - "Adapter maps Supabase types to domain types (Session, User)"
    - "Adapter translates Supabase errors to AuthError with appropriate codes"
    - "Factory reads AUTH_PROVIDER env var and returns SupabaseAuthAdapter when set to 'supabase'"
    - "Factory throws descriptive error for missing or unknown AUTH_PROVIDER"
  artifacts:
    - path: "lib/auth/adapters/supabase/supabase-adapter.ts"
      provides: "SupabaseAuthAdapter class"
      exports: ["SupabaseAuthAdapter"]
    - path: "lib/auth/adapters/supabase/mappers.ts"
      provides: "Type transformation functions"
      exports: ["mapSupabaseSession", "mapSupabaseUser", "mapAuthChangeEvent"]
    - path: "lib/auth/adapters/supabase/error-mapper.ts"
      provides: "Error translation"
      exports: ["mapSupabaseError"]
    - path: "lib/auth/factory.ts"
      provides: "Provider factory"
      exports: ["createAuthProvider"]
  key_links:
    - from: "lib/auth/adapters/supabase/supabase-adapter.ts"
      to: "lib/auth/adapters/supabase/mappers.ts"
      via: "import mapSupabaseSession, mapSupabaseUser"
      pattern: "import.*mapSupabase"
    - from: "lib/auth/adapters/supabase/supabase-adapter.ts"
      to: "lib/auth/adapters/supabase/error-mapper.ts"
      via: "import mapSupabaseError"
      pattern: "import.*mapSupabaseError"
    - from: "lib/auth/factory.ts"
      to: "lib/auth/adapters/supabase/supabase-adapter.ts"
      via: "import SupabaseAuthAdapter"
      pattern: "new SupabaseAuthAdapter"
---

<objective>
Implement SupabaseAuthAdapter class that implements AuthProvider interface and create provider factory.

Purpose: Enable consuming code to use auth via the abstraction layer. The adapter translates between Supabase SDK and domain types, while the factory provides a single entry point for obtaining the configured provider.

Output: Working adapter with all 9 interface methods, error mapping, type transformation, and factory with env var configuration.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-supabase-adapter/02-CONTEXT.md
@.planning/phases/02-supabase-adapter/02-RESEARCH.md
@.planning/phases/01-interface-types/01-01-SUMMARY.md

# Existing files to modify/reference
@lib/auth/auth-provider.interface.ts
@lib/auth/auth.types.ts
@lib/auth/auth-error.ts
@lib/auth/index.ts
@lib/util/supabase/client.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create mappers and error handling</name>
  <files>
    lib/auth/auth-error.ts
    lib/auth/adapters/supabase/mappers.ts
    lib/auth/adapters/supabase/error-mapper.ts
  </files>
  <action>
    1. Update lib/auth/auth-error.ts:
       - Add RATE_LIMITED to AuthErrorCode enum (after INVALID_TOKEN, before UNKNOWN_ERROR)

    2. Create lib/auth/adapters/supabase/mappers.ts with:
       - mapSupabaseSession(supabaseSession: SupabaseSession): Session
         - Map access_token, calculate expires_at (use expires_in if expires_at missing)
         - Call mapSupabaseUser for nested user
       - mapSupabaseUser(supabaseUser: SupabaseUser): User
         - Map id, email (default to empty string if undefined), user_metadata to metadata
       - mapAuthChangeEvent(event: string): AuthChangeEvent | null
         - Map SIGNED_IN, SIGNED_OUT, TOKEN_REFRESHED, USER_UPDATED, PASSWORD_RECOVERY
         - Return null for unmapped events (INITIAL_SESSION, MFA events)

    3. Create lib/auth/adapters/supabase/error-mapper.ts with:
       - ERROR_CODE_MAP constant mapping Supabase error codes to AuthErrorCode:
         - invalid_credentials -> INVALID_CREDENTIALS
         - session_expired, session_not_found, refresh_token_not_found, refresh_token_already_used -> SESSION_EXPIRED
         - user_not_found -> USER_NOT_FOUND
         - email_not_confirmed -> EMAIL_NOT_CONFIRMED
         - weak_password -> WEAK_PASSWORD
         - email_exists, user_already_exists -> EMAIL_TAKEN
         - bad_jwt, otp_expired, flow_state_expired, bad_code_verifier -> INVALID_TOKEN
         - over_request_rate_limit, over_email_send_rate_limit, over_sms_send_rate_limit -> RATE_LIMITED
       - mapSupabaseError(error: unknown): AuthError
         - Use isAuthError from @supabase/supabase-js to detect Supabase errors
         - Look up error.code in ERROR_CODE_MAP, default to UNKNOWN_ERROR
         - Set error.cause to preserve original error
         - Include hint via getHintForCode helper
       - getHintForCode(code: AuthErrorCode): string | undefined
         - Return user-friendly hints for common codes

    Import types from @supabase/supabase-js (Session as SupabaseSession, User as SupabaseUser, isAuthError as isSupabaseAuthError).
    Import AuthError, AuthErrorCode from ../../auth-error.
    Import Session, User, AuthChangeEvent from ../../auth.types.
  </action>
  <verify>
    npx tsc --noEmit lib/auth/adapters/supabase/mappers.ts lib/auth/adapters/supabase/error-mapper.ts
    grep -q "RATE_LIMITED" lib/auth/auth-error.ts
  </verify>
  <done>
    - AuthErrorCode includes RATE_LIMITED
    - mappers.ts exports mapSupabaseSession, mapSupabaseUser, mapAuthChangeEvent
    - error-mapper.ts exports mapSupabaseError with comprehensive error code mapping
    - All files type-check cleanly
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement SupabaseAuthAdapter class</name>
  <files>lib/auth/adapters/supabase/supabase-adapter.ts</files>
  <action>
    Create lib/auth/adapters/supabase/supabase-adapter.ts implementing AuthProvider:

    Class structure:
    - private readonly client: SupabaseClient
    - Constructor: validate NEXT_PUBLIC_SUPABASE_URL and NEXT_PUBLIC_SUPABASE_ANON_KEY, create client via createBrowserClient with autoRefreshToken: true, persistSession: true
    - get supabaseClient(): SupabaseClient (escape hatch getter)

    Implement all 9 interface methods:

    1. getSession(): Promise<Session | null>
       - Call client.auth.getSession()
       - Return null if no session, map otherwise

    2. getUser(): Promise<User | null>
       - Call client.auth.getUser()
       - Return null if no user, map otherwise

    3. onAuthStateChange(callback): AuthSubscription
       - Call client.auth.onAuthStateChange
       - Map event via mapAuthChangeEvent, skip if null
       - Map session if present
       - Return { unsubscribe } object

    4. signIn(credentials: SignInCredentials): Promise<Session>
       - Switch on credentials.type (password | otp | phone)
       - password: signInWithPassword({ email, password })
       - otp: verifyOtp({ email, token, type: "email" })
       - phone: signInWithPassword({ phone, password })
       - Add exhaustive check with never type
       - Throw mapSupabaseError on error
       - Throw AuthError if no session returned
       - Return mapped session

    5. signUp(credentials: SignUpCredentials): Promise<Session>
       - Call client.auth.signUp({ email, password })
       - Check for obfuscated user (empty user_metadata = email exists)
       - Throw EMAIL_TAKEN if obfuscated
       - Throw EMAIL_NOT_CONFIRMED if no session (confirmation required)
       - Return mapped session

    6. signOut(): Promise<void>
       - Call client.auth.signOut()
       - Throw mapSupabaseError on error

    7. signInWithOAuth(provider, options?): Promise<void>
       - Call client.auth.signInWithOAuth with provider and options (redirectTo, scopes joined)
       - Throw mapSupabaseError on error
       - Redirect: window.location.href = data.url

    8. verifyOtp(params: OtpVerificationParams): Promise<Session>
       - Call client.auth.verifyOtp({ email, token, type })
       - Throw mapSupabaseError on error
       - Throw AuthError if no session
       - Return mapped session

    9. resendOtp(params: OtpResendParams): Promise<void>
       - Call client.auth.resend({ email, type })
       - Throw mapSupabaseError on error

    Use imports from ./mappers and ./error-mapper. Import types from @supabase/ssr for createBrowserClient.
  </action>
  <verify>
    npx tsc --noEmit lib/auth/adapters/supabase/supabase-adapter.ts
    grep -q "implements AuthProvider" lib/auth/adapters/supabase/supabase-adapter.ts
    grep -c "async.*Promise" lib/auth/adapters/supabase/supabase-adapter.ts  # Should show 8 (all async methods)
  </verify>
  <done>
    - SupabaseAuthAdapter class implements AuthProvider interface
    - All 9 methods implemented with proper error handling
    - Discriminated union handling with exhaustive switch
    - Type-safe with no any types
    - Compiles cleanly
  </done>
</task>

<task type="auto">
  <name>Task 3: Create factory and update exports</name>
  <files>
    lib/auth/factory.ts
    lib/auth/index.ts
  </files>
  <action>
    1. Create lib/auth/factory.ts:
       - let cachedProvider: AuthProvider | null = null (module-level singleton cache)
       - createAuthProvider(): AuthProvider function
         - Return cachedProvider if exists
         - Read process.env.AUTH_PROVIDER
         - Throw descriptive error if not set: "AUTH_PROVIDER environment variable is not set. Please set it to one of: supabase"
         - Switch on providerType:
           - "supabase": new SupabaseAuthAdapter()
           - default: throw "Unknown auth provider: \"{providerType}\". Supported providers: supabase"
         - Cache and return provider
       - Export createAuthProvider

    2. Update lib/auth/index.ts barrel export:
       - Add: export { createAuthProvider } from "./factory"
       - Add: export { SupabaseAuthAdapter } from "./adapters/supabase/supabase-adapter"
       - Keep all existing exports (types, AuthError, isAuthError, AuthProvider)

    Do NOT export mappers or error-mapper directly - they are internal to the adapter.
  </action>
  <verify>
    npx tsc --noEmit lib/auth/index.ts
    node -e "const f = require('./lib/auth/factory.ts'); console.log(typeof f)" 2>&1 | head -5  # Just verify file parses
    grep -q "createAuthProvider" lib/auth/index.ts
    grep -q "SupabaseAuthAdapter" lib/auth/index.ts
  </verify>
  <done>
    - factory.ts exports createAuthProvider with singleton caching
    - Factory throws descriptive errors for missing/unknown AUTH_PROVIDER
    - index.ts exports createAuthProvider and SupabaseAuthAdapter
    - Full module compiles cleanly
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Full type check: `npx tsc --noEmit`
2. Verify no @supabase imports leak outside adapter directory: `grep -r "@supabase" lib/auth/ --include="*.ts" | grep -v "adapters/supabase"`
3. Verify interface implementation: Manually check SupabaseAuthAdapter has all 9 AuthProvider methods
4. Verify factory works:
   ```typescript
   // Would throw: AUTH_PROVIDER not set
   // AUTH_PROVIDER=supabase would work (requires Supabase env vars)
   ```
</verification>

<success_criteria>
1. SupabaseAuthAdapter class implements all 9 AuthProvider interface methods
2. Type mappers correctly transform Supabase types to domain types
3. Error mapper translates Supabase error codes to AuthErrorCode (including RATE_LIMITED)
4. Factory reads AUTH_PROVIDER env var, returns SupabaseAuthAdapter for "supabase"
5. Factory throws descriptive error for missing or unknown AUTH_PROVIDER
6. No @supabase imports outside lib/auth/adapters/supabase/ directory
7. All files compile cleanly with strict TypeScript
</success_criteria>

<output>
After completion, create `.planning/phases/02-supabase-adapter/02-01-SUMMARY.md`
</output>
