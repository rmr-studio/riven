---
phase: 01-interface-types
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/auth/auth.types.ts
  - lib/auth/auth-error.ts
  - lib/auth/auth-provider.interface.ts
  - lib/auth/index.ts
autonomous: true

must_haves:
  truths:
    - "AuthProvider interface can be imported from lib/auth"
    - "Session and User types are provider-agnostic (no Supabase imports)"
    - "signIn accepts discriminated credential types (password, otp, phone)"
    - "AuthError can be caught and narrowed with isAuthError type guard"
    - "All interface methods return Promises"
  artifacts:
    - path: "lib/auth/auth.types.ts"
      provides: "Session, User, credential types, OAuth types, event types"
      contains: "SignInCredentials"
    - path: "lib/auth/auth-error.ts"
      provides: "AuthError class, AuthErrorCode enum, isAuthError guard"
      exports: ["AuthError", "AuthErrorCode", "isAuthError"]
    - path: "lib/auth/auth-provider.interface.ts"
      provides: "AuthProvider interface contract"
      exports: ["AuthProvider"]
    - path: "lib/auth/index.ts"
      provides: "Barrel export for lib/auth module"
      contains: "export *"
  key_links:
    - from: "lib/auth/auth-provider.interface.ts"
      to: "lib/auth/auth.types.ts"
      via: "import types for method signatures"
      pattern: "import.*from.*auth\\.types"
    - from: "lib/auth/auth-provider.interface.ts"
      to: "lib/auth/auth-error.ts"
      via: "documents thrown error type"
      pattern: "AuthError"
---

<objective>
Define the provider-agnostic authentication interface and domain types that all adapters will implement.

Purpose: Establish the contract that decouples auth consumers from specific providers. This interface enables the adapter pattern where Supabase (Phase 2) and future providers implement the same API.

Output: Complete TypeScript interface and type definitions in `lib/auth/` that can be imported and implemented by adapters.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-interface-types/01-CONTEXT.md
@.planning/phases/01-interface-types/01-RESEARCH.md
@.planning/codebase/CONVENTIONS.md
@lib/util/error/error.util.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create auth domain types</name>
  <files>lib/auth/auth.types.ts</files>
  <action>
Create `lib/auth/auth.types.ts` with provider-agnostic domain types.

**Session type:**
```typescript
interface Session {
    access_token: string;
    expires_at: number;  // Unix timestamp in seconds
    user: User;
}
```

**User type:**
```typescript
interface User {
    id: string;
    email: string;
    metadata: Record<string, unknown>;  // Provider-specific data
}
```

**Credential types (discriminated union):**
- `PasswordCredentials`: `{ type: 'password', email: string, password: string }`
- `OtpCredentials`: `{ type: 'otp', email: string, token: string }`
- `PhoneCredentials`: `{ type: 'phone', phone: string, password: string }`
- `SignInCredentials`: Union of all three
- `SignUpCredentials`: Password-only for now: `{ email: string, password: string }`

**OAuth types:**
```typescript
enum OAuthProvider {
    Google = 'google',
    GitHub = 'github',
}

interface OAuthOptions {
    redirectTo?: string;
    scopes?: string[];
}
```

**OTP types:**
```typescript
interface OtpVerificationParams {
    email: string;
    token: string;
    type: 'signup' | 'recovery' | 'email_change';
}

interface OtpResendParams {
    email: string;
    type: 'signup' | 'recovery' | 'email_change';
}
```

**Auth state change types:**
```typescript
type AuthChangeEvent =
    | 'SIGNED_IN'
    | 'SIGNED_OUT'
    | 'TOKEN_REFRESHED'
    | 'USER_UPDATED'
    | 'PASSWORD_RECOVERY';

interface AuthSubscription {
    unsubscribe: () => void;
}
```

Follow codebase conventions:
- Use `interface` for object shapes, `type` for unions
- Export all types as named exports
- No imports from @supabase/supabase-js
  </action>
  <verify>
- File exists at `lib/auth/auth.types.ts`
- `npx tsc --noEmit lib/auth/auth.types.ts` passes
- File contains no imports from @supabase
  </verify>
  <done>
Session, User, SignInCredentials, SignUpCredentials, OAuthProvider, OAuthOptions, OtpVerificationParams, OtpResendParams, AuthChangeEvent, and AuthSubscription types are defined and exportable.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create AuthError class and type guard</name>
  <files>lib/auth/auth-error.ts</files>
  <action>
Create `lib/auth/auth-error.ts` with auth-specific error handling.

**AuthErrorCode enum:**
```typescript
enum AuthErrorCode {
    INVALID_CREDENTIALS = 'INVALID_CREDENTIALS',
    SESSION_EXPIRED = 'SESSION_EXPIRED',
    USER_NOT_FOUND = 'USER_NOT_FOUND',
    EMAIL_NOT_CONFIRMED = 'EMAIL_NOT_CONFIRMED',
    WEAK_PASSWORD = 'WEAK_PASSWORD',
    EMAIL_TAKEN = 'EMAIL_TAKEN',
    INVALID_TOKEN = 'INVALID_TOKEN',
    UNKNOWN_ERROR = 'UNKNOWN_ERROR',
}
```

**AuthError class:**
```typescript
class AuthError extends Error {
    constructor(
        message: string,
        public readonly code: AuthErrorCode,
        public readonly hint?: string
    ) {
        super(message);
        this.name = 'AuthError';
        // Fix prototype chain for instanceof checks
        Object.setPrototypeOf(this, AuthError.prototype);
    }
}
```

**Type guard:**
```typescript
function isAuthError(error: unknown): error is AuthError {
    return error instanceof AuthError;
}
```

Follow existing error pattern from `lib/util/error/error.util.ts`:
- Type guard function mirrors `isResponseError` pattern
- Class extends Error with additional typed properties
- Include JSDoc comments for the class and guard function
  </action>
  <verify>
- File exists at `lib/auth/auth-error.ts`
- `npx tsc --noEmit lib/auth/auth-error.ts` passes
- AuthError, AuthErrorCode, and isAuthError are exported
  </verify>
  <done>
AuthError class can be instantiated with message, code, and optional hint. isAuthError type guard correctly narrows unknown errors to AuthError type.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create AuthProvider interface and barrel export</name>
  <files>lib/auth/auth-provider.interface.ts, lib/auth/index.ts</files>
  <action>
Create `lib/auth/auth-provider.interface.ts` with the provider contract.

**AuthProvider interface:**
```typescript
import {
    Session,
    User,
    SignInCredentials,
    SignUpCredentials,
    OAuthProvider,
    OAuthOptions,
    OtpVerificationParams,
    OtpResendParams,
    AuthChangeEvent,
    AuthSubscription,
} from './auth.types';

/**
 * Provider-agnostic authentication interface.
 * Adapters implement this to normalize different auth backends.
 */
interface AuthProvider {
    // Session/user access
    getSession(): Promise<Session | null>;
    getUser(): Promise<User | null>;
    onAuthStateChange(
        callback: (event: AuthChangeEvent, session: Session | null) => void
    ): AuthSubscription;

    // Auth actions - throw AuthError on failure
    signIn(credentials: SignInCredentials): Promise<Session>;
    signUp(credentials: SignUpCredentials): Promise<Session>;
    signOut(): Promise<void>;
    signInWithOAuth(provider: OAuthProvider, options?: OAuthOptions): Promise<void>;
    verifyOtp(params: OtpVerificationParams): Promise<Session>;
    resendOtp(params: OtpResendParams): Promise<void>;
}
```

Include JSDoc comment documenting:
- Purpose of the interface
- That adapters implement this
- That auth action methods throw AuthError on failure

**Barrel export (lib/auth/index.ts):**
```typescript
export * from './auth.types';
export * from './auth-error';
export type { AuthProvider } from './auth-provider.interface';
```

Use `export type` for AuthProvider since it's an interface (type-only export).
  </action>
  <verify>
- Files exist at `lib/auth/auth-provider.interface.ts` and `lib/auth/index.ts`
- `npx tsc --noEmit lib/auth/index.ts` passes
- All types importable from `@/lib/auth`: `import { AuthProvider, Session, User, AuthError, isAuthError } from '@/lib/auth'`
  </verify>
  <done>
AuthProvider interface defines all required methods (getSession, getUser, onAuthStateChange, signIn, signUp, signOut, signInWithOAuth, verifyOtp, resendOtp). Barrel export allows single import point for all auth types.
  </done>
</task>

</tasks>

<verification>
Run the following to verify the phase is complete:

1. **Type check the module:**
   ```bash
   npx tsc --noEmit lib/auth/index.ts
   ```

2. **Verify no Supabase imports:**
   ```bash
   grep -r "@supabase" lib/auth/
   # Should return no results
   ```

3. **Verify exports are accessible:**
   Create a temporary test file and verify these imports work:
   ```typescript
   import {
       AuthProvider,
       Session,
       User,
       SignInCredentials,
       SignUpCredentials,
       OAuthProvider,
       OAuthOptions,
       AuthChangeEvent,
       AuthSubscription,
       AuthError,
       AuthErrorCode,
       isAuthError,
   } from '@/lib/auth';
   ```

4. **Verify discriminated union:**
   The SignInCredentials type should narrow correctly in switch statements on the `type` field.
</verification>

<success_criteria>
- AuthProvider interface exists with all 9 methods (getSession, getUser, onAuthStateChange, signIn, signUp, signOut, signInWithOAuth, verifyOtp, resendOtp)
- All methods return Promises (async-only per user decision)
- Session and User types are minimal and provider-agnostic
- SignInCredentials uses discriminated union with 'type' field
- AuthError class has code (enum) and optional hint
- isAuthError type guard enables safe error narrowing
- No imports from @supabase/supabase-js in any file
- All types importable from single `@/lib/auth` entry point
</success_criteria>

<output>
After completion, create `.planning/phases/01-interface-types/01-01-SUMMARY.md` following the summary template.

The summary should capture:
- Files created (lib/auth/*.ts)
- Types defined (list each exported type)
- Patterns established (discriminated unions, error handling)
- Ready for Phase 2 (Supabase adapter can implement AuthProvider)
</output>
