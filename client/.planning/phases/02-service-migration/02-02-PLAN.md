---
phase: 02-service-migration
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - components/feature-modules/entity/service/entity.service.ts
autonomous: true

must_haves:
  truths:
    - "EntityService methods use EntityApi instead of manual fetch"
    - "400 and 409 responses for saveEntity return data, not throw errors"
    - "Validation errors (validateSession, validateUuid) still provide clear messages"
  artifacts:
    - path: "components/feature-modules/entity/service/entity.service.ts"
      provides: "Migrated EntityService using EntityApi"
      contains: "createEntityApi"
  key_links:
    - from: "entity.service.ts"
      to: "lib/api/entity-api.ts"
      via: "import createEntityApi"
      pattern: "import.*createEntityApi.*from.*@/lib/api/entity-api"
---

<objective>
Migrate EntityService from manual fetch to generated EntityApi wrapper.

Purpose: Completes SRVC-02 requirement, migrating the entity instance service (4 methods) including proper 400/409 handling for saveEntity.

Output: Fully migrated `entity.service.ts` using the API factory from Plan 01
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-service-migration/02-RESEARCH.md
@.planning/phases/02-service-migration/02-01-SUMMARY.md
@components/feature-modules/entity/service/entity.service.ts
@lib/api/entity-api.ts
@lib/types/apis/EntityApi.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migrate EntityService to use EntityApi</name>
  <files>components/feature-modules/entity/service/entity.service.ts</files>
  <action>
Migrate all 4 methods in EntityService from manual fetch to EntityApi.

**Import changes:**
- Remove: `import { api } from "@/lib/util/utils";`
- Add: `import { createEntityApi } from "@/lib/api/entity-api";`
- Add: `import { ResponseError } from "@/lib/types";`
- Keep: `validateSession`, `validateUuid` from service.util (for early validation)
- Remove: `handleError` (no longer needed with EntityApi)
- Remove: `fromError`, `isResponseError` (no longer needed)

**Method migration mapping (from RESEARCH.md):**

1. `saveEntity(session, workspaceId, entityTypeId, request)` -> **Catch 400 and 409**
   - `api.saveEntity({ workspaceId, entityTypeId, saveEntityRequest: request })`
   - Catch ResponseError with status 400 OR 409, return `error.response.json()`
   - Both validation errors (400) and impact errors (409) return SaveEntityResponse payload

2. `getEntitiesForType(session, workspaceId, typeId)` -> Simple case
   - `api.getEntityByTypeIdForWorkspace({ workspaceId, id: typeId })`

3. `getEntitiesForTypes(session, workspaceId, typeIds)` -> Simple case
   - `api.getEntityByTypeIdInForWorkspace({ workspaceId, ids: typeIds })`
   - Note: The generated API handles array query params automatically

4. `deleteEntities(session, workspaceId, entityIds)` -> Simple case
   - `api.deleteEntity({ workspaceId, requestBody: entityIds })`

**Pattern for 400/409-handling method (saveEntity):**
```typescript
static async saveEntity(
    session: Session | null,
    workspaceId: string,
    entityTypeId: string,
    request: SaveEntityRequest
): Promise<SaveEntityResponse> {
    validateSession(session);
    validateUuid(workspaceId);
    validateUuid(entityTypeId);
    const api = createEntityApi(session!);

    try {
        return await api.saveEntity({
            workspaceId,
            entityTypeId,
            saveEntityRequest: request,
        });
    } catch (error) {
        // Both 400 (validation) and 409 (impact) return SaveEntityResponse payload
        if (error instanceof ResponseError &&
            (error.response.status === 400 || error.response.status === 409)) {
            return await error.response.json();
        }
        throw error;
    }
}
```

**Pattern for simple methods:**
```typescript
static async getEntitiesForType(
    session: Session | null,
    workspaceId: string,
    typeId: string
): Promise<Entity[]> {
    validateSession(session);
    validateUuid(workspaceId);
    validateUuid(typeId);
    const api = createEntityApi(session!);
    return api.getEntityByTypeIdForWorkspace({ workspaceId, id: typeId });
}
```

**Critical:** Use `session!` (non-null assertion) after `validateSession(session)` since validation throws if null.
  </action>
  <verify>
- TypeScript compiles: `npx tsc --noEmit components/feature-modules/entity/service/entity.service.ts`
- No manual fetch calls remain: `grep -c "fetch(" components/feature-modules/entity/service/entity.service.ts` returns 0
- Uses createEntityApi: `grep -c "createEntityApi" components/feature-modules/entity/service/entity.service.ts` returns 4 (one per method)
  </verify>
  <done>
All 4 EntityService methods use EntityApi:
- 3 simple methods directly return API call results
- 1 method (saveEntity) catches 400 and 409 to return response data
- No manual fetch, no api() utility, no handleError
  </done>
</task>

</tasks>

<verification>
- TypeScript compiles without errors in entity.service.ts
- No `fetch(` calls remain in entity.service.ts
- No `api()` utility usage remains
- `createEntityApi` imported and used in all 4 methods
- `ResponseError` properly caught for saveEntity (400 and 409)
</verification>

<success_criteria>
1. `entity.service.ts` uses EntityApi for all 4 methods
2. saveEntity handles both 400 and 409 responses correctly (returns data)
3. TypeScript compiles without errors
4. Method signatures unchanged (no breaking changes to callers)
</success_criteria>

<output>
After completion, create `.planning/phases/02-service-migration/02-02-SUMMARY.md`
</output>
