---
phase: 02-type-barrels
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/types/entity/models.ts
  - lib/types/entity/requests.ts
  - lib/types/entity/responses.ts
  - lib/types/entity/guards.ts
  - lib/types/entity/custom.ts
  - lib/types/entity/index.ts
  - lib/types/block/models.ts
  - lib/types/block/requests.ts
  - lib/types/block/responses.ts
  - lib/types/block/guards.ts
  - lib/types/block/custom.ts
  - lib/types/block/index.ts
autonomous: true

must_haves:
  truths:
    - "import type { EntityType } from '@/lib/types/entity' resolves correctly"
    - "import type { BlockType } from '@/lib/types/block' resolves correctly"
    - "Type guards isContentMetadata, isReferenceNode, etc. are importable from block barrel"
    - "Type guards isRelationshipDefinition, isAttributeDefinition, etc. are importable from entity barrel"
    - "Custom types EntityTypeDefinition, EntityAttributeRow are importable from entity barrel"
    - "Custom types BlockNode, MetadataUnion are importable from block barrel"
  artifacts:
    - path: "lib/types/entity/index.ts"
      provides: "Barrel aggregation for entity domain"
      contains: "export"
    - path: "lib/types/block/index.ts"
      provides: "Barrel aggregation for block domain"
      contains: "export"
    - path: "lib/types/entity/guards.ts"
      provides: "Type guard functions for entity types"
      contains: "isRelationshipDefinition"
    - path: "lib/types/block/guards.ts"
      provides: "Type guard functions for block types"
      contains: "isContentMetadata"
  key_links:
    - from: "lib/types/entity/index.ts"
      to: "lib/types/entity/models.ts"
      via: "re-export"
      pattern: "export.*from.*models"
    - from: "lib/types/block/index.ts"
      to: "lib/types/block/models.ts"
      via: "re-export"
      pattern: "export.*from.*models"
    - from: "lib/types/entity/guards.ts"
      to: "@/lib/types/models"
      via: "enum import for type narrowing"
      pattern: "import.*EntityPropertyType"
    - from: "lib/types/block/guards.ts"
      to: "@/lib/types/models"
      via: "enum import for type narrowing"
      pattern: "import.*BlockMetadataType"
---

<objective>
Create domain-based barrel exports for entity and block types, consolidating generated OpenAPI types with custom types and type guards into single import paths.

Purpose: Enable `import type { EntityType } from "@/lib/types/entity"` and `import type { BlockType } from "@/lib/types/block"` patterns that provide all domain types through semantic imports.

Output: Complete entity/ and block/ barrel directories with categorized files (models, requests, responses, guards, custom) and index.ts aggregation files.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-type-barrels/02-CONTEXT.md
@.planning/phases/02-type-barrels/02-RESEARCH.md
@components/feature-modules/entity/interface/entity.interface.ts
@components/feature-modules/blocks/interface/block.interface.ts
@components/feature-modules/blocks/interface/layout.interface.ts
@components/feature-modules/blocks/interface/command.interface.ts
@components/feature-modules/entity/hooks/use-relationship-overlap-detection.ts
@lib/types/models/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create entity domain barrel</name>
  <files>
    lib/types/entity/models.ts
    lib/types/entity/requests.ts
    lib/types/entity/responses.ts
    lib/types/entity/guards.ts
    lib/types/entity/custom.ts
    lib/types/entity/index.ts
  </files>
  <action>
Create the lib/types/entity/ directory with categorized barrel files:

**models.ts** - Re-export entity model types from @/lib/types/models:
- Core: Entity, EntityType, EntityCategory, EntityLink
- Attributes: EntityAttribute, EntityAttributePayload, EntityAttributePrimitivePayload, EntityAttributeRelationPayload, EntityAttributeRelationPayloadReference, EntityTypeAttributeColumn
- Relationships: EntityRelationshipDefinition, EntityRelationshipCardinality
- Schema: SchemaUUID, SchemaType, DataType, EntityPropertyType
- Display: DisplayName, Icon, IconColour, IconType
- Impact: EntityImpactSummary, EntityTypeImpactResponse, EntityTypeRelationshipImpactAnalysis, EntityTypeRelationshipDataLossWarning, EntityTypeRelationshipDataLossReason, EntityTypeRelationshipType

**requests.ts** - Re-export entity request types from @/lib/types/models:
- CreateEntityTypeRequest, SaveEntityRequest, SaveTypeDefinitionRequest, SaveTypeDefinitionRequestDefinition
- SaveAttributeDefinitionRequest, SaveRelationshipDefinitionRequest
- DeleteTypeDefinitionRequest, DeleteTypeDefinitionRequestDefinition, DeleteAttributeDefinitionRequest, DeleteRelationshipDefinitionRequest
- EntityAttributeRequest, EntityAttributeRequestPayload, EntityReferenceRequest, EntityTypeRequestDefinition

**responses.ts** - Re-export entity response types from @/lib/types/models:
- SaveEntityResponse, DeleteEntityResponse, EntityTypeImpactResponse

**guards.ts** - Move type guards from entity.interface.ts:
- isRelationshipDefinition(attribute): checks if attribute lacks "schema" property
- isAttributeDefinition(attribute): checks if attribute has "schema" property
- isRelationshipPayload(payload): checks payload.type === EntityPropertyType.Relationship
Import EntityPropertyType enum from @/lib/types/models (not type import, regular import for runtime use).
Import types from ./models and ./custom using type imports.

**custom.ts** - Move custom types from entity.interface.ts:
- EntityTypeDefinition interface (id, type, definition)
- EntityAttributeDefinition interface (id, schema)
- EntityTypeAttributeRow interface (full row type for table display)
- EntityRelationshipCandidate interface (icon, name, key, existingRelationship)
- RelationshipLimit enum (SINGULAR, MANY)
- RelationshipPickerProps interface (component props)
- Re-export overlap detection types: OverlapDetectionResult, OverlapResolution, RelationshipOverlap from their hook file
Import required types from ./models using type imports.

**index.ts** - Aggregate all exports:
- `export type * from "./models";`
- `export type * from "./requests";`
- `export type * from "./responses";`
- `export * from "./guards";` (regular export for functions)
- `export * from "./custom";` (regular export for enum and types)

Use explicit `export type { }` syntax in type-only files (models, requests, responses).
  </action>
  <verify>
Run TypeScript check: `npx tsc --noEmit lib/types/entity/index.ts`
Verify imports resolve: Create temp test file with `import type { EntityType, EntityTypeDefinition } from "@/lib/types/entity"` and run tsc
  </verify>
  <done>
All 6 entity barrel files exist with correct exports. TypeScript compiles without errors. EntityType, EntityTypeDefinition, isRelationshipDefinition are all importable from "@/lib/types/entity".
  </done>
</task>

<task type="auto">
  <name>Task 2: Create block domain barrel</name>
  <files>
    lib/types/block/models.ts
    lib/types/block/requests.ts
    lib/types/block/responses.ts
    lib/types/block/guards.ts
    lib/types/block/custom.ts
    lib/types/block/index.ts
  </files>
  <action>
Create the lib/types/block/ directory with categorized barrel files:

**models.ts** - Re-export block model types from @/lib/types/models:
- Core: Block, BlockType, BlockDisplay, BlockBinding, BlockBindingSource, BlockComponentNode, BlockMeta, BlockPayload, BlockTypeNesting, BlockRenderStructure
- Tree: BlockTree, BlockTreeRoot, BlockTreeLayout, BlockTreeReference, BlockEnvironment, TreeLayout, TreeLayoutColumn
- Node: Node, ContentNode, ReferenceNode
- Metadata: BlockContentMetadata, BlockReferenceMetadata, EntityReferenceMetadata, Metadata, ReferenceMetadata
- Reference: EntityReference, ReferenceItem, ReferenceItemBlockTree, ReferenceItemEntity, ReferencePayload, ReferenceNode, ReferenceType
- Layout: GridRect, LayoutGrid, LayoutGridItem, Widget, BreakpointConfig, ColumnOptions, DraggableOptions, ResizableOptions
- Configuration: BlockListConfiguration, ListConfig, ListDisplayConfig, FormStructure, FormWidgetConfig, RenderContent, Presentation, ThemeTokens
- Operations: BlockOperation, BlockOperationType, AddBlockOperation, AddBlockOperationAllOfBlock, RemoveBlockOperation, MoveBlockOperation, UpdateBlockOperation, UpdateBlockOperationAllOfUpdatedContent, ReorderBlockOperation, StructuralOperationRequest, StructuralOperationRequestData
- Hydration: BlockHydrationResult, HydrateBlocksRequest, BlockFetchPolicy, BlockReferenceFetchPolicy, BlockReferenceWarning
- Binding: BindingSource, Computed, Condition, ConditionLeft, DataPath, FilterSpec, ListFilterLogicType, Op, Operand, Option, OptionSortingType, PagingSpec, Path, Projection, SortDir, SortSpec, ValidationScope, Value

**requests.ts** - Re-export block request types from @/lib/types/models:
- CreateBlockTypeRequest, HydrateBlocksRequest, OverwriteEnvironmentRequest, SaveEnvironmentRequest

**responses.ts** - Re-export block response types from @/lib/types/models:
- BlockHydrationResult, OverwriteEnvironmentResponse, SaveEnvironmentResponse
Also extract GetBlockTypesResponse from operations using: `operations["getBlockTypes"]["responses"]["200"]["content"]["*/*"]` (import operations from @/lib/types/types)

**guards.ts** - Move type guards from block.interface.ts:
- isContentMetadata(payload): checks payload?.type === BlockMetadataType.CONTENT
- isBlockReferenceMetadata(payload): checks payload?.type === BlockMetadataType.BLOCK_REFERENCE
- isEntityReferenceMetadata(payload): checks payload?.type === BlockMetadataType.ENTITY_REFERENCE
- isContentNode(node): checks !!node.block && node.type === NodeType.CONTENT
- isReferenceNode(node): checks !!node.block && node.type === NodeType.REFERENCE
Import BlockMetadataType, NodeType enums from @/lib/types/models (regular import for runtime use).
Import types from ./models and ./custom using type imports.

**custom.ts** - Move/create custom types:
- BlockNode type alias: ContentNode | ReferenceNode
- MetadataUnion type alias: BlockContentMetadata | BlockReferenceMetadata | EntityReferenceMetadata
- ReferencePayloadUnion type alias: EntityReference | BlockTreeReference
- EntityReferencePayload type alias: EntityReference
- BlockReferencePayload type alias: BlockTreeReference
- WidgetRenderStructure type alias: RenderContent
- EntityReferenceHydrationRequest type alias: EntityReferenceRequest (import from @/lib/types/models)
- HydrateBlockRequest type alias: HydrateBlocksRequest
- HydrateBlockResponse type alias: Record<string, BlockHydrationResult>
Import required types from ./models using type imports.

**index.ts** - Aggregate all exports:
- `export type * from "./models";`
- `export type * from "./requests";`
- `export type * from "./responses";`
- `export * from "./guards";` (regular export for functions)
- `export * from "./custom";` (regular export for type aliases)

Use explicit `export type { }` syntax in type-only files (models, requests, responses).
  </action>
  <verify>
Run TypeScript check: `npx tsc --noEmit lib/types/block/index.ts`
Verify imports resolve: Create temp test file with `import type { BlockType, BlockNode } from "@/lib/types/block"` and run tsc
  </verify>
  <done>
All 6 block barrel files exist with correct exports. TypeScript compiles without errors. BlockType, BlockNode, isContentMetadata are all importable from "@/lib/types/block".
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify barrel imports work end-to-end</name>
  <files>test/types/barrel-verification.test.ts</files>
  <action>
Create a TypeScript verification test file that imports from both barrels and confirms types resolve:

```typescript
// test/types/barrel-verification.test.ts
// Verification that domain barrels export correctly

// Entity barrel imports
import type {
    EntityType,
    EntityAttribute,
    EntityRelationshipDefinition,
    EntityTypeDefinition,
    EntityTypeAttributeRow,
    SaveEntityRequest,
    EntityTypeImpactResponse,
} from "@/lib/types/entity";
import {
    isRelationshipDefinition,
    isAttributeDefinition,
    RelationshipLimit,
} from "@/lib/types/entity";

// Block barrel imports
import type {
    Block,
    BlockType,
    BlockTree,
    BlockNode,
    ContentNode,
    CreateBlockTypeRequest,
    BlockHydrationResult,
} from "@/lib/types/block";
import {
    isContentMetadata,
    isContentNode,
    isReferenceNode,
} from "@/lib/types/block";

describe("Type barrel exports", () => {
    it("entity barrel exports types correctly", () => {
        // Type-level checks - if this compiles, types work
        const checkType = (entity: EntityType) => entity.key;
        const checkCustom = (def: EntityTypeDefinition) => def.id;
        const checkEnum = RelationshipLimit.SINGULAR;
        expect(typeof isRelationshipDefinition).toBe("function");
        expect(typeof isAttributeDefinition).toBe("function");
    });

    it("block barrel exports types correctly", () => {
        // Type-level checks - if this compiles, types work
        const checkType = (block: Block) => block.id;
        const checkNode = (node: BlockNode) => node.type;
        expect(typeof isContentMetadata).toBe("function");
        expect(typeof isContentNode).toBe("function");
    });
});
```

Run the test file through TypeScript compiler to verify imports resolve.
  </action>
  <verify>
Run: `npx tsc --noEmit test/types/barrel-verification.test.ts`
Run: `npm test -- test/types/barrel-verification.test.ts`
  </verify>
  <done>
Verification test file exists and passes. TypeScript compiles successfully. Both barrels provide all expected exports.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation passes for all barrel files
2. Both entity and block barrel directories exist with 6 files each
3. Import paths resolve: `@/lib/types/entity` and `@/lib/types/block`
4. Type guards are runtime-callable functions
5. Custom types include all moved types from feature module interfaces
6. Verification test passes
</verification>

<success_criteria>
- `import type { EntityType } from "@/lib/types/entity"` works
- `import type { BlockType } from "@/lib/types/block"` works
- All type guards from entity.interface.ts are accessible via entity barrel
- All type guards from block.interface.ts are accessible via block barrel
- Custom types (EntityTypeDefinition, BlockNode, etc.) are accessible via barrels
- TypeScript compiler passes with no errors
- Verification test passes
</success_criteria>

<output>
After completion, create `.planning/phases/02-type-barrels/02-01-SUMMARY.md`
</output>
